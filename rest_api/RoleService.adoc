// Auto-generated by scripts. Do not edit.
:_mod-docs-content-type: ASSEMBLY



[id="RoleService"]
= RoleService

:toc: macro
:toc-title:

toc::[]



[id="RoleServiceComputeEffectiveAccessScope"]
== ComputeEffectiveAccessScope

`POST /v1/computeeffectiveaccessscope`

ComputeEffectiveAccessScope

=== Description

Returns effective access scope based on the rules in the request. Does not persist anything; not idempotent due to possible changes to clusters and namespaces. POST is chosen due to potentially large payload.  There are advantages in both keeping the response slim and detailed. If only IDs of selected clusters and namespaces are included, response latency and processing time are lower but the caller shall overlay the response with its view of the world which is susceptible to consistency issues. Listing all clusters and namespaces with related metadata is convenient for the caller but bloat the message with secondary data.  We let the caller decide what level of detail they would like to have:    - Minimal, when only roots of included subtrees are listed by their     IDs. Clusters can be either INCLUDED (its namespaces are included but     are not listed) or PARTIAL (at least one namespace is explicitly     included). Namespaces can only be INCLUDED.    - Standard [default], when all known clusters and namespaces are listed     with their IDs and names. Clusters can be INCLUDED (all its     namespaces are explicitly listed as INCLUDED), PARTIAL (all its     namespaces are explicitly listed, some as INCLUDED and some as     EXCLUDED), and EXCLUDED (all its namespaces are explicitly listed as     EXCLUDED). Namespaces can be either INCLUDED or EXCLUDED.    - High, when every cluster and namespace is augmented with metadata.





=== Parameters


==== Body Parameter

[cols="2,3,1,1,1"]
|===
|Name| Description| Required| Default| Pattern

| body
|  <<ComputeEffectiveAccessScopeRequestPayload>>
| X
|
|

|===



==== Query Parameters

[cols="2,3,1,1,1"]
|===
|Name| Description| Required| Default| Pattern

| detail
|
| -
| STANDARD
|

|===


=== Return Type

<<StorageEffectiveAccessScope>>


=== Content Type

* application/json

=== Responses

.HTTP Response Codes
[cols="2,3,1"]
|===
| Code | Message | Datatype


| 200
| A successful response.
|  <<StorageEffectiveAccessScope>>


| 0
| An unexpected error response.
|  <<RuntimeError>>

|===

=== Samples









ifdef::internal-generation[]
=== Implementation



endif::internal-generation[]


[id="RoleServiceCreateRole"]
== CreateRole

`POST /v1/roles/{name}`



=== Description







=== Parameters

==== Path Parameters

[cols="2,3,1,1,1"]
|===
|Name| Description| Required| Default| Pattern

| name
|
| X
| null
|

|===

==== Body Parameter

[cols="2,3,1,1,1"]
|===
|Name| Description| Required| Default| Pattern

| body
|  <<StorageRole>>
| X
|
|

|===





=== Return Type


<<Object>>


=== Content Type

* application/json

=== Responses

.HTTP Response Codes
[cols="2,3,1"]
|===
| Code | Message | Datatype


| 200
| A successful response.
|  <<Object>>


| 0
| An unexpected error response.
|  <<RuntimeError>>

|===

=== Samples









ifdef::internal-generation[]
=== Implementation



endif::internal-generation[]


[id="RoleServiceDeletePermissionSet"]
== DeletePermissionSet

`DELETE /v1/permissionsets/{id}`



=== Description







=== Parameters

==== Path Parameters

[cols="2,3,1,1,1"]
|===
|Name| Description| Required| Default| Pattern

| id
|
| X
| null
|

|===






=== Return Type


<<Object>>


=== Content Type

* application/json

=== Responses

.HTTP Response Codes
[cols="2,3,1"]
|===
| Code | Message | Datatype


| 200
| A successful response.
|  <<Object>>


| 0
| An unexpected error response.
|  <<RuntimeError>>

|===

=== Samples









ifdef::internal-generation[]
=== Implementation



endif::internal-generation[]


[id="RoleServiceDeleteRole"]
== DeleteRole

`DELETE /v1/roles/{id}`



=== Description







=== Parameters

==== Path Parameters

[cols="2,3,1,1,1"]
|===
|Name| Description| Required| Default| Pattern

| id
|
| X
| null
|

|===






=== Return Type


<<Object>>


=== Content Type

* application/json

=== Responses

.HTTP Response Codes
[cols="2,3,1"]
|===
| Code | Message | Datatype


| 200
| A successful response.
|  <<Object>>


| 0
| An unexpected error response.
|  <<RuntimeError>>

|===

=== Samples









ifdef::internal-generation[]
=== Implementation



endif::internal-generation[]


[id="RoleServiceDeleteSimpleAccessScope"]
== DeleteSimpleAccessScope

`DELETE /v1/simpleaccessscopes/{id}`



=== Description







=== Parameters

==== Path Parameters

[cols="2,3,1,1,1"]
|===
|Name| Description| Required| Default| Pattern

| id
|
| X
| null
|

|===






=== Return Type


<<Object>>


=== Content Type

* application/json

=== Responses

.HTTP Response Codes
[cols="2,3,1"]
|===
| Code | Message | Datatype


| 200
| A successful response.
|  <<Object>>


| 0
| An unexpected error response.
|  <<RuntimeError>>

|===

=== Samples









ifdef::internal-generation[]
=== Implementation



endif::internal-generation[]


[id="RoleServiceGetClustersForPermissions"]
== GetClustersForPermissions

`GET /v1/sac/clusters`

GetClustersForPermissions

=== Description

Returns the list of cluster ID and cluster name pairs that have at least read allowed by the scope of the requesting user for the list of requested permissions. Effective access scopes are only considered for input permissions that have cluster scope or narrower (i.e. global permissions from the input are ignored).  If the input only contains permissions at global level, the output will be an empty list.  If no permission is given in input, all clusters allowed by the requester scope for any permission with cluster scope or narrower will be part of the response.





=== Parameters





==== Query Parameters

[cols="2,3,1,1,1"]
|===
|Name| Description| Required| Default| Pattern

| pagination.limit
|
| -
| null
|

| pagination.offset
|
| -
| null
|

| pagination.sortOption.field
|
| -
| null
|

| pagination.sortOption.reversed
|
| -
| null
|

| pagination.sortOption.aggregateBy.aggrFunc
|
| -
| UNSET
|

| pagination.sortOption.aggregateBy.distinct
|
| -
| null
|

| permissions
|  <<String>>
| -
| null
|

|===


=== Return Type

<<V1GetClustersForPermissionsResponse>>


=== Content Type

* application/json

=== Responses

.HTTP Response Codes
[cols="2,3,1"]
|===
| Code | Message | Datatype


| 200
| A successful response.
|  <<V1GetClustersForPermissionsResponse>>


| 0
| An unexpected error response.
|  <<RuntimeError>>

|===

=== Samples









ifdef::internal-generation[]
=== Implementation



endif::internal-generation[]


[id="RoleServiceGetMyPermissions"]
== GetMyPermissions

`GET /v1/mypermissions`



=== Description







=== Parameters







=== Return Type

<<V1GetPermissionsResponse>>


=== Content Type

* application/json

=== Responses

.HTTP Response Codes
[cols="2,3,1"]
|===
| Code | Message | Datatype


| 200
| A successful response.
|  <<V1GetPermissionsResponse>>


| 0
| An unexpected error response.
|  <<RuntimeError>>

|===

=== Samples









ifdef::internal-generation[]
=== Implementation



endif::internal-generation[]


[id="RoleServiceGetNamespacesForClusterAndPermissions"]
== GetNamespacesForClusterAndPermissions

`GET /v1/sac/clusters/{clusterId}/namespaces`

GetNamespacesForClusterAndPermissions

=== Description

Returns the list of namespace ID and namespace name pairs that belong to the requested cluster and for which the user has at least read access granted for the list of requested permissions that have namespace scope or narrower (i.e. global and cluster permissions from the input are ignored).  If the input only contains permissions at global or cluster level, the output will be an empty list.  If no permission is given in input, all namespaces allowed by the requester scope for any permission with namespace scope or narrower will be part of the response.





=== Parameters

==== Path Parameters

[cols="2,3,1,1,1"]
|===
|Name| Description| Required| Default| Pattern

| clusterId
|
| X
| null
|

|===




==== Query Parameters

[cols="2,3,1,1,1"]
|===
|Name| Description| Required| Default| Pattern

| permissions
|  <<String>>
| -
| null
|

|===


=== Return Type

<<V1GetNamespacesForClusterAndPermissionsResponse>>


=== Content Type

* application/json

=== Responses

.HTTP Response Codes
[cols="2,3,1"]
|===
| Code | Message | Datatype


| 200
| A successful response.
|  <<V1GetNamespacesForClusterAndPermissionsResponse>>


| 0
| An unexpected error response.
|  <<RuntimeError>>

|===

=== Samples









ifdef::internal-generation[]
=== Implementation



endif::internal-generation[]


[id="RoleServiceGetPermissionSet"]
== GetPermissionSet

`GET /v1/permissionsets/{id}`



=== Description







=== Parameters

==== Path Parameters

[cols="2,3,1,1,1"]
|===
|Name| Description| Required| Default| Pattern

| id
|
| X
| null
|

|===






=== Return Type

<<StoragePermissionSet>>


=== Content Type

* application/json

=== Responses

.HTTP Response Codes
[cols="2,3,1"]
|===
| Code | Message | Datatype


| 200
| A successful response.
|  <<StoragePermissionSet>>


| 0
| An unexpected error response.
|  <<RuntimeError>>

|===

=== Samples









ifdef::internal-generation[]
=== Implementation



endif::internal-generation[]


[id="RoleServiceGetResources"]
== GetResources

`GET /v1/resources`



=== Description







=== Parameters







=== Return Type

<<V1GetResourcesResponse>>


=== Content Type

* application/json

=== Responses

.HTTP Response Codes
[cols="2,3,1"]
|===
| Code | Message | Datatype


| 200
| A successful response.
|  <<V1GetResourcesResponse>>


| 0
| An unexpected error response.
|  <<RuntimeError>>

|===

=== Samples









ifdef::internal-generation[]
=== Implementation



endif::internal-generation[]


[id="RoleServiceGetRole"]
== GetRole

`GET /v1/roles/{id}`



=== Description







=== Parameters

==== Path Parameters

[cols="2,3,1,1,1"]
|===
|Name| Description| Required| Default| Pattern

| id
|
| X
| null
|

|===






=== Return Type

<<StorageRole>>


=== Content Type

* application/json

=== Responses

.HTTP Response Codes
[cols="2,3,1"]
|===
| Code | Message | Datatype


| 200
| A successful response.
|  <<StorageRole>>


| 0
| An unexpected error response.
|  <<RuntimeError>>

|===

=== Samples









ifdef::internal-generation[]
=== Implementation



endif::internal-generation[]


[id="RoleServiceGetRoles"]
== GetRoles

`GET /v1/roles`



=== Description







=== Parameters







=== Return Type

<<V1GetRolesResponse>>


=== Content Type

* application/json

=== Responses

.HTTP Response Codes
[cols="2,3,1"]
|===
| Code | Message | Datatype


| 200
| A successful response.
|  <<V1GetRolesResponse>>


| 0
| An unexpected error response.
|  <<RuntimeError>>

|===

=== Samples









ifdef::internal-generation[]
=== Implementation



endif::internal-generation[]


[id="RoleServiceGetSimpleAccessScope"]
== GetSimpleAccessScope

`GET /v1/simpleaccessscopes/{id}`



=== Description







=== Parameters

==== Path Parameters

[cols="2,3,1,1,1"]
|===
|Name| Description| Required| Default| Pattern

| id
|
| X
| null
|

|===






=== Return Type

<<StorageSimpleAccessScope>>


=== Content Type

* application/json

=== Responses

.HTTP Response Codes
[cols="2,3,1"]
|===
| Code | Message | Datatype


| 200
| A successful response.
|  <<StorageSimpleAccessScope>>


| 0
| An unexpected error response.
|  <<RuntimeError>>

|===

=== Samples









ifdef::internal-generation[]
=== Implementation



endif::internal-generation[]


[id="RoleServiceListPermissionSets"]
== ListPermissionSets

`GET /v1/permissionsets`



=== Description







=== Parameters







=== Return Type

<<V1ListPermissionSetsResponse>>


=== Content Type

* application/json

=== Responses

.HTTP Response Codes
[cols="2,3,1"]
|===
| Code | Message | Datatype


| 200
| A successful response.
|  <<V1ListPermissionSetsResponse>>


| 0
| An unexpected error response.
|  <<RuntimeError>>

|===

=== Samples









ifdef::internal-generation[]
=== Implementation



endif::internal-generation[]


[id="RoleServiceListSimpleAccessScopes"]
== ListSimpleAccessScopes

`GET /v1/simpleaccessscopes`



=== Description







=== Parameters







=== Return Type

<<V1ListSimpleAccessScopesResponse>>


=== Content Type

* application/json

=== Responses

.HTTP Response Codes
[cols="2,3,1"]
|===
| Code | Message | Datatype


| 200
| A successful response.
|  <<V1ListSimpleAccessScopesResponse>>


| 0
| An unexpected error response.
|  <<RuntimeError>>

|===

=== Samples









ifdef::internal-generation[]
=== Implementation



endif::internal-generation[]


[id="RoleServicePostPermissionSet"]
== PostPermissionSet

`POST /v1/permissionsets`

PostPermissionSet

=== Description

PermissionSet.id is disallowed in request and set in response.





=== Parameters


==== Body Parameter

[cols="2,3,1,1,1"]
|===
|Name| Description| Required| Default| Pattern

| body
|  <<StoragePermissionSet>>
| X
|
|

|===





=== Return Type

<<StoragePermissionSet>>


=== Content Type

* application/json

=== Responses

.HTTP Response Codes
[cols="2,3,1"]
|===
| Code | Message | Datatype


| 200
| A successful response.
|  <<StoragePermissionSet>>


| 0
| An unexpected error response.
|  <<RuntimeError>>

|===

=== Samples









ifdef::internal-generation[]
=== Implementation



endif::internal-generation[]


[id="RoleServicePostSimpleAccessScope"]
== PostSimpleAccessScope

`POST /v1/simpleaccessscopes`

PostSimpleAccessScope

=== Description

SimpleAccessScope.id is disallowed in request and set in response.





=== Parameters


==== Body Parameter

[cols="2,3,1,1,1"]
|===
|Name| Description| Required| Default| Pattern

| body
|  <<StorageSimpleAccessScope>>
| X
|
|

|===





=== Return Type

<<StorageSimpleAccessScope>>


=== Content Type

* application/json

=== Responses

.HTTP Response Codes
[cols="2,3,1"]
|===
| Code | Message | Datatype


| 200
| A successful response.
|  <<StorageSimpleAccessScope>>


| 0
| An unexpected error response.
|  <<RuntimeError>>

|===

=== Samples









ifdef::internal-generation[]
=== Implementation



endif::internal-generation[]


[id="RoleServicePutPermissionSet"]
== PutPermissionSet

`PUT /v1/permissionsets/{id}`



=== Description







=== Parameters

==== Path Parameters

[cols="2,3,1,1,1"]
|===
|Name| Description| Required| Default| Pattern

| id
| id is generated and cannot be changed.
| X
| null
|

|===

==== Body Parameter

[cols="2,3,1,1,1"]
|===
|Name| Description| Required| Default| Pattern

| body
|  <<StoragePermissionSet>>
| X
|
|

|===





=== Return Type


<<Object>>


=== Content Type

* application/json

=== Responses

.HTTP Response Codes
[cols="2,3,1"]
|===
| Code | Message | Datatype


| 200
| A successful response.
|  <<Object>>


| 0
| An unexpected error response.
|  <<RuntimeError>>

|===

=== Samples









ifdef::internal-generation[]
=== Implementation



endif::internal-generation[]


[id="RoleServicePutSimpleAccessScope"]
== PutSimpleAccessScope

`PUT /v1/simpleaccessscopes/{id}`



=== Description







=== Parameters

==== Path Parameters

[cols="2,3,1,1,1"]
|===
|Name| Description| Required| Default| Pattern

| id
| &#x60;id&#x60; is generated and cannot be changed.
| X
| null
|

|===

==== Body Parameter

[cols="2,3,1,1,1"]
|===
|Name| Description| Required| Default| Pattern

| body
|  <<StorageSimpleAccessScope>>
| X
|
|

|===





=== Return Type


<<Object>>


=== Content Type

* application/json

=== Responses

.HTTP Response Codes
[cols="2,3,1"]
|===
| Code | Message | Datatype


| 200
| A successful response.
|  <<Object>>


| 0
| An unexpected error response.
|  <<RuntimeError>>

|===

=== Samples









ifdef::internal-generation[]
=== Implementation



endif::internal-generation[]


[id="RoleServiceUpdateRole"]
== UpdateRole

`PUT /v1/roles/{name}`



=== Description







=== Parameters

==== Path Parameters

[cols="2,3,1,1,1"]
|===
|Name| Description| Required| Default| Pattern

| name
| &#x60;name&#x60; and &#x60;description&#x60; are provided by the user and can be changed.
| X
| null
|

|===

==== Body Parameter

[cols="2,3,1,1,1"]
|===
|Name| Description| Required| Default| Pattern

| body
|  <<StorageRole>>
| X
|
|

|===





=== Return Type


<<Object>>


=== Content Type

* application/json

=== Responses

.HTTP Response Codes
[cols="2,3,1"]
|===
| Code | Message | Datatype


| 200
| A successful response.
|  <<Object>>


| 0
| An unexpected error response.
|  <<RuntimeError>>

|===

=== Samples









ifdef::internal-generation[]
=== Implementation



endif::internal-generation[]


[id="common-object-reference"]
== Common object reference



[#ComputeEffectiveAccessScopeRequestPayload]
=== _ComputeEffectiveAccessScopeRequestPayload_ 




[.fields-ComputeEffectiveAccessScopeRequestPayload]
[cols="2,1,1,2,4,1"]
|===
| Field Name| Required| Nullable | Type| Description | Format

| simpleRules
| 
| 
| <<SimpleAccessScopeRules>>    
| 
|     

|===



[#ProtobufAny]
=== _ProtobufAny_ 

`Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }
    // or ...
    if (any.isSameTypeAs(Foo.getDefaultInstance())) {
      foo = any.unpack(Foo.getDefaultInstance());
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".

==== JSON representation
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    }


[.fields-ProtobufAny]
[cols="2,1,1,2,4,1"]
|===
| Field Name| Required| Nullable | Type| Description | Format

| typeUrl
| 
| 
|   String  
| A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
|     

| value
| 
| 
|   byte[]  
| Must be a valid serialized protocol buffer of the above specified type.
| byte    

|===



[#RuntimeError]
=== _RuntimeError_ 




[.fields-RuntimeError]
[cols="2,1,1,2,4,1"]
|===
| Field Name| Required| Nullable | Type| Description | Format

| error
| 
| 
|   String  
| 
|     

| code
| 
| 
|   Integer  
| 
| int32    

| message
| 
| 
|   String  
| 
|     

| details
| 
| 
|   List   of <<ProtobufAny>>
| 
|     

|===



[#SimpleAccessScopeRules]
=== _SimpleAccessScopeRules_ 

Each element of any repeated field is an individual rule. Rules are
joined by logical OR: if there exists a rule allowing resource `x`,
`x` is in the access scope.


[.fields-SimpleAccessScopeRules]
[cols="2,1,1,2,4,1"]
|===
| Field Name| Required| Nullable | Type| Description | Format

| includedClusters
| 
| 
|   List   of <<string>>
| 
|     

| includedNamespaces
| 
| 
|   List   of <<SimpleAccessScopeRulesNamespace>>
| 
|     

| clusterLabelSelectors
| 
| 
|   List   of <<StorageSetBasedLabelSelector>>
| 
|     

| namespaceLabelSelectors
| 
| 
|   List   of <<StorageSetBasedLabelSelector>>
| 
|     

|===



[#SimpleAccessScopeRulesNamespace]
=== _SimpleAccessScopeRulesNamespace_ 




[.fields-SimpleAccessScopeRulesNamespace]
[cols="2,1,1,2,4,1"]
|===
| Field Name| Required| Nullable | Type| Description | Format

| clusterName
| 
| 
|   String  
| Both fields must be set.
|     

| namespaceName
| 
| 
|   String  
| 
|     

|===



[#StorageAccess]
=== _StorageAccess_ 






[.fields-StorageAccess]
[cols="1"]
|===
| Enum Values

| NO_ACCESS
| READ_ACCESS
| READ_WRITE_ACCESS

|===


[#StorageEffectiveAccessScope]
=== _StorageEffectiveAccessScope_ 

EffectiveAccessScope describes which clusters and namespaces are "in scope"
given current state. Basically, if AccessScope is applied to the currently
known clusters and namespaces, the result is EffectiveAccessScope.

EffectiveAccessScope represents a tree with nodes marked as included and
excluded. If a node is included, all its child nodes are included.


[.fields-StorageEffectiveAccessScope]
[cols="2,1,1,2,4,1"]
|===
| Field Name| Required| Nullable | Type| Description | Format

| clusters
| 
| 
|   List   of <<StorageEffectiveAccessScopeCluster>>
| 
|     

|===



[#StorageEffectiveAccessScopeCluster]
=== _StorageEffectiveAccessScopeCluster_ 




[.fields-StorageEffectiveAccessScopeCluster]
[cols="2,1,1,2,4,1"]
|===
| Field Name| Required| Nullable | Type| Description | Format

| id
| 
| 
|   String  
| 
|     

| name
| 
| 
|   String  
| 
|     

| state
| 
| 
|  <<StorageEffectiveAccessScopeState>>  
| 
|    UNKNOWN, INCLUDED, EXCLUDED, PARTIAL,  

| labels
| 
| 
|   Map   of <<string>>
| 
|     

| namespaces
| 
| 
|   List   of <<StorageEffectiveAccessScopeNamespace>>
| 
|     

|===



[#StorageEffectiveAccessScopeNamespace]
=== _StorageEffectiveAccessScopeNamespace_ 




[.fields-StorageEffectiveAccessScopeNamespace]
[cols="2,1,1,2,4,1"]
|===
| Field Name| Required| Nullable | Type| Description | Format

| id
| 
| 
|   String  
| 
|     

| name
| 
| 
|   String  
| 
|     

| state
| 
| 
|  <<StorageEffectiveAccessScopeState>>  
| 
|    UNKNOWN, INCLUDED, EXCLUDED, PARTIAL,  

| labels
| 
| 
|   Map   of <<string>>
| 
|     

|===



[#StorageEffectiveAccessScopeState]
=== _StorageEffectiveAccessScopeState_ 






[.fields-StorageEffectiveAccessScopeState]
[cols="1"]
|===
| Enum Values

| UNKNOWN
| INCLUDED
| EXCLUDED
| PARTIAL

|===


[#StoragePermissionSet]
=== _StoragePermissionSet_ 

This encodes a set of permissions for StackRox resources.


[.fields-StoragePermissionSet]
[cols="2,1,1,2,4,1"]
|===
| Field Name| Required| Nullable | Type| Description | Format

| id
| 
| 
|   String  
| id is generated and cannot be changed.
|     

| name
| 
| 
|   String  
| `name` and `description` are provided by the user and can be changed.
|     

| description
| 
| 
|   String  
| 
|     

| resourceToAccess
| 
| 
|   Map   of <<StorageAccess>>
| 
|     

| traits
| 
| 
| <<StorageTraits>>    
| 
|     

|===



[#StorageRole]
=== _StorageRole_ 

A role specifies which actions are allowed for which subset of cluster
objects. Permissions be can either specified directly via setting
resource_to_access together with global_access or by referencing a
permission set by its id in permission_set_name.


[.fields-StorageRole]
[cols="2,1,1,2,4,1"]
|===
| Field Name| Required| Nullable | Type| Description | Format

| name
| 
| 
|   String  
| `name` and `description` are provided by the user and can be changed.
|     

| description
| 
| 
|   String  
| 
|     

| permissionSetId
| 
| 
|   String  
| The associated PermissionSet and AccessScope for this Role.
|     

| accessScopeId
| 
| 
|   String  
| 
|     

| globalAccess
| 
| 
|  <<StorageAccess>>  
| 
|    NO_ACCESS, READ_ACCESS, READ_WRITE_ACCESS,  

| resourceToAccess
| 
| 
|   Map   of <<StorageAccess>>
| Deprecated 2021-04-20 in favor of `permission_set_id`.
|     

| traits
| 
| 
| <<StorageTraits>>    
| 
|     

|===



[#StorageSetBasedLabelSelector]
=== _StorageSetBasedLabelSelector_ 

SetBasedLabelSelector only allows set-based label requirements.

Next available tag: 3


[.fields-StorageSetBasedLabelSelector]
[cols="2,1,1,2,4,1"]
|===
| Field Name| Required| Nullable | Type| Description | Format

| requirements
| 
| 
|   List   of <<StorageSetBasedLabelSelectorRequirement>>
| 
|     

|===



[#StorageSetBasedLabelSelectorOperator]
=== _StorageSetBasedLabelSelectorOperator_ 






[.fields-StorageSetBasedLabelSelectorOperator]
[cols="1"]
|===
| Enum Values

| UNKNOWN
| IN
| NOT_IN
| EXISTS
| NOT_EXISTS

|===


[#StorageSetBasedLabelSelectorRequirement]
=== _StorageSetBasedLabelSelectorRequirement_ Next available tag: 4




[.fields-StorageSetBasedLabelSelectorRequirement]
[cols="2,1,1,2,4,1"]
|===
| Field Name| Required| Nullable | Type| Description | Format

| key
| 
| 
|   String  
| 
|     

| op
| 
| 
|  <<StorageSetBasedLabelSelectorOperator>>  
| 
|    UNKNOWN, IN, NOT_IN, EXISTS, NOT_EXISTS,  

| values
| 
| 
|   List   of <<string>>
| 
|     

|===



[#StorageSimpleAccessScope]
=== _StorageSimpleAccessScope_ 

Simple access scope is a (simple) selection criteria for scoped resources.
It does *not* allow multi-component AND-rules nor set operations on names.


[.fields-StorageSimpleAccessScope]
[cols="2,1,1,2,4,1"]
|===
| Field Name| Required| Nullable | Type| Description | Format

| id
| 
| 
|   String  
| `id` is generated and cannot be changed.
|     

| name
| 
| 
|   String  
| `name` and `description` are provided by the user and can be changed.
|     

| description
| 
| 
|   String  
| 
|     

| rules
| 
| 
| <<SimpleAccessScopeRules>>    
| 
|     

| traits
| 
| 
| <<StorageTraits>>    
| 
|     

|===



[#StorageTraits]
=== _StorageTraits_ 




[.fields-StorageTraits]
[cols="2,1,1,2,4,1"]
|===
| Field Name| Required| Nullable | Type| Description | Format

| mutabilityMode
| 
| 
|  <<TraitsMutabilityMode>>  
| 
|    ALLOW_MUTATE, ALLOW_MUTATE_FORCED,  

| visibility
| 
| 
|  <<TraitsVisibility>>  
| 
|    VISIBLE, HIDDEN,  

| origin
| 
| 
|  <<TraitsOrigin>>  
| 
|    IMPERATIVE, DEFAULT, DECLARATIVE, DECLARATIVE_ORPHANED,  

|===



[#TraitsMutabilityMode]
=== _TraitsMutabilityMode_ 

EXPERIMENTAL.
NOTE: Please refer from using MutabilityMode for the time being. It will be replaced in the future (ROX-14276).
MutabilityMode specifies whether and how an object can be modified. Default
is ALLOW_MUTATE and means there are no modification restrictions; this is equivalent
to the absence of MutabilityMode specification. ALLOW_MUTATE_FORCED forbids all
modifying operations except object removal with force bit on.

Be careful when changing the state of this field. For example, modifying an
object from ALLOW_MUTATE to ALLOW_MUTATE_FORCED is allowed but will prohibit any further
changes to it, including modifying it back to ALLOW_MUTATE.




[.fields-TraitsMutabilityMode]
[cols="1"]
|===
| Enum Values

| ALLOW_MUTATE
| ALLOW_MUTATE_FORCED

|===


[#TraitsOrigin]
=== _TraitsOrigin_ 

Origin specifies the origin of an object.
Objects can have four different origins:
- IMPERATIVE: the object was created via the API. This is assumed by default.
- DEFAULT: the object is a default object, such as default roles, access scopes etc.
- DECLARATIVE: the object is created via declarative configuration.
- DECLARATIVE_ORPHANED: the object is created via declarative configuration and then unsuccessfully deleted(for example, because it is referenced by another object)
Based on the origin, different rules apply to the objects.
Objects with the DECLARATIVE origin are not allowed to be modified via API, only via declarative configuration.
Additionally, they may not reference objects with the IMPERATIVE origin.
Objects with the DEFAULT origin are not allowed to be modified via either API or declarative configuration.
They may be referenced by all other objects.
Objects with the IMPERATIVE origin are allowed to be modified via API, not via declarative configuration.
They may reference all other objects.
Objects with the DECLARATIVE_ORPHANED origin are not allowed to be modified via either API or declarative configuration.
DECLARATIVE_ORPHANED resource can become DECLARATIVE again if it is redefined in declarative configuration.
Objects with this origin will be cleaned up from the system immediately after they are not referenced by other resources anymore.
They may be referenced by all other objects.




[.fields-TraitsOrigin]
[cols="1"]
|===
| Enum Values

| IMPERATIVE
| DEFAULT
| DECLARATIVE
| DECLARATIVE_ORPHANED

|===


[#TraitsVisibility]
=== _TraitsVisibility_ 

EXPERIMENTAL.
visibility allows to specify whether the object should be visible for certain APIs.




[.fields-TraitsVisibility]
[cols="1"]
|===
| Enum Values

| VISIBLE
| HIDDEN

|===


[#V1GetClustersForPermissionsResponse]
=== _V1GetClustersForPermissionsResponse_ 




[.fields-V1GetClustersForPermissionsResponse]
[cols="2,1,1,2,4,1"]
|===
| Field Name| Required| Nullable | Type| Description | Format

| clusters
| 
| 
|   List   of <<V1ScopeObject>>
| 
|     

|===



[#V1GetNamespacesForClusterAndPermissionsResponse]
=== _V1GetNamespacesForClusterAndPermissionsResponse_ 




[.fields-V1GetNamespacesForClusterAndPermissionsResponse]
[cols="2,1,1,2,4,1"]
|===
| Field Name| Required| Nullable | Type| Description | Format

| namespaces
| 
| 
|   List   of <<V1ScopeObject>>
| 
|     

|===



[#V1GetPermissionsResponse]
=== _V1GetPermissionsResponse_ 

GetPermissionsResponse is wire-compatible with the old format of the Role
message and represents a collection of aggregated permissions.


[.fields-V1GetPermissionsResponse]
[cols="2,1,1,2,4,1"]
|===
| Field Name| Required| Nullable | Type| Description | Format

| resourceToAccess
| 
| 
|   Map   of <<StorageAccess>>
| 
|     

|===



[#V1GetResourcesResponse]
=== _V1GetResourcesResponse_ 




[.fields-V1GetResourcesResponse]
[cols="2,1,1,2,4,1"]
|===
| Field Name| Required| Nullable | Type| Description | Format

| resources
| 
| 
|   List   of <<string>>
| 
|     

|===



[#V1GetRolesResponse]
=== _V1GetRolesResponse_ 




[.fields-V1GetRolesResponse]
[cols="2,1,1,2,4,1"]
|===
| Field Name| Required| Nullable | Type| Description | Format

| roles
| 
| 
|   List   of <<StorageRole>>
| 
|     

|===



[#V1ListPermissionSetsResponse]
=== _V1ListPermissionSetsResponse_ 




[.fields-V1ListPermissionSetsResponse]
[cols="2,1,1,2,4,1"]
|===
| Field Name| Required| Nullable | Type| Description | Format

| permissionSets
| 
| 
|   List   of <<StoragePermissionSet>>
| 
|     

|===



[#V1ListSimpleAccessScopesResponse]
=== _V1ListSimpleAccessScopesResponse_ 




[.fields-V1ListSimpleAccessScopesResponse]
[cols="2,1,1,2,4,1"]
|===
| Field Name| Required| Nullable | Type| Description | Format

| accessScopes
| 
| 
|   List   of <<StorageSimpleAccessScope>>
| 
|     

|===



[#V1ScopeObject]
=== _V1ScopeObject_ 

ScopeObject represents an ID, name pair, which can apply to any
entity that takes part in an access scope (so far Cluster and Namespace).


[.fields-V1ScopeObject]
[cols="2,1,1,2,4,1"]
|===
| Field Name| Required| Nullable | Type| Description | Format

| id
| 
| 
|   String  
| 
|     

| name
| 
| 
|   String  
| 
|     

|===



