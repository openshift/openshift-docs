// Module included in the following assemblies:
//
// * n/a

[id='architecture-component-builds']
= Image Builds
include::modules/common-attributes.adoc[]
toc::[]

A _build_ is the process of transforming input parameters into a resulting
object. Most often, the process is used to transform input parameters or source
code into a runnable image. A
xref:../../dev_guide/builds/index.adoc#defining-a-buildconfig[`BuildConfig`]
object is the definition of the entire build process.

{product-title} leverages Kubernetes by creating Docker-formatted containers from build
images and pushing them to a
xref:../../architecture/infrastructure_components/image_registry.adoc#integrated-openshift-registry[container image registry].

Build objects share common characteristics: inputs for a build, the need to
complete a build process, logging the build process, publishing resources from
successful builds, and publishing the final status of the build. Builds take
advantage of resource restrictions, specifying limitations on resources such as
CPU usage, memory usage, and build or pod execution time.

ifdef::openshift-origin,openshift-enterprise,openshift-dedicated[]
The {product-title} build system provides extensible support for _build
strategies_ that are based on selectable types specified in the build API. There
are three primary build strategies available:

- xref:docker-build[Docker build]
- xref:source-build[Source-to-Image (S2I) build]
- xref:custom-build[Custom build]

By default, Docker builds and S2I builds are supported.

endif::[]
The resulting object of a build depends on the builder used to create it. For
Docker and S2I builds, the resulting objects are runnable images. For Custom
builds, the resulting objects are whatever the builder image author has
specified.

Additionally, the
xref:pipeline-build[Pipeline build]
strategy can be used to implement sophisticated workflows:

- continuous integration
- continuous deployment

For a list of build commands, see the
xref:../../dev_guide/builds/index.adoc#dev-guide-how-builds-work[Developer's Guide].

For more information on how {product-title} leverages Docker for builds, see the
link:https://github.com/openshift/origin/blob/master/docs/builds.md#how-it-works[upstream
documentation].

ifdef::openshift-origin,openshift-enterprise,openshift-dedicated[]
[[docker-build]]
=== Docker Build

The Docker build strategy invokes the https://docs.docker.com/engine/reference/commandline/build/[docker build] command, and it therefore expects a repository with a *_Dockerfile_* and all required
artifacts in it to produce a runnable image.
endif::[]

[[source-build]]
=== Source-to-Image (S2I) Build

xref:../../creating_images/s2i.adoc#creating-images-s2i[Source-to-Image (S2I)] is a tool for
building reproducible, Docker-formatted container images. It produces ready-to-run images by
injecting application source into a container image and assembling a new image. The new image incorporates the base image (the builder) and built source
and is ready to use with the `docker run` command. S2I supports incremental
builds, which re-use previously downloaded dependencies, previously built
artifacts, etc.

The advantages of S2I include the following:

[horizontal]
Image flexibility:: S2I scripts can be written to inject application code into
almost any existing Docker-formatted container image, taking advantage of the existing ecosystem.
Note that, currently, S2I relies on `tar` to inject application
source, so the image needs to be able to process tarred content.

Speed:: With S2I, the assemble process can perform a large number of complex
operations without creating a new layer at each step, resulting in a fast
process. In addition, S2I scripts can be written to re-use artifacts stored in a
previous version of the application image, rather than having to download or
build them each time the build is run.

Patchability:: S2I allows you to rebuild the application consistently if an
underlying image needs a patch due to a security issue.

Operational efficiency:: By restricting build operations instead of allowing
arbitrary actions, as a *_Dockerfile_* would allow, the PaaS operator can avoid
accidental or intentional abuses of the build system.

Operational security:: Building an arbitrary *_Dockerfile_* exposes the host
system to root privilege escalation. This can be exploited by a malicious user
because the entire Docker build process is run as a user with Docker privileges.
S2I restricts the operations performed as a root user and can run the scripts
as a non-root user.

User efficiency:: S2I prevents developers from performing arbitrary `yum
install` type operations, which could slow down development iteration, during
their application build.

Ecosystem:: S2I encourages a shared ecosystem of images where you can leverage
best practices for your applications.

Reproducibility:: Produced images can include all inputs including specific versions
of build tools and dependencies. This ensures that the image can be reproduced
precisely.

ifdef::openshift-origin,openshift-enterprise,openshift-dedicated[]
[[custom-build]]
=== Custom Build

The Custom build strategy allows developers to define a specific builder image
responsible for the entire build process. Using your own builder image allows
you to customize your build process.

A xref:../../creating_images/custom.adoc#creating-images-custom[Custom builder image] is a plain Docker-formatted container image embedded with build process logic, for example for building RPMs or base images.
endif::[]

[[pipeline-build]]
=== Pipeline Build

The Pipeline build strategy allows developers to define a _Jenkins pipeline_
for execution by the Jenkins pipeline plugin.
The build can be started, monitored, and managed by
{product-title} in the same way as any other build type.

Pipeline workflows are defined in a Jenkinsfile,
either embedded directly in the build configuration,
or supplied in a Git repository and referenced by the build configuration.

For more information about Jenkins Pipelines, see the
link:https://jenkins.io/doc/pipeline/[Jenkins documentation].