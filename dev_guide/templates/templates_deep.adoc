[[dev-guide-templates-designing]]
= Template Deep Dive
{product-author}
{product-version}
:data-uri:
:icons:
:experimental:
:toc: macro
:toc-title:
:prewrap!:

toc::[]
{nbsp} +

This topic is an in-depth review of the contents of a template, using a sample application. This topic describe a template as a set of layers of resources with the following structure (from bottom up):

* *{product-title} Images*: Base images we will be using for our containers.
* *Builds*: Generates an image from source code (application source or Dockerfile source).
* *Images*: Images produced by the builds.
* *Deployments*: What images will be deployed and how.
* *Abstractions*: Additional resources needed for our application, like networking, storage, security, and so forth.

To see how all the layers appear in a template, 
See xref:../../dev_guide/templates/template_examples.adoc#dev-guide-templates-example-edited[Edited rails-postgresql-example template].

[[dev-guide-templates-designing-images]]
=== {product-title} Image Layer
This first layer defines all the *base* images used for the containers. These images typically will not be part of the template, but they need to be identified. These can be S2I images or plain Docker images. 

ImageStream::
An xref:../../architecture/core_concepts/builds_and_image_streams.adoc#image-streams[image stream] presents a single virtual view of related images and can contain images from:

* the {product-title} integrated registry;
* other image streams;
* Docker image repositories from external registries.

{product-title} stores complete metadata about each image (such as commands, entry points, environment variables, and so forth). Images in {product-title} are immutable.

Image Stream Image::
An xref:../../architecture/core_concepts/builds_and_image_streams.adoc#image-stream-image[image stream image] is used to reference or retrieve an image for a given image stream and image name. It uses the following convention for its name: 

----
<image stream name>@<image-id>
----

Image Stream Tag::
An xref:../../architecture/core_concepts/builds_and_image_streams.adoc#image-stream-tag[image stream tag] is a named pointer to an image in an image stream, and is used to reference or retrieve an image for that image stream and tag. It uses the following convention for its name: 

----
<image stream name>:<tag>
----

The sample application uses two base images:

* The frontend component of the application uses a S2I-enabled JBoss EAP image with the specific tag, 6.4, of this image. As this image will be used for building purposes, the specific usage will be defined in the Build layer.
* The backend component of the application uses a MongoDB database with the latest available image. As this image is a ready-to-use image, the specific usage of this image will be defined in the deployment layer.

[NOTE]
====
Both of these base images are default in {product-title} and are installed in the *openshift* project.
====

[[dev-guide-templates-designing-builds]]
=== Builds Layer
This layer contains the xref:../../dev_guide/builds.adoc#defining-a-buildconfig[build configuration], which defines all the builds required for an application. A build is the process of transforming input parameters into a resulting object. Most often, the process is used to transform source code into a runnable image.

A *BuildConfig* object has the following key parts:

* A source description (*Where is your source code?*).
* A strategy for building (*How to build your image?*). Can be the following:
** Source-To-Image (S2I): Transform your application into a runnable docker image, using an S2I image for building and running your application.
** Docker: Your Dockerfile is built into an image. This image contains both, the runtime and the application already built.
** Custom: You provide the building method in a Docker image.
* An output description (*Where to place the built image*?).
* A list of triggers (*When and Why will the source be built?*).

The sample application builds the frontend component, and layers an application on top of an EAP runtime.

[source,json]
----
{
   "kind": "BuildConfig",
   "apiVersion": "v1",
   "metadata": {
      "name": "mlbparks",             # <1>
      "labels": {
         "application": "mlbparks"    # <2>
      }
   },
   "spec": {
      "source": {                     # <3>
         "type": "Git",               # <4>
         "git": {
            "uri": "https://github.com/jorgemoralespou/openshift3mlbparks.git",  # <5> +++CHANGE THIS++++
            "ref": "master"           # <6>
         },
         "contextDir":""              # <7> 
      },
      "strategy": {                   # <8>
         "type": "Source",            # <9>
         "sourceStrategy": {
            "from": {                 # <10>
               "kind": "ImageStreamTag",
               "namespace": "openshift",
               "name": "jboss-eap6-openshift:6.4"
            }
         }
      },
      "output": {                     # <11>
         "to": {
            "kind": "ImageStreamTag",
            "name": "mlbparks:latest"
         }
      },
      "triggers": [
         {
            "type": "GitHub",         # <12>
            "generic": {
               "secret": "secret"
            }
         },
         {
            "type": "Generic",        # <13>
            "github": {
               "secret": "secret"
            }
         },
         {
            "type": "ImageChange",    # <14>
            "imageChange": {}
         }
      ]
   }
}
----
<1> The name that identifies this build configuration.
<2> The labels that will be set for this build configuration.
<3> This stanza defines the source for the build.
<4> The source as located in a Git repository.
<5> The URI of the source repository.
<6> The repository tag/branch. This value is optional and defaults to `master` if not provided.
<7> The subdirectory from the repository. This value is optional and defaults to the root directory of the repository.
<8> This stanza defines which build strategy to use. 
<9> The build strategy, here `Source` indicates Source-To-Image).
<10> The image stream tag to indicate which builder image to use.
<11> This stanza defines where to place the generated image if the build succeeds. It is placing it in the current project. 
<12> This stanza defines that a change generated by a GitHub webhook trigger (if the source code is changed) will trigger a build.
<13> This stanza defines that a change generated via a Generic webhook trigger will trigger a build.
<14> This stanza defines that an image change will trigger a build. This will trigger a build if the builder image changes or is updated.

For more information see xref:../../architecture/core_concepts/builds_and_image_streams.adoc#builds[Builds and Image Streams].

[[dev-guide-templates-designing-layers]]
=== Image Layer

This layer contains an xref:../../architecture/core_concepts/builds_and_image_streams.adoc#image-streams[image stream], which defines all the images produced by the builds.

The sample application produces an image defined in a new image stream.

[source,json]
----
{
   "kind": "ImageStream",
   "apiVersion": "v1",
   "metadata": {
      "name": "mlbparks",            # <1>
      "labels": {
         "application": "mlbparks"   # <2>
      }
   },
   "spec": {                         # <3>
      "dockerImageRepository": "",   # <4>
      "tags": [                      # <5>
         {
            "name": "latest" 
         }
      ]
   }
}
----
<1> The name of the image stream. This image stream will be created in the current project.
<2> A label to describe the resource relative to the application we are creating.
<3> This stanza defines image stream specifications.
<4> The Docker repository backing this image stream.
<5> The list of available tags or image stream locators for this image stream.

As a result of the build process, for every build {product-title} creates a new version of the image, that will always be tagged as `latest` (as seen in the xref:dev-guide-templates-designing-layer[build configuration `output` stanza).

[[dev-guide-templates-designing-layer]]
=== Deployment Layer
This layer contains the xref:../../architecture/core_concepts/deployments.adoc#deployments-and-deployment-configurations[*deployment configuration*], which defines the core of the application that will be deployed and running on {product-title}.

A deployment configuration consists of the following key parts:

* A replication controller template which describes the application to be deployed.
* The default replica count for the deployment. The repliac count is how many instances will be deployed and running.
* A deployment strategy to execute the deployment.
* A set of triggers that cause deployments to be created automatically.

In the sample application, there are two deployment configurations: one for the frontend component (JavaEE application) and one for the backend component (MongoDB).

The deployment configuration for the frontend component defines that:

* there will be a pod with a single container, using the previously built *mlbparks* image;
* there will be initially one replica;
* there will be a new deployment every time there is a new image built or there is a change in the configuration;
* the redeployment strategy will be `Recreate`, which discards all running pods and create new pods. 

[source,json]
----
{
   "kind": "DeploymentConfig",
   "apiVersion": "v1",
   "metadata": {
      "name": "mlbparks",                  <1>
      "labels": {                          <2>
         "deploymentConfig": "mlbparks",   
         "application": "mlbparks"
      }
   },
   "spec": {                               <3>
      "replicas": 1,                       <4>
      "selector": {
         "deploymentConfig": "mlbparks"    <5>
      },
      "strategy": {
         "type": "Recreate"                <6>
      },
      "template": {                        <7>
         "metadata": {
            "labels": {                    <8>
               "deploymentConfig": "mlbparks",
               "application": "mlbparks"
            },
            "name": "mlbparks"             <9>
         },
         "spec": {                         <10>
            "containers": [
               {
                  "name": "mlbparks",           <11>
                  "image": "mlbparks",          <12>
                  "imagePullPolicy": "Always",  <13>
                  "env": [                      <14>
                     {
                        "name": "OPENSHIFT_DNS_PING_SERVICE_NAME",
                        "value": "mlbparks-ping"
                     },
                     {
                        "name": "OPENSHIFT_DNS_PING_SERVICE_PORT",
                        "value": "8888"
                     },
                     {
                        "name": "MONGODB_USER",
                        "value": "user"
                     },
                     {
                        "name": "MONGODB_PASSWORD",
                        "value": "password"
                     },
                     {
                        "name": "MONGODB_DATABASE",
                        "value": "database"
                     }
                  ],
                  "ports": [                    <15>
                     {
                        "name": "mlbparks-http",
                        "containerPort": 8080,
                        "protocol": "TCP"
                     },
                     {
                        "name": "mlbparks-ping",
                        "containerPort": 8888,
                        "protocol": "TCP"
                     }
                  ],
                  "readinessProbe": {          <16>
                     "exec": {
                        "command": [
                           "/bin/bash",
                           "-c",
                           "/opt/eap/bin/readinessProbe.sh"
                        ]
                     }
                  },
                  "resources": {},
                  "terminationMessagePath": "/dev/termination-log",
                  "securityContext": {         <17>
                     "capabilities": {},
                     "privileged": false
                  }
               }
            ],
            "restartPolicy": "Always",
            "dnsPolicy": "ClusterFirst"
         }
      },
      "triggers": [                            <18>
         {                                   
            "type": "ImageChange",             <19>
            "imageChangeParams": {
               "automatic": true,
               "containerNames": [
                  "mlbparks"
               ],
               "from": {
                  "kind": "ImageStreamTag",
                  "name": "mlbparks:latest"
               }
            }
         },
         {                                     <20>
            "type": "ConfigChange"
         }
      ]
   }
}
----
<1> The name for this deployment configuration.
<2> The labels that describe this deployment configuration. <<note2>>.
<3> This stanza describes the deployment configuration.
<4> The number of instances that should be created for this deployment.
<5> This should be the same as *name* (1).
<6> The xref:../../dev_guide/deployments/deployment_strategies.adoc#recreate-strategy[strategy] to use when deploying a new version of the application in case it is triggered. 
<7> This stanza defines what will be deployed as part of this deployment (the pod).
<8> The labels to apply for the resources contained in the template (pod).
<9> The name to assign to the pod. Every pod instance created will have this name as prefix.
<10> This stanza defines the configuration (contents) of the pod.
<11> The name to assign to the container.
<12> The name of the image to use. <<note12>>.
<13> Defines whether the xref:../../dev_guide/managing_images.adoc#image-pull-policy[image should be pulled] prior to starting the container. If the image tag is *latest*, it will always pull the image by default, otherwise it will default to “IfNotPresent”.
<14> This stanza defines a set of environment variables to pass to this container.
<15> This stanza defines the ports that the container exposes.
<16> This stanza defines a xref:../../dev_guide/application_health.adoc#container-health-checks-using-probes[readiness probe] that determines if the runtime in the container has started successfully and traffic can be routed to it.
<17> This stanza defines the xref:../../architecture/additional_concepts/authorization.adoc#security-context-constraints[security context constraint] to use for the container.
<18> This stanza defines the xref:../../dev_guide/builds/triggering_builds.adoc#build-triggers[triggers] that will dictate on what conditions to deploy a new version of the pod.
<19> An xref:../../dev_guide/builds/triggering_builds.adoc#image-change-triggers[image change trigger] to create a new deployment when the latest image tag is updated.
<20> A xref:../../dev_guide/builds/triggering_builds.adoc#config-change-triggers[configuration change trigger] to create a new deployment when there is a configuration change for this resource.

[[note2, See note]]
[NOTE]
====
Red Hat recommends adding an `"application": "<application-name>"` label to resource defined by a template. You can use the label to link resources created as part of the processing of the template. You can add the label manually to each resource, as described here, or at once, as described in xref:labels[Labels].
====

[[note12, See note]]
[NOTE]
====
If there is an image change trigger defined in a deployment configuration, the image specification value gets substituted with the appropriate value for the image triggering the change. If you do not have an image change trigger, this value should be a valid Docker pull specification (such as `openshift/mongodb-24-centos7`).
====

The deployment configuration for the backend component defines that:

* there will be a pod with a single container using the MongoDB openshift base image;
* there will be initially one replica;
* there will be a new deployment every time there is a new image built or there is a change in the configuration;
* the redeployment strategy will be `Recreate`, which discards all running pods and create new ones;
* there will be a persistent volume on the host's filesystem (not valid for HA or host failover).

[source,json]
----
{
   "kind": "DeploymentConfig",
   "apiVersion": "v1",
   "metadata": {
      "name": "mlbparks-MongoDB",                 <1>
      "labels": {                                 <2>
         "application": "mlbparks"
      }
   },
   "spec": {                                      <3>
      "replicas": 1,                              <4>
      "selector": {                               
         "deploymentConfig": "mlbparks-MongoDB"   <5>
      },
      "strategy": {
         "type": "Recreate"                       <6>
      },
      "template": {                               <7>
         "metadata": {
            "labels": {                           <8>
               "deploymentConfig": "mlbparks-MongoDB",
               "application": "mlbparks"
            },
            "name": "mlbparks-MongoDB"            <9>
         },
         "spec": {                                <10>
            "containers": [
               {
                  "name": "mlbparks-MongoDB",     <11>
                  "image": "MongoDB",                 <12>
                  "imagePullPolicy": "IfNotPresent",  <13>
                  "env": [                            <14>
                     {
                        "name": "MONGODB_USER",
                        "value": "user"
                     },
                     {
                        "name": "MONGODB_PASSWORD",
                        "value": "password"
                     },
                     {
                        "name": "MONGODB_DATABASE",
                        "value": "database"
                     }
                  ],
                  "ports": [                          <15> 
                     {
                        "containerPort": 27017,
                        "protocol": "TCP"
                     }
                  ],
                  "resources": {},
                  "volumeMounts": [                   <16> 
                     {
                        "name": "mlbparks-MongoDB-data",
                        "mountPath": "/var/lib/MongoDB/data"
                     }
                  ],
                  "terminationMessagePath": "/dev/termination-log",
                  "securityContext": {                <17>
                     "capabilities": {},
                     "privileged": false
                  }
               }
            ],
            "volumes": [                              <18>
               {
                  "name": "mlbparks-MongoDB-data",
                  "emptyDir": {}
               }
            ],
            "restartPolicy": "Always",
            "dnsPolicy": "ClusterFirst"
         }
      },
      "triggers": [                                   <19>
         {
            "type": "ImageChange",                    <20>
            "imageChangeParams": {  
               "automatic": true,
               "containerNames": [
                  "mlbparks-MongoDB"
               ],
               "from": {
                  "kind": "ImageStreamTag",
                  "namespace": "openshift",
                  "name": "MongoDB:latest"
               }
            }
         },
         {                                             
            "type": "ConfigChange"                    <21>
         }
      ]
   }
}
----
<1> This is the name that will identify this deployment configuration.
<2> These are the labels that will describe this deployment configuration.
<3> Specification for the deployment configuration. Everything inside this section describes the deployment configuration.
<4> Number of instances that should be created for this deployment.
<5> This should be the same as *name* (1).
<6> Strategy to use when deploying a new version of the application in case it is triggered. Here, all existing Pods are killed before new ones are created.
<7> The template defines what will be deployed as part of this deployment (the pod).
<8> The labels to apply for the resources contained in the template (pod).
<9> Name of the pod. Every pod instance created will have this name as prefix.
<10> Defines the configuration (contents) of the pod.
<11> The name of the container.
<12> The name of the image to use. <<note12>>.
<13> Defines if the xref:../../dev_guide/managing_images.adoc#image-pull-policy[image should be pulled] prior to starting the container. If the image tag is *latest*, it will always pull the image by default, otherwise it will default to “IfNotPresent”.
<14> A set of environment variables to pass to this container.
<15> The ports that the container exposes.
<16> Volume mounts used in the container.
<17> Security context constraint to use for the container.
<18> Volumes required for the pod. xref:../../dev_guide/volumes.adoc#dev-guide-volumes[EmptyDir] is a temporary directory on a single machine.
<19> The triggers that will dictate on what conditions to deploy a new version of the pod.
<20> Create a new deployment when the latest image tag is updated.
<21> Create a new deployment when there is a configuration change for this Resource.

[[dev-guide-templates-designing-layer]]
=== Abstraction Layer
This layer defines all of the additional resources needed for our application to run, like networking, storage, security, and so forth.

Service::
A xref:../../architecture/core_concepts/pods_and_services.adoc#services[service] serves as an internal load balancer. It identifies a set of replicated pods in order to proxy the connections it receives to them. Backing pods can be added to or removed from a service arbitrarily while the service remains consistently available, enabling anything that depends on the service to refer to it at a consistent internal address.
::
Services are assigned an IP address and port pair that, when accessed, proxy to an appropriate backing pod. A service uses a label selector to find all the containers running that provide a certain network service on a certain port.

Route::
A xref:../../dev_guide/routes.adoc#dev-guide-routes[route] exposes a service at a host name, like www.example.com, so that external clients can reach it by name.

Persistent Volume Claim::
A xref:../../dev_guide/persistent_volumes.adoc#dev-guide-persistent-volumes[Persistent Volume Claim] is a request for storage resources; the claim is paired with a volume that generally matches your request.

Service Account::
xref:../../dev_guide/service_accounts.adoc#dev-guide-service-accounts[Service accounts] provide a flexible way to control API access without requiring regular user account credentials.

Secret::
A xref:../../dev_guide/secrets.adoc#dev-guide-secrets[secret] provides a mechanism to hold sensitive information such as passwords, {product-title} client config files, Docker configuration files, and so forth. Secrets decouple sensitive content from the pods and can be mounted into containers using a volume plug-in or used by the system to perform actions on behalf of a pod. 

In the example, there are a set of services abstracting the deployments:

* *A service for the backend component (MongoDB)*. This service is configured to target all pods running that have the `deploymentConfig=mlbparks-MongoDB` label, which happens
for every pod created by the deployment configuration specified.
+
[source,json]
----
{
   "kind": "Service",
   "apiVersion": "v1",
   "metadata": {
      "name": "MongoDB",             <1>
      "labels": {
         "application": "mlbparks"   <2>
      }
   },
   "spec": {
      "ports": [                     
         {
            "port": 27017,           <3>
            "targetPort": 27017      <4>
         }
      ],
      "selector": {                  <5> 
         "deploymentConfig": "mlbparks-MongoDB"
      }
   }
}
----
+
<1> Name of the service.
<2> Labels describing this service.
<3> Port where the service will be listening.
<4> Port in the pod to route the network traffic to.
<5> Label selector for determining which pods will be target for this service.

* *A service for the frontend component (JBoss EAP)*. This service is configured to target all pods running that have the `deploymentConfig=mlbparks` label, which happens
for every pod created by the deployment configuration specified.
+
[source,json]
----
{
   "kind": "Service",
   "apiVersion": "v1",
   "metadata": {
      "name": "mlbparks-http",           <1>
      "labels": {
         "application": "mlbparks"       <2> 
      },
      "annotations": {
         "description": "The web server's http port"
      }
   },
   "spec": {
      "ports": [
         {
            "port": 8080,                <3>
            "targetPort": 8080           <4>
         }
      ],
      "selector": {
         "deploymentConfig": "mlbparks"  <5>
      }
   }
}
----
+
<1> Name of the service.
<2> Labels describing this service.
<3> Port where the service will be listening.
<4> Port in the pod to route the network traffic to.
<5> Label selector for determining which pods will be target for this service.

* *A JBoss EAP service for its internal PING service*. The service, which is used for clustering purposes, can be configured to target all pods running that have the `deploymentConfig=mlbparks` label, which happens for every pod created by the deployment configuration specified.
+
[source,json]
----
{
   "kind": "Service",
   "apiVersion": "v1",
   "metadata": {
      "name": "mlbparks-ping",           <1>   
      "labels": {
         "application": "mlbparks"       <2>
      },
      "annotations": {
         "description": "Ping service for clustered applications"
      }
   },
   "spec": {
      "ports": [
         {
            "port": 8888,                <3>
            "targetPort": 8888           <4>
         }
      ],
      "selector": {
         "deploymentConfig": "mlbparks"  <5>
      }
   }
}
----
+
<1> Name of the service.
<2> Labels describing this service.
<3> Port where the service will be listening.
<4> Port in the pod to route the network traffic to.
<5> Label selector for determining which pods will be target for this service.

Also, to make the application publicly available, expose the service by providing HTTP access to the frontend component of the application using a route:

[source,json]
----
{
   "kind": "Route",
   "apiVersion": "v1",
   "metadata": {
      "name": "mlbparks-http-route",       <1>
      "labels": {
         "application": "mlbparks"         <2>
      },
      "annotations": {
         "description": "Route for application's http service"
      }
   },
   "spec": {
      "host": "mlbparks.cloudapps.example.com", # <3>
      "to": {                                   # <4>
         "kind": "Service",
         "name": "mlbparks-http"               
      }
   }
}
----
<1> Name of the route.
<2> Set of labels to describe the route.
<3> DNS name used to access our application. This DNS name needs to resolve to the IP address of the https://docs.openshift.com/enterprise/3.0/architecture/core_concepts/routes.adoc#routers[{product-title} router].
<4> Defines that this is a route to a service with the specified name.


[[dev-guide-templates-designing-labels]]
== Template Labels

To identify the resources you are deploying as a whole, it is important that all resources have a common label. 
In the example, the resources a label of `"application": "mlbparks"`.

You can use labels to:

* set different labels that help identify other parts of the deployment, such as `"deploymentConfig": "mlbparks"`;
* link as service code to a specific deployment configuration;
* filtering resources on a query. For example:
+
----
# oc get buildconfig --selector="application=mlbparks"
# oc get deploymentconfig --selector="deploymentConfig=mlbparks"
----

* delete every resource you created in one operation. For example:
+
----
# oc delete all --selector="application=mlbparks"
----

In the example is an application with a set of resources that to create. 

[[dev-guide-templates-designing-labels-all]]
=== Labels to describe all resources in the template
You can set labels for all the resources in a template by setting labels in the template resource. 
These labels will be set on every resource created when processing the template.

[source,json]
----
{
   "kind": "Template",
   "apiVersion": "v1",
   "metadata": {
      ...
   },
   "labels": {                      <1>            
      "application": "mlbparks",
      "createdBy": "template-mlbparks"
   },
   "parameters": [
      ...
   ],
   "objects": [
      ...
   ]
}
----

<1> Labels to describe all resources in the template.

In this example, two labels are set in the template resource: 

* `application`. This label defines that all resources in the template belong to the `mlbparks` application. 

* `createdBy`. This label defines that all resources with that label were created by the `template-mlbparks` template. 

[[dev-guide-templates-designing-parameters]]
== Template Parameters

You can use specific parameters to make a template reusable. 

The general process for creating template parameters is as follows:

* xref:dev-guide-templates-designing-parameters-id[Identify the information that will take a parameter].

* xref:dev-guide-templates-designing-parameters-set[Change values for parameters placeholders] to make the template configurable.

* xref:dev-guide-templates-designing-parameters-create[Create the `parameters` stanza for the template].

After you perform these these tasks, the parameters will be defined and the values will replace the placeholders 
when creating resources from this template.

[[dev-guide-templates-designing-parameters-id]]
=== Identify parameters

You can create parameters for any resource in the template, for example: 

* application name
* git configuration
* secrets
* inter-component communications configuration
* DNS
* Routes

[[dev-guide-templates-designing-parameters-set]]
=== Set the parameter placeholders

When you know which resources you want to create parameters for, replace the values with a parameter placeholder. 
When you process the template, the values in the `parameters` stanza replace the placeholders.

A parameter placeholder has the following format:

[source,json]
----
"<resource>": ${PARAMETER_NAME}
----

The following example shows a build configuration object with parameter placeholders:

[source,json]
----
{
   "kind": "BuildConfig",
   "apiVersion": "v1",
   "metadata": {
      "name": "${APPLICATION_NAME}", <1>
      "labels": {
         "application": "${APPLICATION_NAME}"
      }
   },
   "spec": {
      "triggers": [
         {
            "type": "Generic", 
            "generic": {
               "secret": "${GENERIC_TRIGGER_SECRET}"
            }
         },
         {
            "type": "GitHub",
            "github": {
               "secret": "${GITHUB_TRIGGER_SECRET}"
            }
         },
         {
            "type": "ImageChange",
            "imageChange": {}
         }
      ],
      "source": {
         "type": "Git",
         "git": {
            "uri": "${GIT_URI}",
            "ref": "${GIT_REF}"
         }
      },
      "strategy": {
         "type": "Source",
         "sourceStrategy": {
            "from": {
               "kind": "ImageStreamTag",
               "namespace": "openshift",
               "name": "jboss-eap6-openshift:${EAP_RELEASE}"
            }
         }
      },
      "output": {
         "to": {
            "kind": "ImageStreamTag",
            "name": "${APPLICATION_NAME}:latest"
         }
      }
   }
}
----

<1> The parameter placeholder can be any descriptive text and must match the appropriate parameter label in the `parameters` stanza.

[[dev-guide-templates-designing-parameters-create]]
=== Create the parameter stanza

The `parameters` stanza contains the values that are entered in the parameter placeholders. 

There are two types of parameters:

* Parameters with auto-generated values using the `value` field.
+
[source,json]
----
{
   "description": "EAP Release version, e.g. 6.4, etc.",
   "name": "EAP_RELEASE",
   "value": "6.4"
},
----

* Parameters with default values using the `from` field.
+
[source,json]
----
{
   "description": "Github trigger secret",
   "name": "GITHUB_TRIGGER_SECRET",
   "from": "[a-zA-Z0-9]{8}",
   "generate": "expression"
},
----

A full `parameters` stanza looks like the following:

[source,json]
----
   "parameters": [
      {
         "description": "EAP Release version, e.g. 6.4, etc.",
         "name": "EAP_RELEASE",
         "value": "6.4"
      },
      {
         "description": "The name for the application.",
         "name": "APPLICATION_NAME",
         "value": "mlbparks"
      },
      {
         "description": "Custom hostname for service routes.",
         "name": "APPLICATION_HOSTNAME"
      },
      {
         "description": "Git source URI for application",
         "name": "GIT_URI",
         "value": "https://github.com/jorgemoralespou/openshift3mlbparks.git"
      },
      {
         "description": "Git branch/tag reference",
         "name": "GIT_REF",
         "value": "master"
      },
      {
         "description": "Database name",
         "name": "MONGODB_DATABASE",
         "value": "root"
      },
      {
         "description": "Database user name", <1>
         "name": "MONGODB_USER",
         "from": "user[a-zA-Z0-9]{3}",
         "generate": "expression"
      },
      {
         "description": "Database user password", <1>
         "name": "MONGODB_PASSWORD",
         "from": "[a-zA-Z0-9]{8}",
         "generate": "expression"
      },
      {
         "description": "Github trigger secret",
         "name": "GITHUB_TRIGGER_SECRET",
         "from": "[a-zA-Z0-9]{8}",
         "generate": "expression"
      },
      ....
]
----

<1> If you generate a random user name and password for a database application with an `expression`, the values get injected in the environment variables for both pods (web and database),
so the two pods accept the same user and password credentials.
