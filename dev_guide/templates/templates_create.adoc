[[dev-guide-templates-creating]]
= Creating New Templates
{product-author}
{product-version}
:data-uri:
:icons:
:experimental:
:toc: macro
:toc-title:
:prewrap!:

toc::[]
{nbsp} +

include::dev_guide/templates/templates_using.adoc[tag=default-templates]

In addition, you can: 

* write your own templates in {product-title}

* create templates outside of the environment and upload them

* edit existing templates to create new templates

* create templates from existing {product-title} objects. 

After you have created the template, see xref:../../dev_guide/templates/templates_edit.adoc#dev-guide-templates-editing[Modifying Templates]
for ideas on what you can do with templates.

Before you start, take a look at the xref:other-recommendations[Template Creation Best Practices]
section at the end of this topic.

[[writing-templates]]
== Writing New Templates
You can define new templates to make it easy to recreate all the objects of your
application.  The template will define the objects it creates along with some
metadata to guide the creation of those objects.

//include::dev_guide/templates/templates_examples.adoc[tag=dev-guide-template-example-callout]

The template format is link:http://golang.org/pkg/text/template/#pkg-overview[golang templates].

== Uploading templates

//tag::uploading-templates[]
If you have a JSON or YAML file that defines a template, you can upload
the template to projects using the CLI. This saves the template to the project
for repeated use by any user with appropriate access to that project.

For tips on creating new templates, see xref:writing-templates[Writing New Templates]
and xref:other-recommendations[Template Creation Best Practices]. 

To upload a template to your current project's template library, pass the JSON
or YAML file with the following command:

----
$ oc create -f <filename>
----

You can upload a template to a different project using the `-n` option with the
name of the project:

----
$ oc create -f <filename> -n <project>
----

The template is now available for selection using the web console or the CLI.
//end::uploading-templates[]

[[edit-a-template]]
== Creating a Template from Another Template

You can create a new template based on one that has already been uploaded to your project: 

The default templates are located in
ifdef::openshift-origin[]
*_/openshift-ansible/roles/openshift_examples/files/examples/v3.7/_*
endif::[]
ifdef::openshift-enterprise[]
*_/usr/share/ansible/openshift-ansible/roles/openshift_examples/files/examples/v3.7/_*
endif::[]
.

. Make a copy of the template you want to edit:
+
----
cp <template-name>.yaml <new-template-name>.yaml
cp <template-name>.json <new-template-name>.json
----
+
For example:
+
----
cp sso71-https.json sso72-https.json
----

. In a text editor, edit the fields as needed and save. Make sure to change the template name. 

. Create the template object:
+
----
oc create -f <temaplte-name>.json
----
+
For example:
+
----
oc create -f sso72.json
----

You can now xref:../../dev_guide/templates/templates_using.adoc#dev-guide-templates-using[use the template to create objects] the same as any other template.

[[export-as-template]]
== Creating a Template from Existing Objects
ifdef::openshift-online[]
If you are upgrading from {product-title} Starter to {product-title} Pro, use
`oc export all` to export all of your existing objects. {product-title} Pro does
not support per-object resource migration.
endif::[]

Rather than writing an entire template from scratch, you can export existing
objects from your project in template form, and then modify the template from
there by adding parameters and other customizations. 

To create a template from an object:

. Export an object in a project in template form:
+
----
$ oc export <object-type> <object-name> --as-template=<template_name> > <path-to-template_filename>
----
+
The `<template-name>` is assigned to the `name` parameter in the template and 
`<path-to-template_filename>` is the file name and location where the template is created.
+
The `<object-type>` can be any of the following:

- BuildConfig
- Build
- DeploymentConfig
- ImageStream
- Pod
- ReplicationController
- Route
- Service
- Template
+
For example:
+
----
oc export pod mypod-1 --as-template pod-template > /etc/template/pod-template.yaml
----

. In a text editor, edit the fields as needed and save. Make sure to change the template name and 
add a description if not present. 

. Create the template object:
+
----
oc create -f <temaplte-name>.yaml
----
+
For example:
+
----
oc create -f pod-template.yaml
----

You can now xref:../../dev_guide/templates/templates_using.adoc#dev-guide-templates-using[use the template to create objects] the same as any other template.

[[other-recommendations]]
== Template Creation Best Practices

* Group related services together in the management console by adding the
`service.alpha.openshift.io/dependencies` annotation to the Service object in
your template.
+
.Group the Frontend and Database Services Together on the Management Console Overview.

[source,yaml]
----
kind: "Template"
apiVersion: "v1"
objects:
  - kind: "Service"
    apiVersion: "v1"
    metadata:
      name: "frontend"
      annotations:
        "service.alpha.openshift.io/dependencies": "[{\"name\": \"database\", \"kind\": \"Service\"}]"
...
  - kind: "Service"
    apiVersion: "v1"
    metadata:
      name: "database"
----

* Set xref:../../dev_guide/compute_resources.adoc#dev-compute-resources[memory, CPU], and
xref:../../architecture/additional_concepts/storage.adoc#pvc-resources[storage]
default sizes to make sure your application is given enough resources to run
smoothly.

* Avoid referencing the `latest` tag from images if that tag is used across major
versions. This may cause running applications to break when new images are
pushed to that tag.

* A good template builds and deploys cleanly without requiring modifications
after the template is deployed.

* Design your template visually, as it helps understand the required components.

* Provide meaningful names to resources and use labels to describe your resources (labels are used as selectors for some resources).

* Templates can be shared or per-project, and common templates are in the *openshift* namespace/project.

* Currently there is no ability to set a Readme on templates, so be as verbose and complete in the template's description.

* Once the resources in a template are processed and deployed, they can be modified with the CLI.

* You should xref:../../dev_guide/compute_resources.adoc#dev-compute-resources[constrain the CPU and memory a container in a pod can use]. 

* When the resources in a template are created, if there is a build configuration defined, it will only start an automated build if there is 
an xref:../../dev_guide/builds/triggering_builds.adoc#image-change-triggersimage change trigger defined. 

* Parameterize everything a user of your template might want to customize so they can control the behavior of the template when they instantiate it.
