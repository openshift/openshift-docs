= Builds
{product-author}
{product-version}
:data-uri:
:icons:
:experimental:
:toc: macro
:toclevels: 3
:toc-title:
:prewrap!:

toc::[]

== Overview

A link:../architecture/core_concepts/builds_and_image_streams.html#builds[build]
is the process of transforming input parameters into a resulting object. Most
often, the process is used to transform source code into a runnable image.

Build configurations are characterized by a strategy and one or more sources.
The strategy determines the aforementioned process, while the sources provide
its input.

There are three build strategies:

- Source-To-Image (S2I)
(link:../architecture/core_concepts/builds_and_image_streams.html#source-build[description],
link:#source-to-image-strategy-options[options])
- Docker
(link:../architecture/core_concepts/builds_and_image_streams.html#docker-build[description],
link:#docker-strategy-options[options])
- Custom
(link:../architecture/core_concepts/builds_and_image_streams.html#custom-build[description],
link:#custom-strategy-options[options])

And there are four types of build source:

- link:#source-code[Git]
- link:#dockerfile-source[Dockerfile]
- link:#image-source[Image]
- link:#binary-source[Binary]

It is up to each build strategy to consider or ignore a certain type of source,
as well as to determine how it is to be used.

Binary and Git are mutually exclusive source types, while Dockerfile and Image can be used
by themselves, with each other, or together with either Git or Binary.

Also, the Binary build source type is unique from the other options in how it is
specified to the system.  Exactly how is detailed link:#binary-source[below].


[[defining-a-buildconfig]]

== Defining a BuildConfig

A build configuration describes a single build definition and a set of
link:#build-triggers[triggers] for when a new build should be created.

A build configuration is defined by a `*BuildConfig*`, which is a REST object
that can be used in a POST to the API server to create a new instance. The
following example `*BuildConfig*` results in a new build every time a Docker
image tag or the source code changes:

.BuildConfig Object Definition
====
[source,yaml]
----
kind: "BuildConfig"
apiVersion: "v1"
metadata:
  name: "ruby-sample-build" <1>
spec:
  triggers: <2>
    -
      type: "GitHub"
      github:
        secret: "secret101"
    -
      type: "Generic"
      generic:
        secret: "secret101"
    -
      type: "ImageChange"
  source: <3>
    type: "Git"
    git:
      uri: "git://github.com/openshift/ruby-hello-world.git"
    dockerfile: "FROM openshift/ruby-22-centos7\nUSER example"
  strategy: <4>
    type: "Source"
    sourceStrategy:
      from:
        kind: "ImageStreamTag"
        name: "ruby-20-centos7:latest"
  output: <5>
    to:
      kind: "ImageStreamTag"
      name: "origin-ruby-sample:latest"
  postCommit: <6>
      script: "bundle exec rake test"
----

<1> This specification will create a new `*BuildConfig*` named
*ruby-sample-build*.
<2> You can specify a list of link:#build-triggers[triggers], which cause a new
build to be created.
<3> The `*source*` section defines the source of the build. The source type
determines the primary source of input, and can be either `*Git*`, to point to
a code repository location, `*Dockerfile*`, to build from an inline Dockerfile,
or `*Binary*`, to accept binary payloads. It is possible to have multiple
sources at once, refer to the documentation for each source type for details.
<4> The `*strategy*` section describes the build strategy used to execute the
build. You can specify `*Source*`, `*Docker*` and `*Custom*` strategies here.
This above example uses the `*ruby-20-centos7*` Docker image that
Source-To-Image will use for the application build.
<5> After the Docker image is successfully built, it will be pushed into the
repository described in the `*output*` section.
<6> The `*postCommit*` section defines an optional link:#build-hooks[build
hook].
====

[[source-to-image-strategy-options]]

== Source-to-Image Strategy Options

The following options are specific to the
link:../architecture/core_concepts/builds_and_image_streams.html#source-build[S2I
build strategy].

[[s2i-force-pull]]

=== Force Pull

By default, if the builder image specified in the build configuration is
available locally on the node, that image will be used. However, to override the
local image and refresh it from the registry to which the image stream points,
create a `*BuildConfig*` with the `*forcePull*` flag set to *true*:

====
[source,yaml]
----
strategy:
  type: "Source"
  sourceStrategy:
    from:
      kind: "ImageStreamTag"
      name: "builder-image:latest" <1>
    forcePull: true <2>
----

<1> The builder image being used, where the local version on the node may not be
up to date with the version in the registry to which the image stream points.
<2> This flag causes the local builder image to be ignored and a fresh version
to be pulled from the registry to which the image stream points. Setting
`*forcePull*` to *false* results in the default behavior of honoring the image
stored locally.
====

[[incremental-builds]]

=== Incremental Builds

S2I can perform incremental builds, which means it reuses artifacts from
previously-built images. To create an incremental build, create a
`*BuildConfig*` with the following modification to the strategy definition:

====
[source,yaml]
----
strategy:
  type: "Source"
  sourceStrategy:
    from:
      kind: "ImageStreamTag"
      name: "incremental-image:latest" <1>
    incremental: true <2>
----

<1> Specify an image that supports incremental builds. Consult the
documentation of the builder image to determine if it supports this behavior.
<2> This flag controls whether an incremental build is attempted. If the builder
image does not support incremental builds, the build will still succeed, but you
will get a log message stating the incremental build was not successful because
of a missing *_save-artifacts_* script.
====

[NOTE]
====
See the link:../creating_images/s2i.html[S2I Requirements] topic for information
on how to create a builder image supporting incremental builds.
====

[[override-builder-image-scripts]]

=== Overriding Builder Image Scripts

You can override the *_assemble_*, *_run_*, and *_save-artifacts_*
link:../creating_images/s2i.html#s2i-scripts[S2I scripts] provided by the
builder image in one of two ways. Either:

1. Provide an *_assemble_*, *_run_*, and/or *_save-artifacts_* script in the
*_.s2i/bin_* directory of your application source repository, or

2. Provide a URL of a directory containing the scripts as part of the strategy
definition. For example:

====
[source,yaml]
----
strategy:
  type: "Source"
  sourceStrategy:
    from:
      kind: "ImageStreamTag"
      name: "builder-image:latest"
    scripts: "http://somehost.com/scripts_directory" <1>
----

<1> This path will have *_run_*, *_assemble_*, and *_save-artifacts_* appended
to it. If any or all scripts are found they will be used in place of the same
named script(s) provided in the image.
====

[NOTE]
====
Files located at the `*scripts*` URL take precedence over files located in
*_.s2i/bin_* of the source repository. See the
link:../creating_images/s2i.html[S2I Requirements] topic and the
link:https://github.com/openshift/source-to-image/blob/master/docs/builder_image.md#sti-scripts[S2I
documentation] for information on how S2I scripts are used.
====

[[configuring-the-source-environment]]
=== Environment Variables

There are two ways to make environment variables available to the
link:../architecture/core_concepts/builds_and_image_streams.html#source-build[source build]
process and resulting \image: link:#environment-files[environment files] and
link:#buildconfig-environment[*BuildConfig* environment] values.

[[environment-files]]

==== Environment Files
Source build enables you to set environment values (one per line) inside your
application, by specifying them in a *_.s2i/environment_* file in the source
repository. The environment variables specified in this file are present during
the build process and in the final Docker image. The complete list of supported
environment variables is available in the
link:../using_images/index.html[documentation] for each image.

If you provide a *_.s2i/environment_* file in your source repository, S2I reads
this file during the build. This allows customization of the build behavior as
the *_assemble_* script may use these variables.

For example, if you want to disable assets compilation for your Rails
application, you can add `*DISABLE_ASSET_COMPILATION=true*` in the
*_.s2i/environment_* file to cause assets compilation to be skipped during the
build.

In addition to builds, the specified environment variables are also available in
the running application itself. For example, you can add
`*RAILS_ENV=development*` to the *_.s2i/environment_* file to cause the Rails
application to start in `development` mode instead of `production`.

[[buildconfig-environment]]

==== BuildConfig Environment
You can add environment variables to the `*sourceStrategy*` definition of the
`*BuildConfig*`. The environment variables defined there are visible during the
*_assemble_* script execution and will be defined in the output image, making
them also available to the *_run_* script and application code.

For example disabling assets compilation for your Rails application:

====
[source,yaml]
----
sourceStrategy:
...
  env:
    -
      name: "DISABLE_ASSET_COMPILATION"
      value: "true"
----
====

[[docker-strategy-options]]

== Docker Strategy Options

The following options are specific to the
link:../architecture/core_concepts/builds_and_image_streams.html#docker-build[Docker
build strategy].


[[docker-strategy-from]]

=== FROM image

The `FROM` instruction of the *_Dockerfile_* will be replaced by the `*from*` of the `*BuildConfig*`:

====
[source,yaml]
----
strategy:
  type: Docker
  dockerStrategy:
    from:
      kind: "ImageStreamTag"
      name: "debian:latest"
----
====


[[dockerfile-path]]

=== Dockerfile Path

By default, Docker builds use a Dockerfile (named *_Dockerfile_*) located at the
root of the context specified in the `*BuildConfig.spec.source.contextDir*`
field.

The `*dockerfilePath*` field allows the build to use a different path to
locate your Dockerfile, relative to the `*BuildConfig.spec.source.contextDir*`
field. It can be simply a different file name other than the default
*_Dockerfile_* (for example, *_MyDockerfile_*), or a path to a Dockerfile in a
subdirectory (for example, *_dockerfiles/app1/_*):

====
[source,yaml]
----
strategy:
  type: Docker
  dockerStrategy:
    dockerfilePath: dockerfiles/app1/
----
====

[[no-cache]]

=== No Cache

Docker builds normally reuse cached layers found on the host performing the
build. Setting the `*noCache*` option to *true* forces the build to ignore
cached layers and rerun all steps of the *_Dockerfile_*:

====
[source,yaml]
----
strategy:
  type: "Docker"
  dockerStrategy:
    noCache: true
----
====

[[docker-force-pull]]

=== Force Pull

By default, if the builder image specified in the build configuration is
available locally on the node, that image will be used. However, to override the
local image and refresh it from the registry to which the image stream points,
create a `*BuildConfig*` with the `*forcePull*` flag set to *true*:

====
[source,yaml]
----
strategy:
  type: "Docker"
  dockerStrategy:
    forcePull: true <1>
----
<1> This flag causes the local builder image to be ignored, and a fresh version
to be pulled from the registry to which the image stream points. Setting
`*forcePull*` to *false* results in the default behavior of honoring the image
stored locally.
====

[[docker-strategy-environment]]
=== Environment Variables

To make environment variables available to the
link:../architecture/core_concepts/builds_and_image_streams.html#docker-build[Docker build]
process and resulting image, you can add environment variables to the
`*dockerStrategy*` definition of the `*BuildConfig*`.

The environment variables defined there are inserted as a single `ENV`
Dockerfile instruction right after the `FROM` instruction, so that it can be
referenced later on within the Dockerfile.

The variables are defined during build and stay in the output image, therefore
they will be present in any container that runs that image as well.

For example, defining a custom HTTP proxy to be used during build and runtime:

====
[source,yaml]
----
dockerStrategy:
...
  env:
    -
      name: "HTTP_PROXY"
      value: "http://myproxy.net:5187/"
----
====

[[custom-strategy-options]]

== Custom Strategy Options

The following options are specific to the
link:../architecture/core_concepts/builds_and_image_streams.html#custom-build[Custom
build strategy].

[[expose-docker-socket]]

=== Exposing the Docker Socket

In order to allow the running of Docker commands and the building of Docker
images from inside the Docker container, the build container must be bound to an
accessible socket. To do so, set the `*exposeDockerSocket*` option to *true*:

====
[source,yaml]
----
strategy:
  type: "Custom"
  customStrategy:
    exposeDockerSocket: true
----
====

[[custom-secrets]]

=== Secrets

In addition to link:../dev_guide/secrets.html[secrets] for
link:#using-private-repositories-for-builds[source] and
link:#using-docker-credentials-for-pushing-and-pulling-images[images] that can
be added to all build types, custom strategies allow adding an arbitrary list of
secrets to the builder pod.

Each secret can be mounted at a specific location:

====
[source,yaml]
----
strategy:
  type: "Custom"
  customStrategy:
    secrets:
      -
        secretSource: <1>
          name: "secret1"
        mountPath: "/tmp/secret1" <2>
      -
        secretSource:
          name: "secret2"
        mountPath: "/tmp/secret2"
----

<1> `*secretSource*` is a reference to a secret in the same namespace as the
build.
<2> `*mountPath*` is the path inside the custom builder where the secret should
be mounted.
====

[[custom-force-pull]]

=== Force Pull

By default, when setting up the build pod, the build controller checks if the
image specified in the build configuration is available locally on the node.  If
so, that image will be used.  However, to override the local image and refresh
it from the registry to which the image stream points, create a `*BuildConfig*`
with the `*forcePull*` flag set to *true*:

====
[source,yaml]
----
strategy:
  type: "Custom"
  customStrategy:
    forcePull: true <1>
----

<1> This flag causes the local builder image to be ignored, and a fresh version
to be pulled from the registry to which the image stream points. Setting
`*forcePull*` to *false* results in the default behavior of honoring the image
stored locally.
====

[[custom-strategy-environment]]
=== Environment Variables

To make environment variables available to the
link:../architecture/core_concepts/builds_and_image_streams.html#custom-build[Custom build]
process, you can add environment variables to the `*customStrategy*` definition
of the `*BuildConfig*`.

The environment variables defined there are passed to the pod that runs the
custom build.

For example, defining a custom HTTP proxy to be used during build:

====
[source,yaml]
----
customStrategy:
...
  env:
    -
      name: "HTTP_PROXY"
      value: "http://myproxy.net:5187/"

----
====

[[build-inputs]]
== Build Inputs

There are several ways to provide content for builds to operate on. In order of precedence:

* Inline Dockerfile definitions
* Content extracted from existing images
* Git repositories
* Binary inputs

These can be combined into a single build. As the inline Dockerfile takes precedence, it can overwrite any other file named Dockerfile provided by another input. Binary input and Git repository are mutually exclusive inputs.

When the build is run, a working directory is constructed and all input content is placed in the working directory (e.g. the input git repository is cloned into the working directory, files specified from input images are copied into the working directory using the target path).  Next the build process will `*cd*` into the `*contextDir*` if one is defined.  Then the inline `*Dockerfile*` (if any) is written to the current directory.  Last, the content from the current directory will be provided to the build process for reference by the `*Dockerfile*`, `*assemble*` script, or custom builder logic.  This means any input content that resides outside the `*contextDir*` will be ignored by the build.

Here is an example of a source definition that includes multiple input types and an explanation of how they are combined.  For more details
on how each input type is defined, see the specific sections for each input type.

====
[source,yaml]
----
source:
  git:
    uri: https://github.com/openshift/ruby-hello-world.git <1>
  images: 
  - from: 
      kind: ImageStreamTag
      name: myinputimage:latest
      namespace: mynamespace
    paths: 
    - destinationDir: app/dir/injected/dir <2>
      sourcePath: /usr/lib/somefile.jar
  contextDir: "app/dir" <3>
  dockerfile: "FROM centos:7\nRUN yum install -y httpd" <4>

----

<1> The repository to be cloned into the working directory for the build
<2> `*/usr/lib/somefile.jar*` from `*myinputimage*` will be stored in `*<workingdir>/app/dir/injected/dir*`
<3> The working dir for the build will become `*<original_workingdir>/app/dir*`
<4> A `*Dockerfile*` with this content will be created in `*<original_workingdir>/app/dir*`, overwriting any existing file with that name
====


[[source-code]]

=== Git Repository Source Options

When the `*BuildConfig.spec.source.type*` is `*Git*`, a Git repository is
required, and an inline Dockerfile is optional.

The source code is fetched from the location specified and, if the
`*BuildConfig.spec.source.dockerfile*` field is specified, the inline Dockerfile
replaces the one in the `*contextDir*` of the Git repository.

The source definition is part of the `*spec*` section in the `*BuildConfig*`:

====
[source,yaml]
----
source:
  type: "Git"
  git: <1>
    uri: "git://github.com/openshift/ruby-hello-world.git"
    ref: "master"
  contextDir: "app/dir" <2>
  dockerfile: "FROM openshift/ruby-22-centos7\nUSER example" <3>
----
<1> The `*git*` field contains the URI to the remote Git repository of the
source code. Optionally, specify the `*ref*` field to check out a specific Git
reference. A valid `*ref*` can be a SHA1 tag or a branch name.
<2> The `*contextDir*` field allows you to override the default location inside
the source code repository where the build looks for the application source
code. If your application exists inside a sub-directory, you can override the
default location (the root folder) using this field.
<3> If the optional `*dockerfile*` field is provided, it should be a string
containing a Dockerfile that overwrites any Dockerfile that may exist in the
source repository.
====

[[using-a-proxy-for-git-cloning]]

==== Using a Proxy for Git Cloning

// tag::using-a-proxy-for-git-cloning-1[]

If your Git repository can only be accessed using a proxy, you can define the
proxy to use in the `*source*` section of the `*BuildConfig*`. You can configure
both a HTTP and HTTPS proxy to use. Both fields are optional.

[NOTE]
====
Your source URI must use the HTTP or HTTPS protocol for this to work.
====

====
[source,yaml]
----
source:
  type: Git
  git:
    uri: "git://github.com/openshift/ruby-hello-world.git"
    httpProxy: http://proxy.example.com
    httpsProxy: https://proxy.example.com
----
====

// end::using-a-proxy-for-git-cloning-1[]


[[using-private-repositories-for-builds]]
==== Using Private Repositories for Builds

Supply valid credentials to build an application from a private repository.

Currently two types of authentication are supported: basic username-password
and SSH key based authentication.

[[basic-authentication]]
===== Basic Authentication

Basic authentication requires either a combination of `username` and `password`,
or a `token` to authenticate against the SCM server. A `CA certificate` file,
or a `.gitconfig` file can be attached.

A link:../dev_guide/secrets.html[`*secret*`] is used to store your keys.

. Create the `*secret*` first before using the username and password to access
the private repository:
+
====
----
$ oc secrets new-basicauth basicsecret --username=USERNAME --password=PASSWORD
----
====

.. To create a Basic Authentication Secret with a token:
+
====
----
$ oc secrets new-basicauth basicsecret --password=TOKEN
----
====

.. To create a Basic Authentication Secret with a CA certificate file:
+
====
----
$ oc secrets new-basicauth basicsecret --username=USERNAME --password=PASSWORD --ca-cert=FILENAME
----
====

.. To create a Basic Authentication Secret with a `.gitconfig` file:
+
====
----
$ oc secrets new-basicauth basicsecret --username=USERNAME --password=PASSWORD --gitconfig=FILENAME
----
====

. Add the `*secret*` to the builder service account. Each build is run with
`serviceaccount/builder` role, so you need to give it access your secret with
following command:
+
====
----
$ oc secrets add serviceaccount/builder secrets/basicsecret
----
====

. Add a `*sourceSecret*` field to the `*source*` section inside the
`*BuildConfig*` and set it to the name of the `*secret*` that you created.
In this case `*basicsecret*`:
+
====
[source,yaml]
----
apiVersion: "v1"
kind: "BuildConfig"
metadata:
  name: "sample-build"
spec:
  output:
    to:
      kind: "ImageStreamTag"
      name: "sample-image:latest"
  source:
    git:
      uri: "https://github.com/user/app.git" <1>
    sourceSecret:
      name: "basicsecret"
    type: "Git"
  strategy:
    sourceStrategy:
      from:
        kind: "ImageStreamTag"
        name: "python-33-centos7:latest"
    type: "Source"
----
<1> The URL of private repository, accessed by basic authentication, is usually
in the `http` or `https` form.
====


[[ssh-key-authentication]]
===== SSH Key Based Authentication

SSH Key Based Authentication requires a private SSH key. A `.gitconfig` file can
also be attached.

The repository keys are usually located in the `$HOME/.ssh/` directory, and are named
`id_dsa.pub`, `id_ecdsa.pub`, `id_ed25519.pub`, or `id_rsa.pub` by default.
Generate SSH key credentials with the following command:

====

----
$ ssh-keygen -t rsa -C "your_email@example.com"
----
====

[NOTE]
====
Creating a passphrase for the SSH key prevents OpenShift from building. When
prompted for a passphrase, leave it blank.
====

Two files are created: the public key and a corresponding private key (one of
`id_dsa`, `id_ecdsa`, `id_ed25519`, or `id_rsa`). With both of these in place,
consult your source control management (SCM) system's manual on how to upload
the public key. The private key will be used to access your private repository.

A link:../dev_guide/secrets.html[`*secret*`] is used to store your keys.

. Create the `*secret*` first before using the SSH key to access the private
repository:
+
====
----
$ oc secrets new-sshauth sshsecret --ssh-privatekey=$HOME/.ssh/id_rsa
----
====

.. To create a SSH Based Authentication Secret with a `.gitconfig` file:
+
====
----
$ oc secrets new-sshauth sshsecret --ssh-privatekey=$HOME/.ssh/id_rsa --gitconfig=FILENAME
----
====

. Add the `*secret*` to the builder service account. Each build is run with
`serviceaccount/builder` role, so you need to give it access your secret with
following command:
+
====

----
$ oc secrets add serviceaccount/builder secrets/sshsecret
----
====

. Add a `*sourceSecret*` field into the `*source*` section inside the
`*BuildConfig*` and set it to the name of the `*secret*` that you created.
In this case `*sshsecret*`:
+
====
[source,yaml]
----
apiVersion: "v1"
kind: "BuildConfig"
metadata:
  name: "sample-build"
spec:
  output:
    to:
      kind: "ImageStreamTag"
      name: "sample-image:latest"
  source:
    git:
      uri: "git@repository.com:user/app.git" <1>
    sourceSecret:
      name: "sshsecret"
    type: "Git"
  strategy:
    sourceStrategy:
      from:
        kind: "ImageStreamTag"
        name: "python-33-centos7:latest"
    type: "Source"
----
<1> The URL of private repository, accessed by a private SSH key, is usually
in the form `git@example.com:<username>/<repository>.git`.
====

[[other-authentication]]
===== Other

In case the cloning of your application is dependent on a `CA certificate`, `.gitconfig`
file or both, you can create a secret that contains them, add it to the builder service
account and then your `BuildConfig`.

. Create desired type of `*secret*`:

.. To create a secret from a `.gitconfig`:
+
====
----
$ oc secrets new mysecret .gitconfig=path/to/.gitconfig
----
====
.. To create a secret from a `CA certificate`:
+
====
----
$ oc secrets new mysecret ca.crt=path/to/certificate
----
====
.. To create a secret from a `CA certificate` and `.gitconfig`:
+
====
----
$ oc secrets new mysecret ca.crt=path/to/certificate .gitconfig=path/to/.gitconfig
----
====

[NOTE]
====
Please note that SSL verification can be turned off, if `sslVerify=false` is set
for the `http` section in your `.gitconfig` file:
----
[http]
        sslVerify=false
----
====

. Add the `*secret*` to the builder service account. Each build is run with
`serviceaccount/builder` role, so you need to give it access your secret with
following command:

+
====
----
$ oc secrets add serviceaccount/builder secrets/mysecret
----
====


[[dockerfile-source]]

=== Dockerfile Source

When the `*BuildConfig.spec.source.type*` is `*Dockerfile*`, an inline
Dockerfile is used as the build input, and no additional sources can be
provided.

This source type is valid when the build strategy type is `*Docker*` or
`*Custom*`.

The source definition is part of the `*spec*` section in the `*BuildConfig*`:

====
[source,yaml]
----
source:
  type: "Dockerfile"
  dockerfile: "FROM centos:7\nRUN yum install -y httpd" <1>
----
<1> The `*dockerfile*` field contains an inline Dockerfile that will be built.
====

[[binary-source]]

=== Binary Source

Streaming content in binary format from a local file system to the builder is called a `*binary type build*`.
The corresponding value of `*BuildConfig.spec.source.type*` is `*Binary*` for such builds.

This source type is unique in that it is leveraged solely based on your use of the `oc start-build`.

[NOTE]
====
Since binary type builds require content to be streamed from the local file system, it is not possible
to automatically trigger a binary type build (e.g. via an image change trigger) because the binary files could
not be provided. Similarly, you cannot launch binary type builds from the web console.
====

To utilize binary builds, invoke `oc start-build` with one of these options:

1) `--from-file`:  The contents of the file you specify will be sent as a binary stream to the builder.  Then
the builder will store the data in a file with the same name at the top of the build context.

2) `--from-dir` and `--from-repo`:  The contents will be archived and sent as a binary stream to the builder.
Then the builder will extract the contents of the archive within the build context directory.

In each of the above cases:

1) If your `*BuildConfig*` already has a `*Binary*` source type defined, it will effectively be ignored and replaced by what the
client sends.

2) If your `*BuildConfig*` has a `*Git*` source type defined, it will be dynamically disabled, since `*Binary*` and `*Git*` are
mutually exclusive, and the data in the binary stream provided to the builder will take precedence.

When using `oc new-build --binary=true`, the command ensures that the restrictions associated with binary builds are enforced.
The resulting `*BuildConfig*` will have a source type of `*Binary*`, meaning that the only valid way to run a build for this `*BuildConfig*`
will be to use `oc start-build` with one of the `--from` options to provide the requisite binary data.

The `*dockerfile*` and `*contextDir*` link:#source-code[source options] have special meaning with binary builds.

The `*dockerfile*` can be used with any form of `*Binary*` build source.  If `*dockerfile*` is used and the binary stream
is an archive, its contents serve as a replacement Dockerfile to any Dockerfile in the archive.  If `*dockerfile*` is used, and if the
`--from-file` argument is used, and the file argument is named "Dockerfile", the value from `*dockerfile*` replaces the value from
the binary stream.

In the case of the binary stream encapsulating extracted archive content, the value of the `*contextDir*` field is interpreted as
a subdirectory within the archive, and if valid, the builder changes into that subdirectory before executing the build.

[[image-source]]

=== Image Source

Additional files can be provided to the build process via images.  Input
images are referenced in the same way the `From` and `To` image targets
are defined.  This means both docker images and image stream
tags can be referenced.  In conjunction with the image, you must provide one or
more path pairs to indicate the path of the files/directories to copy out of the
image and the destination to place them in the build context.

The source path can be any absolute path within the image specified.  The destination
must be a relative directory path.  At build time, the image will be loaded
and the indicated files/directories will be copied into the context directory
of the build process.  This is the same directory into which the source repository
content (if any) is cloned.  If the source path ends in `*/.*` then the content
of the directory will be copied, but the directory itself will not be created
at the destination.

Image inputs are specified in the `*source*` definition of the `*BuildConfig*`:

====
[source,yaml]
----
source:
  git:
    uri: https://github.com/openshift/ruby-hello-world.git
  images: <1>
  - from: <2>
      kind: ImageStreamTag
      name: myinputimage:latest
      namespace: mynamespace
    paths: <3>
    - destinationDir: injected/dir <4>
      sourcePath: /usr/lib/somefile.jar <5>
  - from:
      kind: ImageStreamTag
      name: myotherinputimage:latest
      namespace: myothernamespace
    pullSecret: mysecret <6>
    paths:
    - destinationDir: injected/dir
      sourcePath: /usr/lib/somefile.jar

----

<1> An array of one or more input images and files.
<2> A reference to the image containing the files to be copied.
<3> An array of source/destination paths.
<4> The directory relative to the build root where the build process can access the file.
<5> The location of the file to be copied out of the referenced image.
<6> An optional secret provided if credentials are needed to access the input image.
====

NOTE: This feature is not supported for builds using the `*Custom*` strategy.

[[using-secrets]]
== Using Secrets During a Build

In some scenarios operations performed by the build require credentials to access
dependent resources, but it is undesirable for those credentials to be available
in the final application image produced by the build.

For example, you are building a NodeJS application and you set up your private
mirror for NodeJS modules. In order to download modules from that private mirror,
you have to supply a custom *_.npmrc_* file for the build that contains a URL,
username and password. For security reasons, you do not want to expose your
credentials in the application image.

While this example describes NodeJS, you can use the same approach for adding
SSL certificates into the *_/etc/ssl/certs_* directory, API keys or tokens, license
files, etc.

[[using-secrets-in-the-buildconfig]]
=== Defining Secrets in the BuildConfig

First, you have to create the `Secret` you want to use. You can do that by
executing the following command:

----
$ oc secrets new secret-npmrc .npmrc=~/.npmrc
----

This command will create a new `Secret` named *_secret-npmrc_* and store
the base64 encoded content of the *_~/.npmrc_* file in it.

Now, that you have the secret created, you can add references to `*secrets*`
into the `*source*` section in the existing `BuildConfig`:

[source,yaml]
----
source:
  git:
    uri: https://github.com/openshift/nodejs-ex.git
  secrets:
    - secret:
        name: secret-npmrc
  type: Git
----

If you want to create a new `BuildConfig` and you want to include the secrets
in it, you can run the following command:

----
$ oc new-build openshift/nodejs-010-centos7~https://github.com/openshift/nodejs-ex.git --build-secret secret-npmrc
----

During the build in both of these examples the *_.npmrc_* will be copied into
a directory where the source code is located. In case of the OpenShift Source-To-Image
builder images, this will be the image working directory which is set using the
`WORKDIR` instruction in the *_Dockerfile_*. If you want to specify another directory,
you can add a `*destinationDir*` into the secret definition:

[source,yaml]
----
source:
  git:
    uri: https://github.com/openshift/nodejs-ex.git
  secrets:
    - secret:
        name: secret-npmrc
    destinationDir: /etc
  type: Git
----

You can also specify the destination directory when creating a new `BuildConfig`:

----
$ oc new-build openshift/nodejs-010-centos7~https://github.com/openshift/nodejs-ex.git --build-secret “secret-npmrc:/etc”
----

In both cases, the *_.npmrc_* file will be added into the *_/etc_* directory of
the build environment. Note that for a
link:../architecture/core_concepts/builds_and_image_streams.html#docker-build[Docker strategy]
the destination directory must be a relative path.

[[using-secrets-s2i-strategy]]
=== Source-to-Image Strategy

When you are using a `Source` strategy all defined source secrets will be copied
to the respective `destinationDir`. If you left `destinationDir` empty then the
secrets will be placed to the working directory of the builder image. The same
rule is used when a destination directory is a relative path - the secrets will
be placed into the paths that are relative to the image's working directory.
The `destinationDir` must exist or an error will occur. No directory paths are
created during the copy process.

Keep in mind that in the current implementation, files with the secrets are
world-writable (have `0666` permissions) and will be truncated to size zero
after execution of the *_assemble_* script. This means that the secret files will
exist in the resulting image but they will be empty for security reasons.

[[using-secrets-docker-strategy]]
=== Docker Strategy

When you are using a `Docker` strategy, you can add all defined source secrets into
your Docker image using the https://docs.docker.com/engine/reference/builder/#add[ADD]
and https://docs.docker.com/engine/reference/builder/#copy[COPY instructions]
in your *_Dockerfile_*. If you don’t specify the `destinationDir` for a secret,
then the files will be copied into the same directory in which the *_Dockerfile_*
is located. If you specify a relative path as `destinationDir`, then the secrets
will be copied into that directory, relative to your *_Dockerfile_* location.
This makes the secret files available to the Docker build operation as part of
the context directory used during the build.

Note that for security reasons, users should always remove their secrets from
the final application image. This removal should be part of the *_Dockerfile_*
itself. In that case, the secrets will not be present in the container running
from that image. However, the secrets will still exist in the image itself in
the layer where they were added.

[[using-secrets-custom-strategy]]
=== Custom Strategy

When you are using a `Custom` strategy, then all the defined source secrets will
be available inside the builder container under
*_/var/run/secrets/openshift.io/build_* directory. It is the custom build image's
responsibility to use these secrets appropriately. The `Custom` strategy also
allows secrets to be defined as described in link:#custom-secrets[Secrets]. There is
no technical difference between existing strategy secrets and the source secrets.
However, your builder image might distinguish between them and use them
differently, based on your build use case. The source secrets are always mounted
into *_/var/run/secrets/openshift.io/build_* directory or your builder can parse
the `$BUILD` environment variable which includes the full Build object serialized
into JSON format.


[[starting-a-build]]

== Starting a Build

Manually start a new build from an existing build configuration in your current
project using the following command:

----
$ oc start-build <buildconfig_name>
----

Re-run a build using the `--from-build` flag:

----
$ oc start-build --from-build=<build_name>
----

Specify the `--follow` flag to stream the build's logs in stdout:

----
$ oc start-build <buildconfig_name> --follow
----

Specify the `--env` flag to set any desired environment variable for the build:

----
$ oc start-build <buildconfig_name> --env=<key>=<value>
----

Rather than relying on a Git source pull or a Dockerfile for a build, you can
can also start a build by directly pushing your source, which could be the
contents of a Git or SVN working directory, a set of prebuilt binary artifacts
you want to deploy, or a single file. This can be done by specifying one of the
following options for the `start-build` command:

[cols="1,2",options="header"]
|===
|Option |Description

|`--from-dir=<directory>`
|Specifies a directory that will be archived and used as a binary input for the
build.

|`--from-file=<file>`
|Specifies a single file that will be the only file in the build source. The
file is placed in the root of an empty directory with the same file name as the original file provided.

|`--from-repo=<local_source_repo>`
|Specifies a path to a local repository to use as the binary input for a build.
Add the `--commit` option to control which branch, tag, or commit is used for
the build.
|===

When passing any of these options directly to the build, the contents are
streamed to the build and override the current build source settings.

[NOTE]
====
Builds triggered from binary input will not preserve the source on the server,
so rebuilds triggered by base image changes will use the source specified in the
build configuration.
====

For example, the following command sends the contents of a local Git repository
as an archive from the tag `v2` and starts a build:

====
----
$ oc start-build hello-world --from-repo=../hello-world --commit=v2
----
====

[[canceling-a-build]]

== Canceling a Build
Manually cancel a build using the web console, or with the following CLI command:

----
$ oc cancel-build <build_name>
----

[[deleting-a-buildconfig]]

== Deleting a BuildConfig
Delete a `*BuildConfig*` using the following command:

----
$ oc delete bc <BuildConfigName>
----

This will also delete all builds that were instantiated from this `*BuildConfig*`.
Specify the `--cascade=false` flag if you do not want to delete the builds:

----
$ oc delete --cascade=false bc <BuildConfigName>
----

[[viewing-build-details]]
== Viewing Build Details

You can view build details using the web console or the following CLI command:

----
$ oc describe build <build_name>
----

The output of the `describe` command includes details such as the build source,
strategy, and output destination. If the build uses the Docker or Source
strategy, it will also include information about the source revision used for
the build: commit ID, author, committer, and message.

[[accessing-build-logs]]

== Accessing Build Logs
You can access build logs using the web console or the CLI.

To stream the logs using the build directly:

----
$ oc logs -f build/<build_name>
----

To stream the logs of the latest build for a build configuration:

----
$ oc logs -f bc/<buildconfig_name>
----

To return the logs of a given version build for a build configuration:

----
$ oc logs --version=<number> bc/<buildconfig_name>
----

*Log Verbosity*

To enable more verbose output, pass the `*BUILD_LOGLEVEL*` environment variable
as part of the `*sourceStrategy*` or `*dockerStrategy*` in a `*BuildConfig*`:

====
[source,yaml]
----
sourceStrategy:
...
  env:
    -
      name: "BUILD_LOGLEVEL"
      value: "2" <1>
----

<1> Adjust this value to the desired log level.
====

NOTE: A platform administrator can set verbosity for the entire OpenShift
instance by passing the `--loglevel` option to the `openshift start` command.
If both `--loglevel` and `BUILD_LOGLEVEL` are specified, `BUILD_LOGLEVEL` takes precedence.

Available log levels for Source builds are as follows:

[horizontal]
Level 0:: Produces output from containers running the *_assemble_* script and all encountered errors. This is the default.
Level 1:: Produces basic information about the executed process.
Level 2:: Produces very detailed information about the executed process.
Level 3:: Produces very detailed information about the executed process, and a listing of the archive contents.
Level 4:: Currently produces the same information as level 3.
Level 5:: Produces everything mentioned on previous levels and additionally provides docker push messages.

[[setting-maximum-duration]]
== Setting Maximum Duration

When defining a `*BuildConfig*`, you can define its maximum duration by setting
the  `*completionDeadlineSeconds*` field. It is specified in seconds and is not
set by default. When not set, there is no maximum duration enforced.

The maximum duration is counted from the time when a build pod gets scheduled in
the system, and defines how long it can be active, including the time needed to
pull the builder image. After reaching the specified timeout, the build is
terminated by OpenShift.

The following example shows the part of a `*BuildConfig*` specifying
`*completionDeadlineSeconds*` field for 30 minutes:

====
----
spec:
  completionDeadlineSeconds: 1800
----
====


[[build-triggers]]

== Build Triggers
When defining a `*BuildConfig*`, you can define triggers to control the
circumstances in which the `*BuildConfig*` should be run. The following build
triggers are available:

* link:#webhook-triggers[Webhook]
* link:#image-change-triggers[Image change]
* link:#config-change-triggers[Configuration change]

[[webhook-triggers]]

=== Webhook Triggers
Webhook triggers allow you to trigger a new build by sending a request to the
OpenShift API endpoint. You can define these triggers using
https://developer.github.com/webhooks/[GitHub webhooks] or Generic webhooks.

*GitHub Webhooks*

https://developer.github.com/webhooks/creating/[GitHub webhooks] handle the call
made by GitHub when a repository is updated. When defining the trigger, you must
specify a `*secret*`, which will be part of the URL you supply to GitHub when
configuring the webhook. The secret ensures the uniqueness of the URL, preventing
others from triggering the build. The following example is a trigger definition
YAML within the `*BuildConfig*`:

====
[source,yaml]
----
type: "GitHub"
github:
  secret: "secret101"
----
====

[NOTE]
====
The secret field in webhook trigger configuration is not the same as `*secret*`
field you encounter when configuring webhook in GitHub UI. The former is to make
the webhook URL unique and hard to predict, the latter is an optional string field
used to create HMAC hex digest of the body, which is sent as an `X-Hub-Signature`
https://developer.github.com/webhooks/#delivery-headers[header].
====

The payload URL is returned as the GitHub Webhook URL by the `describe` command
(see link:#describe-buildconfig[below]), and is structured as follows:

----
http://<openshift_api_host:port>/oapi/v1/namespaces/<namespace>/buildconfigs/<name>/webhooks/<secret>/github
----

*Generic Webhooks*

Generic webhooks can be invoked from any system capable of making a web request.
As with a GitHub webhook, you must specify a `*secret*` which will be part of
the URL, the caller must use to trigger the build. The secret ensures the
uniqueness of the URL, preventing others from triggering the build. The
following is an example trigger definition YAML within the `*BuildConfig*`:

====
[source,yaml]
----
type: "Generic"
generic:
  secret: "secret101"
----
====

To set up the caller, supply the calling system with the URL of the generic
webhook endpoint for your build:

----
http://<openshift_api_host:port>/oapi/v1/namespaces/<namespace>/buildconfigs/<name>/webhooks/<secret>/generic
----

The endpoint can accept an optional payload with the following format:

====
[source,yaml]
----
type: "git"
git:
  uri: "<url to git repository>"
  ref: "<optional git reference>"
  commit: "<commit hash identifying a specific git commit>"
  author:
    name: "<author name>"
    email: "<author e-mail>"
  committer:
    name: "<committer name>"
    email: "<committer e-mail>"
  message: "<commit message>"
----
====

[[describe-buildconfig]]

*Displaying a BuildConfig's Webhook URLs*

Use the following command to display the webhook URLs associated with a build
configuration:

----
$ oc describe bc <name>
----

If the above command does not display any webhook URLs, then no webhook trigger
is defined for that build configuration.

[[image-change-triggers]]

=== Image Change Triggers
Image change triggers allow your build to be automatically invoked when a new
version of an upstream image is available. For example, if a build is based on
top of a RHEL image, then you can trigger that build to run any time the RHEL
image changes. As a result, the application image is always running on the
latest RHEL base image.

Configuring an image change trigger requires the following actions:

. Define an `*ImageStream*` that points to the upstream image you want to
trigger on:
+
====
[source,yaml]
----
kind: "ImageStream"
apiVersion: "v1"
metadata:
  name: "ruby-20-centos7"
----
====
+
This defines the image stream that is tied to a Docker image repository
located at `_<system-registry>_/_<namespace>_/ruby-20-centos7`. The
`_<system-registry>_` is defined as a service with the name `docker-registry`
running in OpenShift.

. If an image stream is the base image for the build, set the from field in the
build strategy to point to the image stream:
+
====
[source,yaml]
----
strategy:
  type: "Source"
  sourceStrategy:
    from:
      kind: "ImageStreamTag"
      name: "ruby-20-centos7:latest"
----
====
+
In this case, the `*sourceStrategy*` definition is consuming the `latest` tag of
the image stream named `ruby-20-centos7` located within this namespace.

. Define a build with one or more triggers that point to image streams:
+
====
[source,yaml]
----
type: "imageChange" <1>
imageChange: {}
type: "imagechange" <2>
imageChange:
  from:
    kind: "ImageStreamTag"
    name: "custom-image:latest"
----
<1> An image change trigger that monitors the `*ImageStream*` and `*Tag*` as
defined by the build strategy's `*from*` field. The `*imageChange*` object here
must be empty.
<2> An image change trigger that monitors an arbitrary image stream. The
`*imageChange*` part in this case must include a `*from*` field that references
the `*ImageStreamTag*` to monitor.
====

When using an image change trigger for the strategy image stream, the generated build
is supplied with an immutable Docker tag that points to the latest image corresponding
to that tag. This new image reference will be used by the strategy
when it executes for the build. For other image change triggers that do not
reference the strategy image stream, a new build will be started, but the build
strategy will not be updated with a unique image reference.

In the example above that has an image change trigger for the strategy, the resulting build will be:

====
[source,yaml]
----
strategy:
  type: "Source"
  sourceStrategy:
    from:
      kind: "DockerImage"
      name: "172.30.17.3:5001/mynamespace/ruby-20-centos7:immutableid"
----
====

This ensures that the triggered build uses the new image that was just pushed to
the repository, and the build can be re-run any time with the same inputs.

In addition to setting the image field for all `*Strategy*` types, for custom
builds, the `OPENSHIFT_CUSTOM_BUILD_BASE_IMAGE` environment variable is checked.
If it does not exist, then it is created with the immutable image reference. If
it does exist then it is updated with the immutable image reference.

If a build is triggered due to a webhook trigger or manual request,
the build that is created uses the `*immutableid*` resolved from the
`*ImageStream*` referenced by the `*Strategy*`. This ensures that builds
are performed using consistent image tags for ease of reproduction.

[NOTE]
====
Image streams that point to Docker images in
http://docs.docker.com/v1.7/reference/api/hub_registry_spec/#docker-registry-1-0[v1
Docker registries] only trigger a build once when the image stream tag becomes
available and not on subsequent image updates. This is due to the lack of
uniquely identifiable images in v1 Docker registries.
====

[[config-change-triggers]]
=== Configuration Change Triggers
A configuration change trigger allows a build to be automatically invoked as
soon as a new `*BuildConfig*` is created. The following is an example trigger
definition YAML within the `*BuildConfig*`:

====
[source,yaml]
----
  type: "ConfigChange"
----
====

[NOTE]
====
Configuration change triggers currently only work when creating a new
`*BuildConfig*`. In a future release, configuration change triggers will also be
able to launch a build whenever a `*BuildConfig*` is updated.
====

[[build-hooks]]

== Build Hooks

Build hooks allow behavior to be injected into the build process.

There is one hook type, post commit, that can be used to execute commands
inside a temporary container running the build output image. The hook is
executed immediately after the last layer of the image has been committed and
before the image is pushed to a registry.

The current working directory is set to the image's `*WORKDIR*`, the default
working directory of the Docker image. For most images, this is where
the source code is located.

The hook will fail if the script or command returns a non-zero exit code or if
there's any other error related to starting the temporary container. When the
hook fails it will mark the build as failed and the image will not be pushed to
a registry. The exact failure reason can be inspected by looking at the build
logs.

Build hooks can be used to run unit tests to verify the image before the build
is marked complete and the image is made available in a registry. If all tests
pass and the test runner returns exit code 0, the build will be marked
successful. Otherwise, in case of any test failure, the build will be marked as
failed. In all cases, the build log will contain the output of the test runner,
which can be used to identify failed tests.

The post commit hook is not limited to running tests but can be used for other
commands as well. Changes made by the hook will not be persisted, since it runs
in a temporary container. In other words, the hook execution cannot affect the
final image. This behavior allows for, among other uses, the installation and
usage of test dependencies that will be automatically discarded and not present
in the final image.

There are different ways to configure the post build hook. All forms in the
examples below are equivalent and will execute `*bundle exec rake test
--verbose*`:

1. Shell script:
+
[source,yaml]
----
postCommit:
  script: "bundle exec rake test --verbose"
----
In this form, `*script*` is a shell script to be run with `*/bin/sh -ic*`. Use
this when a shell script is appropriate to execute the build hook, for example
for running unit tests as above. If you need control over the image entrypoint,
or if the image does not have `*/bin/sh*`, use `*command*` and/or `*args*`.
+
NOTE: The additional `*-i*` flag was introduced to improve the experience
working with CentOS and RHEL images, and may be removed in a future release.
+
2. Command as the image entrypoint:
+
[source,yaml]
----
postCommit:
  command: ["/bin/bash", "-c", "bundle exec rake test --verbose"]
----
+
In this form, `*command*` is the command to run. It overrides the image
entrypoint in the exec form, as documented in the
link:https://docs.docker.com/engine/reference/builder/#entrypoint[Dockerfile
reference]. This might be needed if the image does not have `*/bin/sh*` or if
you do not want to use a shell. In all other cases, using `*script*` might be
more convenient.
+
3. Pass arguments to the default entrypoint:
+
[source,yaml]
----
postCommit:
  args: ["bundle", "exec", "rake", "test", "--verbose"]
----
In this form, `*args*` is a list of arguments that are provided to the default
entrypoint of the image. The image entrypoint must be able to handle arguments.
+
4. Shell script with arguments:
+
[source,yaml]
----
postCommit:
  script: "bundle exec rake test $1"
  args: ["--verbose"]
----
+
This form is useful if you need to pass arguments that would otherwise be hard
to quote properly in the shell script. In the `*script*`, `$0` will be "/bin/sh"
and `$1`, `$2`, etc, are the positional arguments from `*args*`.
+
5. Command with arguments:
+
[source,yaml]
----
postCommit:
  command: ["bundle", "exec", "rake", "test"]
  args: ["--verbose"]
----
This form is equivalent to appending the arguments to `*command*`.

NOTE: It is invalid to provide both `*script*` and `*command*` simultaneously.

[[using-docker-credentials-for-pushing-and-pulling-images]]
== Using Docker Credentials for Pushing and Pulling Images

Supply the *_.docker/config.json_* file with valid Docker Registry credentials in order to
push the output image into a private Docker Registry or pull the builder image
from the private Docker Registry that requires authentication. For the OpenShift
Docker Registry, you don't have to do this because `*secrets*` are generated
automatically for you by OpenShift.

The *_.docker/config.json_* file is found in your home directory by default and has
the following format:

====
[source,json]
----
{
  "auths": {
    "https://index.docker.io/v1/": { <1>
      "auth": "YWRfbGzhcGU6R2labnRib21ifTE=", <2>
      "email": "user@example.com" <3>
    }
  }
}
----
<1> URL of the registry.
<2> Encrypted password.
<3> Email address for the login.
====

You can define multiple Docker registry entries in this file. Alternatively, you
can also add authentication entries to this file by running the `docker login`
command. The file will be created if it does not exist. Kubernetes provides
link:../dev_guide/secrets.html[`*secret*`] objects, which are used to store your
configuration and passwords.

. Create the `*secret*` from your local *_.docker/config.json_* file:
+
====
----
$ oc secrets new dockerhub ~/.docker/config.json
----
====
+
This generates a JSON specification of the `*secret*` named *dockerhub* and
creates the object.

. Once the `*secret*` is created, add it to the builder service account. Each
build is run with `serviceaccount/builder` role, so you need to give it access
your secret with following command:

+
====
----
$ oc secrets add serviceaccount/builder secrets/dockerhub
----
====

. Add a `*pushSecret*` field into the `*output*` section of the `*BuildConfig*` and
set it to the name of the `*secret*` that you created, which in the above example
is *dockerhub*:
+
====
[source,yaml]
----
spec:
  output:
    to:
      kind: "DockerImage"
      name: "private.registry.com/org/private-image:latest"
    pushSecret:
      name: "dockerhub"
----
====

. Pull the builder Docker image from a private Docker registry by specifying the
`*pullSecret*` field, which is part of the build strategy definition:
+
====
[source,yaml]
----
strategy:
  sourceStrategy:
    from:
      kind: "DockerImage"
      name: "docker.io/user/private_repository"
    pullSecret:
      name: "dockerhub"
  type: "Source"
----
====

[NOTE]
====
This example uses `*pullSecret*` in a Source build, but it is also applicable
in Docker and Custom builds.
====

[[build-output]]
== Build Output

Docker and Source builds result in the creation of a new Docker image. The image
is then pushed to the registry specified in the `*output*` section of the
`*Build*` specification.

If the output kind is `*ImageStreamTag*`, then the image will be pushed to the
integrated OpenShift registry and tagged in the specified image stream. If the
output is of type `*DockerImage*`, then the name of the output reference will be
used as a Docker push specification. The specification may contain a registry or
will default to DockerHub if no registry is specified. If the output section of
the build specification is empty, then the image will not be pushed at the end
of the build.

.Output to an ImageStreamTag
====
[source,yaml]
----
output:
  to:
    kind: "ImageStreamTag"
    name: "sample-image:latest"
----
====

.Output to a Docker Push Specification
====
[source,yaml]
----
output:
  to:
    kind: "DockerImage"
    name: "my-registry.mycompany.com:5000/myimages/myimage:tag"
----
====

[[output-image-environment-variables]]
=== Output Image Environment Variables

Docker and Source builds set the following environment variables on output
images:

[options="header"]
|===

|Variable |Description

|`*OPENSHIFT_BUILD_NAME*`
|Name of the build

|`*OPENSHIFT_BUILD_NAMESPACE*`
|Namespace of the build

|`*OPENSHIFT_BUILD_SOURCE*`
|The source URL of the build

|`*OPENSHIFT_BUILD_REFERENCE*`
|The Git reference used in the build

|`*OPENSHIFT_BUILD_COMMIT*`
|Source commit used in the build
|===

[[output-image-labels]]
=== Output Image Labels

Docker and Source builds set the following labels on output images:

[options="header"]
|===

|Label |Description

|*io.openshift.build.commit.author*
|Author of the source commit used in the build

|*io.openshift.build.commit.date*
|Date of the source commit used in the build

|*io.openshift.build.commit.id*
|Hash of the source commit used in the build

|*io.openshift.build.commit.message*
|Message of the source commit used in the build

|*io.openshift.build.commit.ref*
|Branch or reference specified in the source

|*io.openshift.build.source-location*
|Source URL for the build
|===

[[using-external-artifacts]]
== Using External Artifacts During a Build

It is not recommended to store binary files in a source repository. Therefore,
you may find it necessary to define a build which pulls additional files (such
as Java *_.jar_* dependencies) during the build process. How this is done
depends on the build strategy you are using.

For a `*Source*` build strategy, you must put appropriate shell commands into
the *_assemble_* script:

.*_.s2i/bin/assemble_* File
====

[source,bash]
----
#!/bin/sh
APP_VERSION=1.0
wget http://repository.example.com/app/app-$APP_VERSION.jar -O app.jar
----
====

.*_.s2i/bin/run_* File
====

[source,bash]
----
#!/bin/sh
exec java -jar app.jar
----
====

[NOTE]
====
For more information on how to control which *_assemble_* and *_run_* script is
used by a Source build, see link:#override-builder-image-scripts[Overriding
Builder Image Scripts].
====

For a `*Docker*` build strategy, you must modify the *_Dockerfile_* and invoke
shell commands with the
https://docs.docker.com/engine/reference/builder/#run[`RUN` instruction]:

.Excerpt of `Dockerfile`
====

[source]
----
FROM jboss/base-jdk:8

ENV APP_VERSION 1.0
RUN wget http://repository.example.com/app/app-$APP_VERSION.jar -O app.jar

EXPOSE 8080
CMD [ "java", "-jar", "app.jar" ]
----
====

In practice, you may want to use an environment variable for the file location
so that the specific file to be downloaded can be customized using an
environment variable defined on the `BuildConfig`, rather than updating the
*_assemble_* script or *_Dockerfile_*.

You can choose between different methods of defining environment variables:

- link:#environment-files[Using the *_.s2i/environment_* file] (only for a
`*Source*` build strategy)
- link:#buildconfig-environment[Setting in `*BuildConfig*`]
- link:../cli_reference/basic_cli_operations.html#build-and-deployment-cli-operations[Providing
explicitly using `*oc start-build --env*`] (only for builds that are triggered
manually)

== Troubleshooting

[cols="1,4",options="header"]
.Troubleshooting Guidance
|===
|Issue |Resolution
|A build fails with `requested access to the resource is denied`. What does it
mean?
|You have exceeded one of the link:../dev_guide/quota.html#usage-limits[image
quotas] set on your project. Consult `oc describe quota` and see the limits
applied and storage in use.
|===
