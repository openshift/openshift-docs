[[dev-guide-custom-resource]]
= Extend the Kubernets API with Custom Resources
{product-author}
{product-version}
:data-uri:
:icons:
:experimental:
:toc: macro
:toc-title:

toc::[]



A resource is an endpoint in the Kubernetes API that stores a collection of API objects of a certain kind. 
For example, the built-in pods resource contains a collection of Pod objects.

A _custom resource_ is an extension of the Kubernetes API that extends the API or allows you to
introduce your own API into a project or a cluster.

A _custom resource definition_ (CRD) defines your own object kinds and lets the API Server handle the entire lifecycle.
Deploying a CRD into the cluster causes the Kubernetes API server to begin serving the specified custom resource on your behalf.

When you create a new custom resource definition (CRD), the Kubernetes API Server
reacts by creating a new RESTful resource path, that can be accessed by an entire cluster 
or a single project (namespace). As with existing built-in objects, deleting a
namespace deletes all custom objects in that namespace.

== Create a Custom Resource Definition

To create a CRD, open a YAML file and enter the fields in the follwing example.

.Example YAML file for a Custom Resource Definition

[source,yaml]
----
apiVersion: apiextensions.k8s.io/v1beta1 <1>
kind: CustomResourceDefinition
metadata:
  name: crontabs.stable.example.com <2>
spec:
  group: stable.example.com <3>
  version: v1 <4>
  scope: Namespaced <5>
  names: 
    plural: crontabs <6>
    singular: crontab <7>
    kind: CronTab <8>
    shortNames:
    - ct <9>
----

<1> Use the `apiextensions.k8s.io/v1beta1` API.
<2> Specify a name for the definition. This must be in the <plural-name><group> format using the values from the `group` and `plural` fields.
<3> Specify a group name for the API. An API group is a collection of Kinds that are logically related. For example, all batch objects like Job or ScheduledJob are in the batch API Group. A good practice is to use a fully-qualified-domain name of your organization.
<4> Specify a version name to be used in the URL. Each API Group can exist in multiple versions. For example: `v1alpha`, `vibeta`, `v1`.
<5> Specify whether the custom objects are available to a project (`Namespaced`) or all prjects
in the cluster (`Cluster).
<6> Specify the plural name to be used in the URL. The `plaural` field is the same as resources in the API URL.  
<7> Specify a singular name to be used as an alias on the CLI and for display.
<8> Specify the kind of objects that can be created. The type can be CamelCased singular type. Your resource manifests use this.
<9> Specify a shorter string to match your resource on the CLI

[NOTE]
====
By default, Custom Resource Definitions cluster-scoped and available to all projects.
====

After configuring the definition file, create the object:

----
oc create -f <file-name>.yaml
-----

A new RESTful API endpoint is created at:

/apis/<spec:group>/<spec:version>/<scope>/*/<names-plural>/...

For example, using the example file, the following endpoint would be created:

----
/apis/stable.example.com/v1/namespaces/*/crontabs/...
----

This endpoint URL can then be used to create and manage custom objects.
The kind of these objects will be based on the `spec.kind` field of the
Custom Resource Definition object you created.


## Create custom objects

After the custom resource definition object has been created, you can create
custom objects. 

Custom objects can contain custom fields. These fields can contain arbitrary JSON.

In the following example, the `cronSpec` and `image` custom fields are set in a
custom object of kind `CronTab`. The kind `CronTab` comes from the `spec.kind` field of the
custom resource definition object you created above.

.Example YAML file for a Custom Object

[source,yaml]
----
apiVersion: "stable.example.com/v1" <1>
kind: CronTab <2>
metadata:
  name: my-new-cron-object <3>
spec:
  cronSpec: "* * * * /5" <4>
  image: my-awesome-cron-image <5>
----

<1> Specify the spec:name/spec:version from the custom resource definition.
<2> Specify the type in the custom resource definition.
<3> Specify a name for the object.
<4>
<5>

After configuring the object file, create the object:

----
oc create -f <file-name>.yaml
----

== Manage Custom Objects

You can then manage your CronTab objects. 

For example:

----
oc get crontab

NAME                 KIND
my-new-cron-object   CronTab.v1.stable.example.com
----

Note that resource names are not case-sensitive,
and you can use either the singular or plural forms defined in the CRD,
as well as any short names.

You can also view the raw JSON data:

----
kubectl get ct -o yaml
----

You should see that it contains the custom `cronSpec` and `image` fields
from the yaml you used to create it:

----
apiVersion: v1
items:
- apiVersion: stable.example.com/v1
  kind: CronTab
  metadata:
    clusterName: ""
    creationTimestamp: 2017-05-31T12:56:35Z
    deletionGracePeriodSeconds: null
    deletionTimestamp: null
    name: my-new-cron-object
    namespace: default
    resourceVersion: "285"
    selfLink: /apis/stable.example.com/v1/namespaces/default/crontabs/my-new-cron-object
    uid: 9423255b-4600-11e7-af6a-28d2447dc82b
  spec:
    cronSpec: '* * * * /5'
    image: my-awesome-cron-image
kind: List
metadata:
  resourceVersion: ""
  selfLink: ""
----


## Finalizers

_Finalizers_ allow controllers to implement asynchronous pre-delete hooks.
Custom objects support finalizers just like built-in objects.

You can add a finalizer to a custom object like this:

[source,yaml]
----
apiVersion: "stable.example.com/v1"
kind: CronTab
metadata:
  finalizers:
  - finalizer.stable.example.com
----

The first delete request on an object with finalizers sets a value for the
`metadata.deletionTimestamp` field instead of deleting it.
This triggers controllers watching the object to execute any finalizers they handle.

Each controller then removes the finalizer from the list and issues the delete request again.
This request deletes the object only if the list of finalizers is empty,
meaning all finalizers are done.

