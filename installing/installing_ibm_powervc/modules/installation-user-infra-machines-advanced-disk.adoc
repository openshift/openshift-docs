// Module included in the following assemblies:
//
// * installing/installing_bare_metal/upi/installing-bare-metal.adoc
// * installing/installing_bare_metal/upi/installing-restricted-networks-bare-metal.adoc
// * installing/installing_bare_metal/upi/installing-bare-metal-network-customizations.adoc
// * installing/installing_with_agent_based_installer/installing-with-agent-based-installer.adoc

ifeval::["{context}" == "installing-with-agent-based-installer"]
:agent:
endif::[]
ifeval::["{context}" == "installing-restricted-networks-bare-metal"]
:restricted:
endif::[]

:_mod-docs-content-type: PROCEDURE
[id="installation-user-infra-machines-advanced-disk_{context}"]
= Disk partitioning

ifndef::agent[]
[role="_abstract"]
During {op-system-first} installation, {product-title} applies a default partition layout that automatically expands the root file system to fill available space. By understanding this default configuration, you can override partitioning settings to customize the layout for specific node architecture requirements.

During the {op-system} installation, the size of the root file system is increased to use any remaining available space on the target device.

[IMPORTANT]
====
The use of a custom partition scheme on your node might result in {product-title} not monitoring or alerting on some node partitions. For more information on monitoring host file systems when using custom partitioning, see link:https://access.redhat.com/articles/4766521[Understanding OpenShift File System Monitoring (eviction conditions)].
====

{product-title} monitors the following two filesystem identifiers:

* `nodefs`, which is the filesystem that contains `/var/lib/kubelet`.
* `imagefs`, which is the filesystem that contains `/var/lib/containers`.

For the default partition scheme, `nodefs` and `imagefs` monitor the same root filesystem, `/`.

To override the default partitioning when installing {op-system} on an {product-title} cluster node, you must create separate partitions. Consider a situation where you want to add a separate storage partition for your containers and container images. For example, by mounting `/var/lib/containers` in a separate partition, the kubelet separately monitors `/var/lib/containers` as the `imagefs` directory and the root file system as the `nodefs` directory.

[IMPORTANT]
====
If you have resized your disk size to host a larger file system, consider creating a separate `/var/lib/containers` partition. Consider resizing a disk that has an `xfs` format to reduce CPU time issues caused by a high number of allocation groups.
====
endif::agent[]
ifdef::agent[]
[role="_abstract"]
To accommodate directories expected to grow, create separate partitions during the {op-system} installation. This configuration overrides the default partitioning layout, ensuring specific storage requirements are met for dynamic data.
endif::agent[]

{product-title} supports the addition of a single partition to attach storage to either the `/var` directory or a subdirectory of `/var`. For example:

* `/var/lib/containers`: Holds container-related content that can grow
as more images and containers are added to a system.
* `/var/lib/etcd`: Holds data that you might want to keep separate for purposes such as performance optimization of etcd storage.
* `/var`: Holds data that you might want to keep separate for purposes such as auditing.
+
[IMPORTANT]
====
For disk sizes larger than 100GB, and especially larger than 1TB, create a separate `/var` partition.
====

Storing the contents of a `/var` directory separately makes it easier to grow storage for those areas as needed and reinstall {product-title} at a later date to keep that data intact. This method eliminates the need to re-pull containers or copy large log files during system updates.

The use of a separate partition for the `/var` directory or a subdirectory of `/var` also prevents data growth in the partitioned directory from filling up the root file system.

The following procedure sets up a separate `/var` partition by adding a machine config manifest that is wrapped into the Ignition config file for a node type during the preparation phase of an installation.

ifdef::agent[]
.Prerequisites
* You have created an `openshift` subdirectory within your installation directory.
endif::agent[]

.Procedure

ifndef::agent[]
. On your installation host, change to the directory that contains the {product-title} installation program and generate the Kubernetes manifests for the cluster:
+
[source,terminal]
----
$ openshift-install create manifests --dir <installation_directory>
----
endif::agent[]

. Create a Butane config that configures the additional partition. For example, name the file `$HOME/clusterconfig/98-var-partition.bu`, change the disk device name to the name of the storage device on the `worker` systems, and set the storage size as appropriate. This example places the `/var` directory on a separate partition:
+
[source,yaml,subs="attributes+"]
----
variant: openshift
version: {product-version}.0
metadata:
  labels:
    machineconfiguration.openshift.io/role: worker
  name: 98-var-partition
storage:
  disks:
  - device: /dev/disk/by-id/<device_name>
    partitions:
    - label: var
      start_mib: <partition_start_offset>
      size_mib: <partition_size>
      number: 5
  filesystems:
    - device: /dev/disk/by-partlabel/var
      path: /var
      format: xfs
      mount_options: [defaults, prjquota]
      with_mount_unit: true
----
+
where:
+
`<device_name>`:: Specifies the storage device name of the disk that you want to partition.
`<partition_start_offset>`:: Specifies the minimum offset value for the boot disk. For best performance, specify a minimum offset value of 25000 mebibytes. The root file system is automatically resized to fill all available space up to the specified offset. If no offset value is specified, or if the specified value is smaller than the recommended minimum, the resulting root file system will be too small, and future reinstalls of {op-system} might overwrite the beginning of the data partition.
`<partition_size>`:: Specifies the size of the data partition in mebibytes.
`mount_options`:: The `prjquota` mount option must be enabled for filesystems used for container storage.
+
[NOTE]
====
When creating a separate `/var` partition, you cannot use different instance types for compute nodes, if the different instance types do not have the same device name.
====

. Create a manifest from the Butane config and save it to the `clusterconfig/openshift` directory. For example, run the following command:
+
[source,terminal]
----
$ butane $HOME/clusterconfig/98-var-partition.bu -o $HOME/clusterconfig/openshift/98-var-partition.yaml
----

ifndef::agent[]
. Create the Ignition config files by running the following command:
+
[source,terminal]
----
$ openshift-install create ignition-configs --dir <installation_directory>
----
+
where:
+
`<installation_directory>`:: Specifies the name of the installation directory.
+
Ignition config files are created for the bootstrap, control plane, and compute nodes in the installation directory:
+
----
.
├── auth
│   ├── kubeadmin-password
│   └── kubeconfig
├── bootstrap.ign
├── master.ign
├── metadata.json
└── worker.ign
----
+
The files in the `<installation_directory>/manifest` and `<installation_directory>/openshift` directories are wrapped into the Ignition config files, including the file that contains the `98-var-partition` custom `MachineConfig` object.

. Optional: You can apply the custom disk partitioning by referencing the Ignition config files during the {op-system} installations.
endif::agent[]

ifeval::["{context}" == "installing-with-agent-based-installer"]
:!agent:
endif::[]
ifeval::["{context}" == "installing-restricted-networks-bare-metal"]
:!restricted:
endif::[]