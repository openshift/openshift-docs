[[admin-guide-backup-and-restore]]
= Backup and Restore
{product-author}
{product-version}
:data-uri:
:icons: font
:experimental:
:toc: macro
:toc-title:
:prewrap!:

toc::[]

== Overview

In {product-title}, you can _back up_ (saving state to separate storage) and
_restore_ (recreating state from separate storage) at the cluster level. There
is also some preliminary support for xref:project-backup[per-project backup].
The full state of a cluster installation includes:

- etcd data on each master
- API objects
- registry storage
- volume storage

This topic does not cover how to back up and restore
xref:../install_config/persistent_storage/index.adoc#install-config-persistent-storage-index[persistent
storage], as those topics are left to the underlying storage provider. However,
an example of how to perform a *generic* backup of
xref:backup-application-data[application data] is provided.

[IMPORTANT]
====
This topic only provides a generic way of backing up applications and the
{product-title} cluster. It can not take into account custom requirements.
Therefore, you should create a full backup and restore procedure. To prevent
data loss, necessary precautions should be taken.
====

[[backup-restore-prerequisites]]
== Prerequisites

. Because the restore procedure involves a complete
reinstallation, save all the files used in the initial installation. This may
include:
+
- *_~/.config/openshift/installer.cfg.yml_* (from the
xref:../install_config/install/quick_install.adoc#install-config-install-quick-install[Quick Installation]
method)
- Ansible playbooks and inventory files (from the
xref:../install_config/install/advanced_install.adoc#install-config-install-advanced-install[Advanced
Installation] method)
- *_/etc/yum.repos.d/ose.repo_* (from the
xref:../install_config/install/disconnected_install.adoc#install-config-install-disconnected-install[Disconnected
Installation] method)

. Backup the procedures for post-installation steps. Some installations may
involve steps that are not included in the installer. This may include changes
to the services outside of the control of {product-title} or the installation of
extra services like monitoring agents.
Additional configuration that is not supported yet by the advanced installer
might also be affected, for example when using multiple authentication providers.

. Install packages that provide various utility commands:
+
----
# yum install etcd
----
. If using a container-based installation, pull the etcd image instead:
+
----
# docker pull rhel7/etcd
----

Note the location of the *etcd* data directory (or `$ETCD_DATA_DIR` in the
following sections), which depends on how *etcd* is deployed.

[options="header",cols="1,2"]
|===
| Deployment Type| Data Directory

|all-in-one cluster
|*_/var/lib/origin/openshift.local.etcd_*

|external etcd (not on master)
|*_/var/lib/etcd_*

|embedded etcd (on master)
|*_/var/lib/etcd_*
|===


[[cluster-backup]]
== Cluster Backup

. Save all the certificates and keys, on each master:
+
----
# cd /etc/origin/master
# tar cf /tmp/certs-and-keys-$(hostname).tar *.key *.crt
----

. If *etcd* is running on more than one host, stop it on each host:
+
----
# sudo systemctl stop etcd
----
+
Although this step is not strictly necessary, doing so ensures that the *etcd*
data is fully synchronized.

. Create an *etcd* backup:
+
----
# etcdctl backup \
    --data-dir $ETCD_DATA_DIR \
    --backup-dir $ETCD_DATA_DIR.bak
----
+
[NOTE]
====
If *etcd* is running on more than one host,
the various instances regularly synchronize their data,
so creating a backup for one of them is sufficient.
====
+
[NOTE]
====
For a container-based installation, you must use `docker exec` to run *etcdctl*
inside the container.
====

. Copy the *_db_* file over to the backup you created:
+
----
$ cp "$ETCD_DATA_DIR"/member/snap/db "$HOTDIR"/member/snap/db'
----

[[cluster-restore-single-member-etcd-clusters]]
== Cluster Restore for Single-member etcd Clusters

To restore the cluster:

. Reinstall {product-title}.
+
This should be done in the
xref:../install_config/install/planning.adoc#installation-methods[same way] that
{product-title} was previously installed.

. Run all necessary post-installation steps.
+
. Restore the certificates and keys, on each master:
+
----
# cd /etc/origin/master
# tar xvf /tmp/certs-and-keys-$(hostname).tar
----

. Restore from the *etcd* backup:
+
----
# mv $ETCD_DATA_DIR $ETCD_DATA_DIR.orig
# cp -Rp $ETCD_DATA_DIR.bak $ETCD_DATA_DIR
# chcon -R --reference $ETCD_DATA_DIR.orig $ETCD_DATA_DIR
# chown -R etcd:etcd $ETCD_DATA_DIR
----

. Create the new single node cluster using etcd's `--force-new-cluster` option.
You can do this using the values from *_/etc/etcd/etcd.conf_*, or you can
temporarily modify the *systemd* unit file and start the service normally.
+
To do so, edit the *_/usr/lib/systemd/system/etcd.service_* file, and add
`--force-new-cluster`:
+
----
# sed -i '/ExecStart/s/"$/  --force-new-cluster"/' /usr/lib/systemd/system/etcd.service
# cat /usr/lib/systemd/system/etcd.service  | grep ExecStart

ExecStart=/bin/bash -c "GOMAXPROCS=$(nproc) /usr/bin/etcd --force-new-cluster"
----
+
Then, restart the *etcd* service:
+
----
# systemctl daemon-reload
# systemctl start etcd
----

. Verify the *etcd* service started correctly, then re-edit the
*_/usr/lib/systemd/system/etcd.service_* file and remove the
`--force-new-cluster` option:
+
----
# sed -i '/ExecStart/s/ --force-new-cluster//' /usr/lib/systemd/system/etcd.service
# cat /usr/lib/systemd/system/etcd.service  | grep ExecStart

ExecStart=/bin/bash -c "GOMAXPROCS=$(nproc) /usr/bin/etcd"
----

. Restart the *etcd* service, then verify the etcd cluster is running correctly
and displays {product-title}'s configuration:
+
----
# systemctl daemon-reload
# systemctl restart etcd
----

[[cluster-restore-multiple-member-etcd-clusters]]
== Cluster Restore for Multiple-member etcd Clusters

When using an external etcd host, you must first restore the etcd backup
by creating a new, single node etcd cluster. If using external etcd with
multiple members, you must then also add any additional etcd members to the
cluster one by one.

However, the details of the restoration process differ between
xref:restoring-embedded-etcd[embedded] and
xref:restoring-external-etcd[external] etcd. See the following
section and follow the relevant steps
before
xref:bringing-openshift-services-back-online[Bringing OpenShift
Services Back Online].

[[restoring-embedded-etcd]]
=== Embedded etcd

Restore your etcd backup and configuration:

. Run the following on the master with the embedded etcd:
+
----
# ETCD_DIR=/var/lib/origin/openshift.local.etcd
# mv $ETCD_DIR /var/lib/etcd.orig
# cp -Rp /var/lib/origin/etcd-backup-<timestamp>/ $ETCD_DIR
# chcon -R --reference /var/lib/etcd.orig/ $ETCD_DIR
# chown -R etcd:etcd $ETCD_DIR
----
+
[WARNING]
====
The `$ETCD_DIR` location differs between external and embedded etcd.
====

. Create the new, single node etcd cluster:
+
----
# etcd -data-dir=/var/lib/origin/openshift.local.etcd \
    -force-new-cluster
----
+
Verify etcd has started successfully by checking the output from the above
command, which should look similar to the following near the end:
+
----
[...]
2016-06-24 12:14:45.644073 I | etcdserver: starting server... [version: 2.2.5, cluster version: 2.2]
[...]
2016-06-24 12:14:46.834394 I | etcdserver: published {Name:default ClientURLs:[http://localhost:2379 http://localhost:4001]} to cluster 5580663a6e0002
----

. Shut down the process by running the following from a separate terminal:
+
----
# pkill etcd
----

. Continue to xref:bringing-openshift-services-back-online[Bringing
{product-title} Services Back Online].

[[restoring-external-etcd]]
=== External etcd

Choose a system to be the initial etcd member, and restore its etcd backup and
configuration:

. Run the following on the etcd host:
+
----
# ETCD_DIR=/var/lib/etcd/
# mv $ETCD_DIR /var/lib/etcd.orig
# cp -Rp /var/lib/origin/etcd-backup-<timestamp>/ $ETCD_DIR
# chcon -R --reference /var/lib/etcd.orig/ $ETCD_DIR
# chown -R etcd:etcd $ETCD_DIR
----
+
[WARNING]
====
The `$ETCD_DIR` location differs between external and embedded etcd.
====

. Restore your *_/etc/etcd/etcd.conf_* file from backup or *_.rpmsave_*.

. Create the new single node cluster using etcd's `--force-new-cluster`
option. You can do this with a long complex command using the values from
*_/etc/etcd/etcd.conf_*, or you can temporarily modify the *systemd* unit file
and start the service normally.
+
To do so, edit the *_/usr/lib/systemd/system/etcd.service_* file, and add
`--force-new-cluster`:
+
----
# sed -i '/ExecStart/s/"$/  --force-new-cluster"/' /usr/lib/systemd/system/etcd.service
# cat /usr/lib/systemd/system/etcd.service  | grep ExecStart

ExecStart=/bin/bash -c "GOMAXPROCS=$(nproc) /usr/bin/etcd --force-new-cluster"
----
+
Then restart the *etcd* service:
+
----
# systemctl daemon-reload
# systemctl start etcd
----

. Verify the *etcd* service started correctly, then re-edit the
*_/usr/lib/systemd/system/etcd.service_* file and remove the
`--force-new-cluster` option:
+
----
# sed -i '/ExecStart/s/ --force-new-cluster//' /usr/lib/systemd/system/etcd.service
# cat /usr/lib/systemd/system/etcd.service  | grep ExecStart

ExecStart=/bin/bash -c "GOMAXPROCS=$(nproc) /usr/bin/etcd"
----

. Restart the *etcd* service, then verify the etcd cluster is running correctly
and displays {product-title}'s configuration:
+
----
# systemctl daemon-reload
# systemctl restart etcd
# etcdctl --cert-file=/etc/etcd/peer.crt \
    --key-file=/etc/etcd/peer.key \
    --ca-file=/etc/etcd/ca.crt \
    --peers="https://172.16.4.18:2379,https://172.16.4.27:2379" \
    ls /
----

. If you have additional etcd members to add to your cluster, continue to
xref:adding-addtl-etcd-members[Adding Additional etcd Members].
Otherwise, if you only want a single node external etcd, continue to
xref:bringing-openshift-services-back-online[Bringing {product-title}
Services Back Online].

[[adding-addtl-etcd-members]]
==== Adding Additional etcd Members

To add additional etcd members to the cluster, you must first adjust the default
*localhost* peer in the `*peerURLs*` value for the first member:

. Get the member ID for the first member using the `member list` command:
+
----
# etcdctl --cert-file=/etc/etcd/peer.crt \
    --key-file=/etc/etcd/peer.key \
    --ca-file=/etc/etcd/ca.crt \
    --peers="https://172.18.1.18:2379,https://172.18.9.202:2379,https://172.18.0.75:2379" \
    member list
----

. Update the value of `*peerURLs*` using the `etcdctl member update` command by
passing the member ID obtained from the previous step:
+
----
# etcdctl --cert-file=/etc/etcd/peer.crt \
    --key-file=/etc/etcd/peer.key \
    --ca-file=/etc/etcd/ca.crt \
    --peers="https://172.18.1.18:2379,https://172.18.9.202:2379,https://172.18.0.75:2379" \
    member update 511b7fb6cc0001 https://172.18.1.18:2380
----
+
Alternatively, you can use `curl`:
+
----
# curl --cacert /etc/etcd/ca.crt \
    --cert /etc/etcd/peer.crt \
    --key /etc/etcd/peer.key \
    https://172.18.1.18:2379/v2/members/511b7fb6cc0001 \
    -XPUT -H "Content-Type: application/json" \
    -d '{"peerURLs":["https://172.18.1.18:2380"]}'
----

. Re-run the `member list` command and ensure the peer URLs no longer include
*localhost*.

. Now, add each additional member to the cluster one at a time.
+
[WARNING]
====
Each member must be fully added and brought online one at a time. When adding
each additional member to the cluster, the `*peerURLs*` list must be correct for
that point in time, so it will grow by one for each member added. The `etcdctl
member add` command will output the values that need to be set in the
*_etcd.conf_* file as you add each member, as described in the following
instructions.
====

.. For each member, add it to the cluster using the values that can be found in
that system's *_etcd.conf_* file:
+
----
# etcdctl --cert-file=/etc/etcd/peer.crt \
    --key-file=/etc/etcd/peer.key \
    --ca-file=/etc/etcd/ca.crt \
    --peers="https://172.16.4.18:2379,https://172.16.4.27:2379" \
    member add 10.3.9.222 https://172.16.4.27:2380

Added member named 10.3.9.222 with ID 4e1db163a21d7651 to cluster

ETCD_NAME="10.3.9.222"
ETCD_INITIAL_CLUSTER="10.3.9.221=https://172.16.4.18:2380,10.3.9.222=https://172.16.4.27:2380"
ETCD_INITIAL_CLUSTER_STATE="existing"
----

.. Using the environment variables provided in the output of the above `etcdctl
member add` command, edit the *_/etc/etcd/etcd.conf_* file on the member system
itself and ensure these settings match.

.. Now start etcd on the new member:
+
----
# rm -rf /var/lib/etcd/member
# systemctl enable etcd
# systemctl start etcd
----

.. Ensure the service starts correctly and the etcd cluster is now healthy:
+
----
# etcdctl --cert-file=/etc/etcd/peer.crt \
    --key-file=/etc/etcd/peer.key \
    --ca-file=/etc/etcd/ca.crt \
    --peers="https://172.16.4.18:2379,https://172.16.4.27:2379" \
    member list

51251b34b80001: name=10.3.9.221 peerURLs=https://172.16.4.18:2380 clientURLs=https://172.16.4.18:2379
d266df286a41a8a4: name=10.3.9.222 peerURLs=https://172.16.4.27:2380 clientURLs=https://172.16.4.27:2379

# etcdctl --cert-file=/etc/etcd/peer.crt \
    --key-file=/etc/etcd/peer.key \
    --ca-file=/etc/etcd/ca.crt \
    --peers="https://172.16.4.18:2379,https://172.16.4.27:2379" \
    cluster-health

cluster is healthy
member 51251b34b80001 is healthy
member d266df286a41a8a4 is healthy
----

.. Now repeat this process for the next member to add to the cluster.

. After all additional etcd members have been added, continue to
xref:bringing-openshift-services-back-online[Bringing {product-title}
Services Back Online].

////
[[backup-restore-adding-etcd-hosts]]
== Adding New etcd Hosts

In cases where etcd hosts have failed, but you have at least one host still
running, you can use the one surviving host to recover etcd hosts without
downtime.

*Suggested Cluster Size*

Having a cluster with an odd number of etcd hosts can account for fault
tolerance. Having an odd number of etcd hosts does not change the number needed
for majority, but increases the tolerance for failure. For example, a cluster
size of seven hosts has a majority of four, leaving a failure tolerance of
three. This ensures that four hosts will be guaranteed to operate.

Having an in-production cluster of seven etcd hosts is recommended.

[NOTE]
====
The following presumes you have a backup of the */etc/etcd* configuration for
the etcd hosts.
====

. xref:../install_config/adding_hosts_to_existing_cluster.adoc#install-config-adding-hosts-to-cluster[Add
the desired number of hosts to the cluster]. The rest of this procedure presumes
you have added just one host, but if adding multiple, perform all steps on each
host.

. Upgrade etcd on the surviving node:
+
----
# yum install etcd iptables-services
----
+
Ensure version `etcd-2.3.7-4.el7.x86_64` or greater is installed, and that the
same version is installed on each host.

. On the new host, add the appropriate iptables rules:
+
----
# systemctl enable iptables.service --now
# iptables -N OS_FIREWALL_ALLOW
# iptables -t filter -I INPUT -j OS_FIREWALL_ALLOW
# iptables -A OS_FIREWALL_ALLOW -p tcp -m state \
  --state NEW -m tcp --dport 2379 -j ACCEPT
# iptables -A OS_FIREWALL_ALLOW -p tcp -m state \
  --state NEW -m tcp --dport 2380 -j ACCEPT
# iptables-save
----

. Generate the required certificates for the new host. On a surviving etcd host:
+
.. Create a copy of the *_/etc/etcd/ca/_* directory.

.. Set the variables and working directory for the certificates, ensuring to create the *_PREFIX_* directory if one has not been created:
+
----
# cd /etc/etcd
# export NEW_ETCD="<NEW_HOST_NAME>"

# export CN=$NEW_ETCD
# export SAN="IP:<NEW_HOST_IP>"
# export PREFIX="./generated_certs/etcd-$CN/"
----

.. Create the $PREFIX directory:
+
----
$ mkdir $PREFIX
----

.. Create the *_server.csr_* and *_server.crt_* certificates:
+
----
# openssl req -new -keyout ${PREFIX}server.key \
  -config ca/openssl.cnf \
  -out ${PREFIX}server.csr \
  -reqexts etcd_v3_req -batch -nodes \
  -subj /CN=$CN

# openssl ca -name etcd_ca -config ca/openssl.cnf \
  -out ${PREFIX}server.crt \
  -in ${PREFIX}server.csr \
  -extensions etcd_v3_ca_server -batch
----

.. Create the *_peer.csr_* and *_peer.crt_* certificates:
+
----
# openssl req -new -keyout ${PREFIX}peer.key \
  -config ca/openssl.cnf \
  -out ${PREFIX}peer.csr \
  -reqexts etcd_v3_req -batch -nodes \
  -subj /CN=$CN

# openssl ca -name etcd_ca -config ca/openssl.cnf \
  -out ${PREFIX}peer.crt \
  -in ${PREFIX}peer.csr \
  -extensions etcd_v3_ca_peer -batch
----

.. Copy the *_etcd.conf_* file, and archive the contents of the directory:
+
----
# cp etcd.conf ${PREFIX}
# tar -czvf ${PREFIX}${CN}.tgz -C ${PREFIX} .
----

.. Transfer the files to the new etcd hosts:
+
----
# scp ${PREFIX}${CN}.tgz  $CN:/etc/etcd/
----

. While still on the surviving etcd host, add the new host to the cluster, take the copy of etcd, and transfer it to the new host:

.. Add the new host to the cluster:
+
----
# export ETCD_CA_HOST="<SURVIVING_ETCD_HOSTNAME>"
# export NEW_ETCD="<NEW_ETCD_HOSTNAME>"
# export NEW_ETCD_IP="<NEW_HOST_IP>"

# etcdctl -C https://${ETCD_CA_HOST}:2379 \
  --ca-file=/etc/etcd/ca.crt     \
  --cert-file=/etc/etcd/peer.crt     \
  --key-file=/etc/etcd/peer.key member add ${NEW_ETCD} https://${NEW_ETCD_IP}:2380

ETCD_NAME="<NEW_ETCD_HOSTNAME>"
ETCD_INITIAL_CLUSTER="<NEW_ETCD_HOSTNAME>=https://<NEW_HOST_IP>:2380,<SURVIVING_ETCD_HOST>=https:/<SURVIVING_HOST_IP>:2380
ETCD_INITIAL_CLUSTER_STATE="existing"
----

.. Create a backup of the surviving etcd host, and transfer the contents to the new
host:
+
[NOTE]
====
Skip this step if version is lower than `etcd-2.3.7-4` or if etcd database size
is smaller than 700 MB.

If the etcd backup is larger than 700 MB,
xref:../admin_guide/pruning_resources.adoc#admin-guide-pruning-resources[prune
the resource], or clear time to live (TTL) data, such as events. If the backup
is still larger than 700 MB, stop the other hosts before performing this step.
====
+
[WARNING]
====
If you must skip this step, do not use a backup of *_/var/lib/etcd_*. Also, if
you reuse a node, *_/var/lib/etcd_* must first be purged of old data. Otherwise,
etcd will also indicate that the `cluster-id` does not match.
====
+
----
# export NODE_ID="<NEW_NODE_ID>"
# etcdctl backup --keep-cluster-id --node-id ${NODE_ID} \
  --data-dir /var/lib/etcd --backup-dir /var/lib/etcd/$NEW_ETCD-backup
# tar -cvf $NEW_ETCD-backup.tar.gz -C /var/lib/etcd/$NEW_ETCD-backup/ .
# scp $NEW_ETCD-backup.tar.gz $NEW_ETCD:/var/lib/etcd/
----
+
On the new host, extract the backup data and set the permissions:
+
----
# tar -xf /etc/etcd/<NEW_ETCD_HOSTNAME> -C /etc/etcd/ --overwrite
# chown etcd:etcd /etc/etcd/*

# rm -rf /var/lib/etcd/member
# tar -xf /var/lib/etcd/<NEW_ETCD_HOSTNAME>-backup.tar.gz -C /var/lib/etcd/
# chown -R etcd:etcd /var/lib/etcd/
----
+
Ensure that you save the *_db_* file.

. On the new etcd host's *_etcd.conf_* file:
.. Replace the following with the values generated in the previous step:
+
* ETCD_NAME
* ETCD_INITIAL_CLUSTER
* ETCD_INITIAL_CLUSTER_STATE
+
Replace the IP address with the "NEW_ETCD" value for:
+
* ETCD_LISTEN_PEER_URLS
* ETCD_LISTEN_CLIENT_URLS
* ETCD_INITIAL_ADVERTISE_PEER_URLS
* ETCD_ADVERTISE_CLIENT_URLS
+
For replacing failed hosts, you will need to remove the failed hosts from the
etcd configuration.

. Start etcd on the new host:
+
----
# systemctl enable etcd --now
----

. To verify that the new host has been added successfully:
+
----
etcdctl -C https://${ETCD_CA_HOST}:2379 --ca-file=/etc/etcd/ca.crt \
  --cert-file=/etc/etcd/peer.crt     \
  --key-file=/etc/etcd/peer.key cluster-health
----
////

[[bringing-openshift-services-back-online]]
== Bringing {product-title} Services Back Online

On each {product-title} master, restore your master and node configuration from
backup and enable and restart all relevant services.

On the master in a single master cluster:

----
# cp /etc/sysconfig/atomic-openshift-master.rpmsave /etc/sysconfig/atomic-openshift-master
# cp /etc/origin/master/master-config.yaml.<timestamp> /etc/origin/master/master-config.yaml
# cp /etc/origin/node/node-config.yaml.<timestamp> /etc/origin/node/node-config.yaml
# systemctl enable atomic-openshift-master
# systemctl enable atomic-openshift-node
# systemctl start atomic-openshift-master
# systemctl start atomic-openshift-node
----

On each master in a multi-master cluster:

----
# cp /etc/sysconfig/atomic-openshift-master-api.rpmsave /etc/sysconfig/atomic-openshift-master-api
# cp /etc/sysconfig/atomic-openshift-master-controllers.rpmsave /etc/sysconfig/atomic-openshift-master-controllers
# cp /etc/origin/master/master-config.yaml.<timestamp> /etc/origin/master/master-config.yaml
# cp /etc/origin/node/node-config.yaml.<timestamp> /etc/origin/node/node-config.yaml
# systemctl enable atomic-openshift-master-api
# systemctl enable atomic-openshift-master-controllers
# systemctl enable atomic-openshift-node
# systemctl start atomic-openshift-master-api
# systemctl start atomic-openshift-master-controllers
# systemctl start atomic-openshift-node
----

On each {product-title} node, restore your *_node-config.yaml_* file from backup
and enable and restart the *atomic-openshift-node* service:

----
# cp /etc/origin/node/node-config.yaml.<timestamp> /etc/origin/node/node-config.yaml
# systemctl enable atomic-openshift-node
# systemctl start atomic-openshift-node
----

Your {product-title} cluster should now be back online.

[[project-backup]]
== Project Backup

A future release of {product-title} will feature specific support for
per-project back up and restore.

For now, to back up API objects at the project level, use `oc export` for each
object to be saved. For example, to save the deployment configuration `frontend`
in YAML format:

----
$ oc export dc frontend -o yaml > dc-frontend.yaml
----

To back up all of the project (with the exception of cluster objects like
namespaces and projects):

----
$ oc export all -o yaml > project.yaml
----

[[backup-rolebindings]]
=== Role Bindings

Sometimes custom policy
xref:../admin_guide/manage_authorization_policy.adoc#managing-role-bindings[role
bindings] are used in a project. For example, a project administrator can give
another user a certain role in the project and grant that user project access.

These role bindings can be exported:

----
$ oc get rolebindings -o yaml --export=true > rolebindings.yaml
----

[[backup-serviceaccounts]]
=== Service Accounts

If custom service accounts are created in a project, these need to be exported:

----
$ oc get serviceaccount -o yaml --export=true > serviceaccount.yaml
----

[[backup-secrets]]
=== Secrets

Custom secrets like source control management secrets (SSH Public Keys,
Username/Password) should be exported if they are used:

----
$ oc get secret -o yaml --export=true > secret.yaml
----

[[backup-pvc]]
=== Persistent Volume Claims

If the an application within a project uses a persistent volume through a
persistent volume claim (PVC), these should be backed up:

----
$ oc get pvc -o yaml --export=true > pvc.yaml
----


[[project-restore]]
== Project Restore

To restore a project, recreate the project and recreate all all of the objects
that were exported during the backup:

----
$ oc new-project myproject
$ oc create -f project.yaml
$ oc create -f secret.yaml
$ oc create -f serviceaccount.yaml
$ oc create -f pvc.yaml
$ oc create -f rolebindings.yaml
----

[NOTE]
====
Some resources can fail to be created (for example, pods and default service
accounts).
====

[[backup-application-data]]
== Application Data Backup
In many cases, application data can be backed up using the `oc rsync` command,
assuming `rsync` is installed within the container image. The Red Hat *rhel7*
base image does contain `rsync`. Therefore, all images that are based on *rhel7*
contain it as well.

[WARNING]
====
This is a _generic_ backup of application data and does not take into account
application-specific backup procedures, for example special export/import
procedures for database systems.
====

Other means of backup may exist depending on the type of the persistent volume
(for example, Cinder, NFS, Gluster, or others).

The paths to back up are also _application specific_. You can determine
what path to back up by looking at the `*mountPath*` for volumes in the
`*deploymentconfig*`.

.Example of Backing up a Jenkins Deployment's Application Data

. Get the application data `*mountPath*` from the `*deploymentconfig*`:
+
----
$ oc export dc/jenkins|grep mountPath
        - mountPath: /var/lib/jenkins
----

. Get the name of the pod that is currently running:
+
----
$ oc get po --selector=deploymentconfig=jenkins
NAME              READY     STATUS    RESTARTS   AGE
jenkins-1-a3347   1/1       Running   0          18h
----

. Use the `oc rsync` command to copy application data:
+
----
$ oc rsync jenkins-1-37nux:/var/lib/jenkins /tmp/
----

[NOTE]
====
This type of application data backup can only be performed while an application
pod is currently running.
====


[[restore-application-data]]
== Application Data Restore

The process for restoring application data is similar to the
xref:backup-application-data[application backup procedure] using the `oc rsync`
tool. The same restrictions apply and the process of restoring application data
requires a persistent volume.

.Example of Restoring a Jenkins Deployment's Application Data

. Verify the backup:
+
----
$ ls -la /tmp/jenkins-backup/
total 8
drwxrwxr-x.  3 user     user   20 Sep  6 11:14 .
drwxrwxrwt. 17 root     root 4096 Sep  6 11:16 ..
drwxrwsrwx. 12 user     user 4096 Sep  6 11:14 jenkins
----

. Use the `oc rsync` tool to copy the data into the running pod:
+
----
$ oc rsync /tmp/jenkins-backup/jenkins jenkins-1-37nux:/var/lib
----
+
[NOTE]
====
Depending on the application, you may be required to restart the application.
====

. Restart the application with new data (_optional_):
+
----
$ oc delete po jenkins-1-37nux
----
+
Alternatively, you can scale down the deployment to 0, and then up again:
+
----
$ oc scale --replicas=0 dc/jenkins
$ oc scale --replicas=1 dc/jenkins
----
