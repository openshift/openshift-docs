////
About statefulsets

Module included in the following assemblies:

////

[id='about-stateful-sets']
= About Statefulsets

A StatefulSet is an admission controller that allows for the deployment of application types that require
changes to their configuration or deployment count (instances) to be done in a specific and ordered manner.

Unlike a deployment, a StatefulSet maintains a sticky identity for each associated pods. These pods are created from the same spec, 
but are not interchangeable. Each pod has a persistent identifier that it maintains across any rescheduling.

A StatefulSet operates under the same pattern as any other Controller. You define your desired state in a StatefulSet object, 
and the StatefulSet controller makes any necessary updates to get there from the current state.

StatefulSets are intended to be used with stateful applications and distributed systems. 

StatefulSets are valuable for applications that require one or more of the following.

* Stable unique network identifiers.

* Stable persistent storage.

* Ordered graceful deployment and scaling.

* Ordered graceful deletion and termination.

* Ordered automated rolling updates.

Stable is synonymous with persistence across Pod scheduling. If an application does not require a stable identifier 
or ordered deployment, deletion, or scaling, you should deploy your application with a controller that provides a set of stateless replicas. 
Controllers such as Deployment or ReplicaSet may be better suited to your stateless needs.

The storage for a given Pod must either be provisioned by a PersistentVolume provisioner based on the requested storage class, or pre-provisioned by an admin.
Deleting or scaling a StatefulSet down does delete the volumes associated with the StatefulSet. 
StatefulSets currently require you to create a Headless Service to be responsible for the network identity of the Pods.

The example below demonstrates the components of a StatefulSet.

* A Headless service, named *ruby-helloworld*.

* The StatefulSet, named *ruby-helloworld*, has a `spec` that .
    The volumeClaimTemplates will provide stable storage using PersistentVolumes provisioned by a PersistentVolume Provisioner.

.Sample headless service to use with a StatefulSet
apiVersion: v1
kind: Service
metadata:
  name: frontend-headless  <1>
  labels:
    app: ruby-helloworld-sample
spec:
  ports:
  - port: 80
    name: web
  clusterIP: None  <2>
  selector:
    app: ruby-helloworld-sample
---

<1> Name of the headless service.
<2> Setting `clusterIP` variable to `None` declares a headless service.
<3> Selects all pods that use the specified application.

//tag::statefulset-sample[]
.Sample StatefulSet

----
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: web
spec:
  selector:
    matchLabels:
      app: ruby-helloworld-sample <1>
  serviceName: "ruby-helloworld"
  replicas: 3 <2>
  template:
    metadata:
      labels:
        app: ruby-helloworld <3>
    spec:
      terminationGracePeriodSeconds: 10
      containers:
      - name: nginx
        image: k8s.gcr.io/nginx-slim:0.8
        ports:
        - containerPort: 80
          name: ruby-helloworld
        volumeMounts:
        - name: www
          mountPath: /usr/share/nginx/html
  volumeClaimTemplates:
  - metadata:
      name: www
    spec:
      accessModes: [ "ReadWriteOnce" ]
      storageClassName: "my-storage-class"
      resources:
        requests:
          storage: 1Gi
----

<1> The `app` has to match `.spec.template.metadata.labels`.
<2> Indicates the number of replicas of the container that will be launched in unique pods. This is 1 by default.
<2> The `app` has to match `.spec.selector.matchLabels`.
//end::statefulset-sample[]

== Additional concepts

Admission controller
Persistent Volume Provisioner
Headless Service

