[[admin-guide-priority-preemption]]
= Pod Priority and Preemption
{product-author}
{product-version}
:data-uri:
:icons:
:experimental:
:toc: macro
:toc-title:

toc::[]

== Overview

Pods can have priority. Priority indicates the importance of a pod relative to other pods. If a pod cannot be scheduled, the scheduler tries to preempt (evict) lower priority pods to make scheduling of the pending pod possible.

Priority also affects scheduling order of pods and out-of-resource eviction ordering on the Node.pod priority and preemption .

== How to use priority and preemption

To use priority and preemption, follow these steps:

. Add one or more PriorityClasses.

. Create pods with priorityClassName set to one of the added PriorityClasses. Of course you do not need to create the pods directly; normally you would add priorityClassName to the pod template of a collection object like a Deployment.


If you try the feature and then decide to disable it, you must remove the PodPriority command-line flag or set it to false, and then restart the API server and scheduler. After the feature is disabled, the existing pods keep their priority fields, but preemption is disabled, and priority fields are ignored. If the feature is disabled, you cannot set priorityClassName in new pods

== How to use priority and preemption

Preemption is controlled by a scheduler flag disablePreemption, which is set to false by default.

It is important to note that critical pods (except DaemonSet pods, which are still scheduled by the DaemonSet controller) rely on scheduler preemption to be scheduled when a cluster is under resource pressure. For this reason, we do not recommend disabling preemption.

== PriorityClass

A PriorityClass is a non-namespaced object that defines a mapping from a priority class name to the integer value of the priority. The name is specified in the name field of the PriorityClass object’s metadata. The value is specified in the required value field. The higher the value, the higher the priority.

A PriorityClass object can have any 32-bit integer value smaller than or equal to 1 billion. Larger numbers are reserved for critical system pods that should not normally be preempted or evicted. We have two reserved priorityClasses for critical system pods to have guaranteed scheduling.

. System-cluster-critical - This has a priority value of 2000000000. This is used for all the pods that are important for the cluster. While this doesn't ensure eviction from a node always(this could be evicted by pods with system-node-critical priorityClass explained below ), this will ensure guaranteed scheduling. Examples of pods that can have this priorityClass are fluentd, add-on components like descheduler etc.

. System-node-critical - This has a priority value of 2000001000. This priorityClass is used for all the pods that we would not want to be evicted from node at all. Examples of pods that can have this priorityClass are sdn-ovs, sdn etc.


PriorityClass also has two optional fields: globalDefault and description. The globalDefault field indicates that the value of this PriorityClass should be used for pods without a priorityClassName. Only one PriorityClass with globalDefault set to true can exist in the system. If there is no PriorityClass with globalDefault set, the priority of pods with no priorityClassName is zero.

The description field is an arbitrary string. It is meant to tell users of the cluster when they should use this PriorityClass.

=== Notes about PodPriority and existing clusters

. If you upgrade your existing cluster and enable this feature, the priority of your existing pods is effectively zero.

. Addition of a PriorityClass with globalDefault set to true does not change the priorities of existing pods. The value of such a PriorityClass is used only for pods created after the PriorityClass is added.

. If you delete a PriorityClass, existing pods that use the name of the deleted PriorityClass remain unchanged, but you cannot create more pods that use the name of the deleted PriorityClass

.Example PriorityClass
[source, yaml]
----
apiVersion: scheduling.k8s.io/v1beta1
kind: PriorityClass
metadata:
  name: high-priority
value: 1000000
globalDefault: false
description: "This priority class should be used for XYZ service pods only."
----

== Pod priority

After you have one or more PriorityClasses, you can create pods that specify one of those PriorityClass names in their specifications. The priority admission controller uses the priorityClassName field and populates the integer value of the priority. If the priority class is not found, the pod is rejected.

The following YAML is an example of a pod configuration that uses the PriorityClass created in the preceding example. The priority admission controller checks the specification and resolves the priority of the pod to 1000000.

.Example pod with PriorityClass
[source, yaml]
----
apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    env: test
spec:
  containers:
  - name: nginx
    image: nginx
    imagePullPolicy: IfNotPresent
  priorityClassName: high-priority
----

=== Effect of Pod priority on scheduling order

When pod priority is enabled, scheduler orders pending pods by their priority and a pending pod is placed ahead of other pending pods with lower priority in the scheduling queue. As a result, the higher priority pod may by scheduled sooner that pods with lower priority if its scheduling requirements are met. If such pod cannot be scheduled, scheduler will continue and tries to schedule other lower priority pods.

== Preemption

When pods are created, they go to a queue and wait to be scheduled. The scheduler picks a pod from the queue and tries to schedule it on a Node. If no Node is found that satisfies all the specified requirements of the pod, preemption logic is triggered for the pending pod. Let’s call the pending pod P. Preemption logic tries to find a Node where removal of one or more pods with lower priority than P would enable P to be scheduled on that Node. If such a Node is found, one or more lower priority pods get deleted from the Node. After the pods are gone, P can be scheduled on the Node.

=== User exposed information

When pod P preempts one or more pods on Node N, nominatedNodeName field of pod P’s status is set to the name of Node N. This field helps scheduler track resources reserved for pod P and also gives users information about preemptions in their clusters.

Please note that pod P is not necessarily scheduled to the “nominated Node”. After victim pods are preempted, they get their graceful termination period. If another node becomes available while scheduler is waiting for the victim pods to terminate, scheduler will use the other node to schedule pod P. As a result nominatedNodeName and nodeName of pod spec are not always the same. Also, if scheduler preempts pods on Node N, but then a higher priority pod than pod P arrives, scheduler may give Node N to the new higher priority pod. In such a case, scheduler clears nominatedNodeName of pod P. By doing this, scheduler makes pod P eligible to preempt pods on another Node.

=== Limitations of preemption

==== Graceful termination of preemption victims

When pods are preempted, the victims get their xref:../../dev_guide/deployments/advanced_deployment_strategies.adoc#graceful-termination[graceful termination period]. They have that much time to finish their work and exit. If they don’t, they are killed. This graceful termination period creates a time gap between the point that the scheduler preempts pods and the time when the pending pod (P) can be scheduled on the Node (N). In the meantime, the scheduler keeps scheduling other pending pods. As victims exit or get terminated, the scheduler tries to schedule pods in the pending queue. Therefore, there is usually a time gap between the point that scheduler preempts victims and the time that pod P is scheduled. In order to minimize this gap, one can set graceful termination period of lower priority pods to zero or a small number.

==== PodDisruptionBudget is supported, but not guaranteed!

A xref:../../admin_guide/managing_pods.adoc#managing-pods-poddisruptionbudget[Disruption Budget (PDB)] allows application owners to limit the number pods of a replicated application that are down simultaneously from voluntary disruptions. {product-title} supports PDB when preempting pods, but respecting PDB is best effort. The Scheduler tries to find victims whose PDB are not violated by preemption, but if no such victims are found, preemption will still happen, and lower priority pods will be removed despite their PDBs being violated.

==== Inter-Pod affinity on lower-priority Pods

A Node is considered for preemption only when the answer to this question is yes: “If all the pods with lower priority than the pending pod are removed from the Node, can the pending pod be scheduled on the Node?”

Preemption does not necessarily remove all lower-priority pods. If the pending pod can be scheduled by removing fewer than all lower-priority pods, then only a portion of the lower-priority pods are removed. Even so, the answer to the preceding question must be yes. If the answer is no, the Node is not considered for preemption.

If a pending pod has inter-pod affinity to one or more of the lower-priority pods on the Node, the inter-pod affinity rule cannot be satisfied in the absence of those lower-priority pods. In this case, the scheduler does not preempt any pods on the Node. Instead, it looks for another Node. The scheduler might find a suitable Node or it might not. There is no guarantee that the pending pod can be scheduled.

Our recommended solution for this problem is to create inter-pod affinity only towards equal or higher priority pods.

==== Cross node preemption

Suppose a Node N is being considered for preemption so that a pending pod P can be scheduled on N. P might become feasible on N only if a pod on another Node is preempted. Here’s an example:

. pod P is being considered for Node N.
. pod Q is running on another Node in the same Zone as Node N.
. pod P has Zone-wide anti-affinity with pod Q (topologyKey: failure-domain.beta.kubernetes.io/zone).
. There are no other cases of anti-affinity between pod P and other pods in the Zone.
. In order to schedule pod P on Node N, pod Q can be preempted, but scheduler does not perform cross-node preemption. So, pod P will be deemed unschedulable on Node N.

If pod Q were removed from its Node, the pod anti-affinity violation would be gone, and pod P could possibly be scheduled on Node N.
