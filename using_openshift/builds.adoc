= Builds
{product-author}
{product-version}
:data-uri:
:icons:
:experimental:
:toc: macro
:toc-title:

toc::[]

== Overview
A build is a process of creating runnable image to be used on OpenShift. There are three types of builds:

* Docker build
* STI build
* custom build

See the link:../architecture/builds.html[Builds] architecture topic for more details on these build types.

== Starting a Build
Builds can be manually invoked using the following command:

----
osc start-build <buildConfigID>
----

They can also be re-run using the `--from-build` flag:

----
osc start-build --from-build=<buildID>
----

== Canceling a Build
Builds can be manually canceled using the following command:

----
osc cancel-build <buildID>
----

== Accessing Build Logs
Builds allow access to their logs using following command:

----
osc build-logs <buildID>
----

== Source Code
The source code location is one of the required parameters for the BuildConfig. The build uses this location and fetches the source code that is later built. The source code location definition is part of the `parameters` section in the BuildConfig:

----
        {
          "source" : {
            "type" : "Git", <1>
            "git" : { <2>
              "uri": "git://github.com/openshift/ruby-hello-world.git"
            },
            "contextDir": "app/dir", <3>
          },
        }
----

<1> The `type` field describes what SCM is used to fetch your source code.
<2> In this example, the `git` field contains the URI to the remote Git repository where your source code lives. It might optionally specify the `ref` field if you want to check out a specific Git reference. A valid `ref` can be a SHA1 tag or a branch name.
<3> The `contextDir` field allows you to override the default location inside the source code repository, where the build looks for the application source code. If your application exists inside a sub-directory, you can override the default location (the root folder) using this field.

== Build Triggers
When defining a BuildConfig, you can define triggers to control circumstances under which a build should be run for the BuildConfig. There are two types of triggers available:

* Webhook
* Image change

=== Webhook Triggers
Webhook triggers allow you to trigger a new build by sending a request to the OpenShift API endpoint. You can define these triggers using https://developer.github.com/webhooks/[GitHub webhooks] or generic webhooks.

*GitHub Webhooks*

GitHub webhooks can handle the call made by GitHub when a repository is updated. When defining the trigger, you can specify a `secret` which is part of the URL you supply to GitHub when configuring the webhook. This ensures that only you and your repository can trigger the build. The trigger definition JSON within the BuildConfig looks like:

----
        {
          "type": "github",
          "github": {
            "secret": "secret101"
          }
        }
----

See the https://developer.github.com/webhooks/creating/[GitHub Developer documentation] for instructions on creating a GitHub webhook. The payload URL is the URL returned as the GitHub Webhook URL by the `describe` command (see link:#describe-buildconfig[below]). It will be of the form:

----
http://<openshift_api_host:port>/osapi/v1beta1/buildConfigHooks/<build-name>/<secret>/github?namespace=<namespace>
----

*Generic Webhooks*

Generic webhooks can be invoked from any system capable of making a web request.  As with a GitHub webhook, you specify a secret when defining the trigger and the caller must provide this secret to trigger the build.  The trigger definition JSON within the BuildConfig looks like this:

----
        {
          "type": "generic",
          "generic": {
            "secret": "secret101"
          }
        }
----

To set up the caller, supply the calling system with the URL of the generic webhook endpoint for your build which will look like:

----
http://<openshift_api_host:port>/osapi/v1beta/buildConfigHooks/<build-name>/<secret>/generic?namespace=<namespace>
----

The endpoint can accept an optional payload with the following format:

----
{
     type: 'git',
     git: {
        uri: '<url to git repository>',
	ref: '<optional git reference>',
	commit: '<commit hash identifying a specific git commit>',
	author: {
		name: '<author name>',
		email: '<author e-mail>',
	},
	committer: {
		name: '<committer name>',
		email: '<committer e-mail>',
	},
	message: '<commit message>'
     }
}
----

[#describe-buildconfig]
*Displaying a BuildConfig's Webhook URLs*

Use the `osc describe buildConfig [replaceable]#<name>#` command to display the Webhook URLs associated with a build configuration. If no Webhook URLs are displayed, it means that no Webhook trigger is defined for that build configuration.

=== Image Change Triggers
Image change triggers allow your build to be automatically invoked when a new version of an upstream image is available. For example, if a build is based on top of a RHEL image, then you can trigger that build to run anytime the RHEL image changes. As a result, the application image is always running on the latest RHEL base image.

Configuring an image change trigger requires that a few pieces be in place:

. First, you must define an ImageRepository that points to the upstream image from which you want to trigger. An example of an ImageRepository definition is as follows:
+
----
    {
      "metadata":{
        "name": "ruby-20-centos7",
      },
      "kind": "ImageRepository",
      "apiVersion": "v1beta1",
    }
----
+
This defines an image repository which is tied to a Docker image repository located at `[replaceable]#<system-registry>#/[replaceable]#<namespace>#/ruby-20-centos7`. The `[replaceable]#<system-registry>#` is defined as a service with the name `docker-registry` running in OpenShift.

. Next, define a build with a strategy which consumes some upstream image; for example:
+
----
    "strategy": {
      "type": "STI",
      "stiStrategy": {
        "image": "172.30.17.3:5001/mynamespace/ruby-20-centos7",
      }
    }
----
+
In this case, the STI strategy definition is consuming a Docker image repository named `172.30.17.3:5001/mynamespace/ruby-20-centos7`. Here, `172.30.17.3:5001` corresponds to the OpenShift system registry service.

. Finally, define an image change trigger to tie these pieces together:
+
----
    {
      "type": "imageChange",
       "imageChange": {
        "image": "172.30.17.3:5001/mynamespace/ruby-20-centos7",
        "from": {
          "name": "ruby-20-centos7"
        },
        "tag":"latest"
      }
    }
----
+
This defines an image change trigger which monitors the `ruby-20-centos7` ImageRepository defined earlier. Specifically, it monitors for changes to the `latest` tag in that repository. When a change occurs, a new build is triggered and is supplied with an immutable Docker tag that points to the new image that was just created. Wherever the BuildConfig previously referenced `172.30.17.3:5001/mynamespace/ruby-20-centos` (as defined by the image change trigger's image field), the value is replaced with the new immutable image tag; for example, the newly-created build will have a definition like:
+
----
    "strategy": {
      "type": "STI",
      "stiStrategy": {
        "image": "172.30.17.3:5001/mynamespace/ruby-20-centos7:immutableid",
      }
    }
----
+
This ensures that the triggered build uses the new image that was just pushed to the repository, and the build can be re-run anytime with exactly the same inputs.

For STI type builds, the field that is matched and replaced is the `stiStrategy.image` field. For Docker type builds, the field is `dockerStrategy.baseImage`. For Custom builds, the `customStrategy.image` field is updated.

In addition, for custom builds, the `OPENSHIFT_CUSTOM_BUILD_BASE_IMAGE` environment variable is checked.  If it does not exist, it is created with the immutable image reference. If it does exist and the value matches the image field of the image change trigger, it is updated with the immutable image reference.

Anytime an ImageChange trigger is defined on a BuildConfig and a build is triggered (whether due to an image change, webhook trigger, or manual request), the build that is created uses the `immutableid` resolved from the ImageRepository pointed to by the ImageChange trigger. This ensures that builds are performed using consistent image tags for reproduceability.
