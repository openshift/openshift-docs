include::modules/serverless-document-attributes.adoc[]
[id="about-serverless"]
= About {ServerlessProductName}
:context: about-serverless
include::modules/common-attributes.adoc[]

toc::[]

{ServerlessProductName} enables developers to deploy and manage cloud-native applications that can run anywhere, without provisioning or managing servers.
These routine tasks are abstracted away by the platform, allowing developers to push code to production much faster than in traditional models.

Developers can use a single platform for hosting their microservices, legacy, and serverless applications, and can use the provided Kubernetes native APIs, as well as familiar languages and frameworks, to deploy applications and stateless container workloads.
This improves developer productivity by removing the need for complex infrastructure to be set up before apps can be deployed.

Operational costs can be reduced by implementing out-of-the-box {ServerlessProductName} solutions for automating operational tasks, such as the Knative Serving component's auto-scaling app capabilities.
You can fine-tune system and application settings by creating or modifying Kubernetes custom resources.

{ServerlessProductName} is based on the open source link:https://knative.dev/[Knative] project.

include::modules/serverless-supported-configs.adoc[leveloffset=+1]

[id="about-serverless-serving"]
== Knative Serving component

Knative Serving supports deploying and managing link:https://www.redhat.com/en/topics/cloud-native-apps[cloud-native applications] by providing a set of objects as Kubernetes Custom Resource Definitions (CRDs) that define and control the behavior of serverless workloads on an {product-title} cluster.
For more information about CRDs, see xref:../operators/crds/crd-extending-api-with-crds.adoc#crd-extending-api-with-crds[Extending the Kubernetes API with Custom Resource Definitions].

Developers use these CRDs to create custom resource (CR) instances that can be used as building blocks to address complex use cases. For example:

* Rapidly deploying serverless containers.
* Automatically scaling pods.
// TODO: Add other use cases, more advanced tutorials?

For more information about CRs, see xref:../operators/crds/crd-managing-resources-from-crds.adoc#crd-managing-resources-from-crds[Managing resources from Custom Resource Definitions].

=== Knative Serving CRDs
// TODO: Request a good Serving arch diagram

Service:: The `service.serving.knative.dev` CRD automatically manages the life cycle of your workload to ensure that the application is deployed and reachable through the network. It creates a route, a configuration, and a new revision for each change to a user-created service. Most developer interactions in Knative are carried out by modifying services.

Revision:: The `revision.serving.knative.dev` CRD is a point-in-time snapshot of the code and configuration for each modification made to the workload. Revisions are immutable objects and can be retained for as long as necessary.

Route:: The `route.serving.knative.dev` CRD maps a network endpoint to one or more revisions. You can manage the traffic in several ways, including fractional traffic and named routes.

Configuration:: The `configuration.serving.knative.dev` CRD maintains the desired state for your deployment. It provides a clean separation between code and configuration. Modifying a configuration creates a new revision.

[id="about-serverless-eventing"]
== Knative Eventing component

:FeatureName: Knative Eventing
include::modules/technology-preview.adoc[leveloffset=+2]

Knative Eventing on {product-title} enables developers to use an link:https://www.redhat.com/en/topics/integration/what-is-event-driven-architecture[event-driven architecture] with serverless applications.
An event-driven architecture is based on the concept of decoupled relationships between event producers that create events, and event  _sinks_, or consumers, that receive them.

Knative Eventing uses standard HTTP POST requests to send and receive events between event producers and consumers.
These events conform to the link:https://cloudevents.io[CloudEvents specifications], which enables creating, parsing, sending, and receiving events in any programming language.

You can propagate an event from an xref:../serverless/event_sources/knative-event-sources.adoc#knative-event-sources[event source] to multiple event sinks by using:

* xref:../serverless/knative_eventing/serverless-channels.adoc#serverless-channels[channels] and xref:../serverless/knative_eventing/serverless-subscriptions.adoc#serverless-subscriptions[subscriptions], or
* xref:../serverless/knative_eventing/serverless-using-brokers.adoc#serverless-using-brokers[brokers] and xref:../serverless/knative_eventing/serverless-kn-trigger.adoc#serverless-kn-trigger[triggers].

Events are buffered if the destination sink is unavailable.

Knative Eventing supports the following scenarios:

Publish an event without creating a consumer:: You can send events to a broker as an HTTP POST, and use a SinkBinding to decouple the destination configuration from your application that is producing events.
Consume an event without creating a publisher:: You can use a trigger to consume events from a broker based on event attributes. Your application will receive events as an HTTP POST.
// Use Channels and Subscriptions to define complex message-passing topologies:: For simple pipelines, the Sequence automates construction of Channels and Subscriptions between each stage.
// Knative also supports some additional patterns such as Parallel fanout of events, and routing response events from both Channels and Brokers

=== Event sinks

To enable delivery to multiple types of sinks, Knative Eventing defines the following generic interfaces that can be implemented by multiple Kubernetes resources:

Addressable objects:: Able to receive and acknowledge an event delivered over HTTP to an address defined in the event's `status.address.url` field. The Kubernetes Service object also satisfies the addressable interface.
Callable objects:: Able to receive an event delivered over HTTP and transform it, returning 0 or 1 new events in the HTTP response payload. These returned events may be further processed in the same way that events from an external event source are processed.
