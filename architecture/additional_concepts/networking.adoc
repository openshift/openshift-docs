[[architecture-additional-concepts-networking]]
= Networking
{product-author}
{product-version}
:data-uri:
:icons:
:experimental:
:toc: macro
:toc-title:

toc::[]

== Overview

Kubernetes ensures that pods are able to network with each other, and
allocates each pod an IP address from an internal network. This ensures all
containers within the pod behave as if they were on the same host. Giving each
pod its own IP address means that pods can be treated like physical hosts or
virtual machines in terms of port allocation, networking, naming, service
discovery, load balancing, application configuration, and migration.

Creating links between pods is unnecessary. However, it is not recommended that
you have a pod talk to another directly by using the IP address. Instead, we
recommend that you create a
xref:../core_concepts/pods_and_services.adoc#services[service], then interact
with the service.

[[architecture-additional-concepts-openshift-dns]]
== {product-title} DNS

If you are running multiple
xref:../core_concepts/pods_and_services.adoc#services[services], such as
frontend and backend services for use with multiple pods, in order for the
frontend pods to communicate with the backend services, environment variables
are created for user names, service IP, and more. If the service is deleted and
recreated, a new IP address can be assigned to the service, and requires the
frontend pods to be recreated in order to pick up the updated values for the
service IP environment variable. Additionally, the backend service has to be
created before any of the frontend pods to ensure that the service IP is
generated properly and that it can be provided to the frontend pods as an
environment variable.

For this reason, {product-title} has a built-in DNS so that the services can be
reached by the service DNS as well as the service IP/port. {product-title}
supports split DNS by running
link:https://github.com/skynetservices/skydns[SkyDNS] on the master that answers
DNS queries for services. The master listens to port 53 by default.

When the node starts, the following message indicates the Kubelet is correctly
resolved to the master:

----
0308 19:51:03.118430    4484 node.go:197] Started Kubelet for node
openshiftdev.local, server at 0.0.0.0:10250
I0308 19:51:03.118459    4484 node.go:199]   Kubelet is setting 10.0.2.15 as a
DNS nameserver for domain "local"
----

If the second message does not appear, the Kubernetes service may not be available.

On a node host, each container's nameserver has the master name added to the
front, and the default search domain for the container will be
`._<pod_namespace>_.cluster.local`. The container will then direct any nameserver
queries to the master before any other nameservers on the node, which is the
default behavior for Docker-formatted containers. The master will answer queries on the `.cluster.local` domain
that have the following form:

.DNS Example Names
[cols=".2,.^5,8",options="header"]
|===

|Object Type |Example

|Default
|<pod_namespace>.cluster.local

|Services
|<service>.<pod_namespace>.svc.cluster.local

|Endpoints
|<name>.<namespace>.endpoints.cluster.local
|===

This prevents having to restart frontend pods in order to pick up new services,
which creates a new IP for the service. This also removes the need to use
environment variables, as pods can use the service DNS. Also, as the DNS does not change, you can reference database services as
`db.local` in config files. Wildcard lookups are also supported, as any lookups
resolve to the service IP, and removes the need to create the backend service
before any of the frontend pods, since the service name (and hence DNS) is
established upfront.

This DNS structure also covers headless services, where a portal IP is not
assigned to the service and the kube-proxy does not load-balance or provide
routing for its endpoints. Service DNS can still be used and responds with
multiple A records, one for each pod of the service, allowing the client to
round-robin between each pod.

[[port-forwarding]]

== Port Forwarding

{product-title} takes advantage of a feature built into
link:https://kubernetes.io/docs/user-guide/kubectl/kubectl_port-forward/#[Kubernetes] to support port
forwarding to pods. This is implemented using HTTP along with a multiplexed
streaming protocol such as link:http://www.chromium.org/spdy[*SPDY*]

See xref:port_forwarding.adoc#[Port Forwarding] for more information.

[[network-plugins]]

== Network Plug-ins

{product-title} supports the Kubernetes
link:https://kubernetes.io/docs/admin/network-plugins/#cni[Container Network
Interface (CNI)] as the interface between the {product-title} and Kubernetes.
Software defined network (SDN) plugins are a powerful and flexable way
to match network capabilities to your networking needs.  There are several
xref:sdn.adoc#architecture-additional-concepts-sdn[{product-title} SDN plugins] as well as
available third party plugins. Additional plugins that support the CNI interface
can be added as needed.

ifdef::openshift-enterprise,openshift-origin[]
The following network plug-ins are currently supported by {product-title}.
endif::[]

- xref:sdn.adoc#architecture-additional-concepts-sdn[{product-title} SDN] plugins

- xref:sdn.adoc#network-isolation-multitenant[{product-title} Network Isolation SDN]

- xref:flannel.adoc#[Flannel SDN] plugin

- xref:contiv.adoc#[Contiv SDN] plugin

- xref:nuagesdn.adoc#[Nuage Networks SDN] plugin


[[openshift-sdn]]
=== {product-title} SDN

The {product-title} SDN connects all pods across all node hosts, providing a
unified cluster network.  It can be installed and configured as part of the
Ansible-based installation procedure.

There are several
xref:sdn.adoc#architecture-additional-concepts-sdn[SDN plugins]
plugins to chose from depending on your needs.

[[flannel-sdn]]
=== xref:flannel.adoc#[Flannel SDN]

Flannel is an alternative SDN.
See xref:flannel.adoc#[Flannel SDN] for more information.


[[contiv-sdn]]
=== xref:contiv.adoc#[Contiv SDN]

Contiv is an alternative SDN.
See xref:contiv.adoc#[Contiv SDN] for more information.


ifdef::openshift-enterprise,openshift-origin[]
[[nuage-sdn]]
=== xref:nuagesdn.adoc#[Nuage SDN for {product-title}]

xref:nuagesdn.adoc#[Nuage Networks']
SDN solution delivers highly scalable, policy-based overlay
networking for pods in an {product-title} cluster.
endif::[]

