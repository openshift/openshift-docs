[[architecture-core-concepts-routers]]
= Routers
{product-author}
{product-version}
:data-uri:
:icons:
:experimental:
:toc: macro
:toc-title:
:prewrap!:

toc::[]

== Overview

Routers are one way to
xref:getting_traffic_into_cluster.adoc#[get traffic into the cluster].
Working with routers and routes brings together the external user, external network
administrator, the cluster administrator, and the application developer. Each
has a role in creating and using a cloud based application.

For example, a user on the external network may want to browse to a host name that
accesses an application in the cluster. The application developer creates the
application and a route that specifies the host name to access it.  The administrator
of the external network arranges for the application's host name (as found in the route)
to resolve to the host in the cluster that is running the router.  The cluster administrator
deploys the needed router on the selected node. This router accepts traffic from the
external network and passes it to the application using the xref:routes.adoc#[route]
that the developer created.

This simple example can be greatly expanded to serve a large variety of applications 
that have differing needs. The router that is set up by default in a small cluster
may be augmented by more routers with specialized roles in larger clusters. 

A developer, working in a project or namespace, can create a application consisting
of one or more xref:pods_and_services.adoc#pods[pods].
At this point networking is restricted to pods in the namespace. The user can create a
xref:pods_and_services.adoc#services[service] that exposes the application in the cluster.

To make the application visible to the external network through a router,
the user can expose the xref:pods_and_services.adoc#services[service] at a host name,
such as _www.example.com_, which creates a xref:routes.adoc#[route]. The route can be admitted 
by a router. At this point requests for _www.example.com_ are passed to the application.


[[routers]]
== Routers

{product-title} provides a very flexible routing environment through
xref:available-router-plug-ins[router plug-ins].
The two available {product-title} plug-ins support the
xref:haproxy-router.adoc#[HAProxy router]
and the
xref:f5-router.adoc#[*F5 BIG-IP®*]
router.
Both plug-ins admit (accept)
xref:routes.adoc#[routes] created by developers
and proxy traffic to the application pods base on the admitted routes.

By default routers use host networking and listen on ports 80 (HTTP) and 443 (HTTPS).
This usually limits the administrator to deploying at most one router per node in the
cluster which limits the total number of routers.

The network administrator directs traffic to the router's host IP address. When the router is 
created it must be deployed on a specific node.  The administrator can use labels and
xref:../../install_config/router/default_haproxy_router.adoc#adding-nodeselector-to-a-deployment[node selectors]
to deploy the routers on specific nodes.

[NOTE]
The administrator can specify alternative ports as well as use cluster networking.
Multiple routers can run on the same node as long as they listen on different ports.

By default, each router admits all of the xref:routes.adoc#[routes] from all namespaces. The administrator
can configure a router to admit routes from a given set of namespaces or based on 
specific labels in the routes. The administrator can use this to xref:router-sharding[shard]
(distribute) cluster 
traffic over multiple routers. When this is done the external network administrator and cluster
administrator must coordinate to ensure the traffic reaches the intended routers and from there
goes to the intended applications.

When routes from different namespaces are selected and specify the same host name the
route that was created first is admitted and the others are rejected.
This allows a host name to be claimed by a project.


ifdef::openshift-enterprise,openshift-origin[]
[NOTE]
====
See the xref:../../install_config/router/index.adoc#install-config-router-overview[Installation and
Configuration] guide for information on deploying a router.
====
endif::[]

A router uses the service selector to find the
xref:pods_and_services.adoc#services[service] and the endpoints backing
the service.
Since both router and service provide load balancing,
{product-title} uses router load balancing.
A router detects relevant changes in the IP addresses of its services,
and adapts its configuration accordingly.
This is useful for custom routers to communicate modifications
of API objects to an external routing solution.

The path of a request starts with the DNS resolution of a host name
to one or more routers.
The suggested method is to define a cloud domain with a
xref:../../install_config/install/prerequisites.adoc#prereq-dns[DNS wildcard entry]
pointing to one or more virtual IP (VIP)
addresses backed by multiple router instances.
Routes using names and addresses outside the cloud domain require
configuration of individual DNS entries.

When there are fewer VIP addresses than routers, the routers corresponding
to the number of addresses are _active_ and the rest are _passive_.
A passive router is also known as a _hot-standby_ router.
For example, with two VIP addresses and three routers,
you have an "active-active-passive" configuration.
See
ifdef::openshift-enterprise,openshift-origin[]
xref:../../admin_guide/high_availability.adoc#configuring-a-highly-available-service[High Availability]
endif::[]
ifdef::openshift-dedicated[]
the link:https://docs.openshift.com/enterprise/3.1/admin_guide/high_availability.html#configuring-a-highly-available-service[{product-title} Enterprise Cluster Administration documentation]
endif::[]
for more information on router VIP configuration.

Routes can be
xref:router-sharding[sharded]
among the set of routers.
Administrators can set up sharding on a cluster-wide basis
and users can set up sharding for the namespace in their project.
Sharding allows the operator to define multiple router groups.
Each router in the group serves only a subset of traffic.

{product-title} routers provide external host name mapping and load balancing
of xref:pods_and_services.adoc#services[service] end points over protocols that
pass distinguishing information directly to the router; the host name
must be present in the protocol in order for the router to determine
where to send it.

By default, Router plug-ins assume they can bind to host ports 80 (HTTP)
and 443 (HTTPS).
This means that routers must be placed on nodes
where those ports are not otherwise in use.
Alternatively, a router can be configured to listen
on other ports by setting the xref:env-variables#[`ROUTER_SERVICE_HTTP_PORT`]
and xref:env-variables#[`ROUTER_SERVICE_HTTPS_PORT`] environment variables.

Because a router binds to ports on the host node,
only one router listening on those ports can be on each node
if the router uses host networking (the default).
Cluster networking is configured such that all routers
can access all pods in the cluster.

Routers support the following protocols:

- HTTP
- HTTPS (with SNI)
- WebSockets
- TLS with SNI

[NOTE]
====
WebSocket traffic uses the same route conventions and supports the same TLS
termination types as other traffic.
====

[[available-router-plug-ins]]

== Available Router Plug-ins

The following router plug-ins are provided and supported in {product-title}.

- xref:haproxy-router.adoc#[HAProxy Template Router Plug-in]

ifdef::openshift-enterprise,openshift-origin[]
- xref:f5-router.adoc#[F5 BIG-IP® Router Plug-in]
endif::[]

Instructions on deploying these routers are available in
xref:../../install_config/router/index.adoc#install-config-router-overview[Deploying a Router].


[[haproxy-template-router]]

=== xref:haproxy-router.adoc#[HAProxy Template Router]

[[f5-router]]

=== xref:f5-router.adoc#[F5 BIG-IP® Router]

[[router-sharding]]
== Router Sharding

In {product-title}, each route can have any number of
xref:routes.adoc#route-labels[labels]
in its `metadata` field.
A router uses _selectors_ (also known as a _selection expression_)
to select a subset of routes from the entire pool of routes to serve.
A selection expression can also involve
labels on the route's namespace.
The selected routes form a _router shard_.
ifdef::openshift-enterprise,openshift-origin[]
You can
xref:../../install_config/router/default_haproxy_router.adoc#creating-router-shards[create]
and
xref:../../install_config/router/default_haproxy_router.adoc#modifying-router-shards[modify]
router shards independently from the routes, themselves.
endif::[]

This design supports _traditional_ sharding as well as _overlapped_ sharding.
In traditional sharding, the selection results in no overlapping sets
and a route belongs to exactly one shard.
In overlapped sharding, the selection results in overlapping sets
and a route can belong to many different shards.
For example, a single route may belong to a `SLA=high` shard
(but not `SLA=medium` or `SLA=low` shards),
as well as a `geo=west` shard
(but not a `geo=east` shard).

Another example of overlapped sharding is a
set of routers that select based on namespace of the route:

[cols="1,1,3",options="header"]
|===
| Router | Selection | Namespaces

|router-1
|`A*` -- `J*`
|`A*`, `B*`, `C*`, `D*`, `E*`, `F*`, `G*`, `H*`, `I*`, `J*`

|router-2
|`K*` -- `T*`
|`K*`, `L*`, `M*`, `N*`, `O*`, `P*`, `Q*`, `R*`, `S*`, `T*`

|router-3
|`Q*` -- `Z*`
|`Q*`, `R*`, `S*`, `T*`, `U*`, `V*`, `W*`, `X*`, `Y*`, `Z*`
|===

Both `router-2` and `router-3` serve routes that are in the
namespaces `Q*`, `R*`, `S*`, `T*`.
To change this example from overlapped to traditional sharding,
we could change the selection of `router-2` to `K*` -- `P*`,
which would eliminate the overlap.

When routers are sharded,
a given route is bound to zero or more routers in the group.
The route binding ensures uniqueness of the route across the shard.
Uniqueness allows secure and non-secure versions of the same route to exist
within a single shard.
This implies that routes now have a visible life cycle
that moves from created to bound to active.

In the sharded environment the first route to hit the shard
reserves the right to exist there indefinitely, even across restarts.

During a green/blue deployment a route may be be selected in multiple routers.
An {product-title} application administrator may wish to bleed traffic from one
version of the application to another and then turn off the old version.

Sharding can be done by the administrator at a cluster level and by the user
at a project/namespace level.  When namespace labels are used, the service
account for the router must have
xref:../../install_config/router/index.adoc#router-use-of-labels[`cluster-reader`]
permission to permit the router to access the labels in the namespace.


[NOTE]
====
For two or more routes that claim the same host name, the resolution order
is based on the age of the route and the oldest route would win the claim to
that host.
In the case of sharded routers, routes are selected based on their labels
matching the router's selection criteria. There is no consistent way to
determine when labels are added to a route. So if an older route claiming
an existing host name is "re-labelled" to match the router's selection
criteria, it will replace the existing route based on the above mentioned
resolution order (oldest route wins).
====

[[env-variables]]
== Environment Variables

When you create a router using `oadm router` a *deployment configuration* is created that includes environment
variables that are passed to the router pods when they are created. These environment variables control HAProxy
operation.

Values can be set or changed with the `oc set env` command, or the `oc edit <dc/...>` commands.
 
----
$ oc set env <object_type>/<object_name> KEY1=VALUE1 KEY2=VALUE2
----

For example:

----
$ oc set env dc/router HAPROXY_ROUTER_SYSLOG_ADDRESS=127.0.0.1 HAPROXY_ROUTER_LOG_LEVEL=debug
----

.Router Configuration Parameters
[cols="2,2,6", options="header"]
|===
|Variable | Default | Description
|`*DEFAULT_CERTIFICATE*` |  | The contents of a default certificate to use for routes that don't expose a TLS server cert; in PEM format.
|`*DEFAULT_CERTIFICATE_DIR*` |  | A path to a directory that contains a file named *_tls.crt_*. If *_tls.crt_* is not a PEM file which also contains a private key, it is first combined with a file named tls.key in the same directory. The PEM-format contents are then used as the default certificate. Only used if `DEFAULT_CERTIFICATE` or `DEFAULT_CERTIFICATE_PATH` are not specified.
|`*DEFAULT_CERTIFICATE_PATH*` |  | A path to default certificate to use for routes that don't expose a TLS server cert; in PEM format. Only used if `DEFAULT_CERTIFICATE` is not specified.
|`*EXTENDED_VALIDATION*` | true | If `true`, perform an additional extended validation step on all routes admitted by this router.
|`*NAMESPACE_LABELS*` |  | A label selector to apply to namespaces to watch, empty means all.
|`*PROJECT_LABELS*` |  | A label selector to apply to projects to watch, emtpy means all.
|`*RELOAD_SCRIPT*` |  | The path to the reload script to use to reload the router.
|`*ROUTER_ALLOWED_DOMAINS*` | | A comma-separated list of domains that the host name in a route can only be part of. Any subdomain in the domain can be used. Option `ROUTER_DENIED_DOMAINS` overrides any values given in this option. If set, everything outside of the allowed domains will be rejected.
|`*ROUTER_BACKEND_CHECK_INTERVAL*` | 5000ms | Length of time between subsequent "liveness" checks on backends.
|`*ROUTER_COMPRESSION_MIME*` | "text/html text/plain text/css" | A space separated list of mime types to compress.
|`*ROUTER_DEFAULT_CLIENT_TIMEOUT*`| 30s | Length of time within which a client has to acknowledge or send data.
|`*ROUTER_DEFAULT_CONNECT_TIMEOUT*`| 5s | The maximum connect time.
|`*ROUTER_DEFAULT_SERVER_TIMEOUT*`| 30s | Length of time within which a server has to acknowledge or send data.
|`*ROUTER_DEFAULT_TUNNEL_TIMEOUT*` | 1h | Length of time till which TCP or WebSocket connections will remain open.
|`*ROUTER_DENIED_DOMAINS*` | | A comma-separated list of domains that the host name in a route can not be part of. No subdomain in the domain can be used either. Overrides option `ROUTER_ALLOWED_DOMAINS`.
|`*ROUTER_ENABLE_COMPRESSION*`| false | If `true`, compress responses when possible.
|`*ROUTER_LOG_LEVEL*` | warning | The log level to send to the syslog server.
|`*ROUTER_MAX_CONNECTIONS*`| 2000 | Maximum number of concurrent connections.
|`*ROUTER_OVERRIDE_HOSTNAME*`|  | If set, override the spec.host value for a route with the template in ROUTER_SUBDOMAIN.
|`*ROUTER_SERVICE_HTTPS_PORT*` | 443 | Port to listen for HTTPS requests. Make sure firewall passes new port.
|`*ROUTER_SERVICE_HTTP_PORT*` | 80 | Port to listen for HTTP requests. Make sure firewall passes new port.
|`*ROUTER_SERVICE_NAME*` | public | The name that the router identifies itself in the in route status.
|`*ROUTER_CANONICAL_HOSTNAME*` | | The (optional) host name of the router shown in the in route status.
|`*ROUTER_SERVICE_NAMESPACE*` |  | The namespace the router identifies itself in the in route status. Required if `ROUTER_SERVICE_NAME` is used.
|`*ROUTER_SERVICE_NO_SNI_PORT*` | 10443 | Internal port for some front-end to back-end communication (see note below).
|`*ROUTER_SERVICE_SNI_PORT*` | 10444 | Internal port for some front-end to back-end communication (see note below).
|`*ROUTER_SLOWLORIS_HTTP_KEEPALIVE*` | 300s | Set the maximum time to wait for a new HTTP request to appear. If this is set too low, it can confuse browsers and applications not expecting a small `keepalive` value.
|`*ROUTER_SLOWLORIS_TIMEOUT*` | 10s | Length of time the transmission of an HTTP request can take.
|`*ROUTER_SUBDOMAIN*`|  | The template that should be used to generate the host name for a route without spec.host (e.g. `${name}-${namespace}.myapps.mycompany.com`).
|`*ROUTER_SYSLOG_ADDRESS*` |  | Address to send log messages. Disabled if empty.
|`*ROUTER_TCP_BALANCE_SCHEME*` | source | Load-balancing strategy for multiple endpoints for pass-through routes. Available options are `source`, `roundrobin`, or `leastconn`.
|`*ROUTER_LOAD_BALANCE_ALGORITHM*` | leastconn | Load-balancing strategy routes with multiple endpoints. Available options are `source`, `roundrobin`, and `leastconn`.
//|`*ROUTE_FIELDS*` |  | A field selector to apply to routes to watch, empty means all.
|`*ROUTE_LABELS*` |  | A label selector to apply to the routes to watch, empty means all.
|`*STATS_PASSWORD*` |  | The password needed to access router stats (if the router implementation supports it).
|`*STATS_PORT*` |  | Port to expose statistics on (if the router implementation supports it).  If not set, stats are not exposed.
|`*STATS_USERNAME*` |  | The user name needed to access router stats (if the router implementation supports it).
|`*TEMPLATE_FILE*` | `/var/lib/haproxy/conf/custom/` `haproxy-config-custom.template` | The path to the HAproxy template file (in the image).
|`*RELOAD_INTERVAL*` | 12s | The minimum period the router is allowed to reload to accept new changes.
|`*ROUTER_USE_PROXY_PROTOCOL*` |  | When set to 'true' or 'TRUE', HAProxy expects incoming connections to use the `PROXY` protocol.
|===

Supported time units with HAProxy are microseconds (us), milliseconds (ms), seconds (s),
minutes (m), hours (h), or days (d). When no unit is specified, the default is ms.

[NOTE]
====
If you want to run multiple routers on the same machine, you must
change the ports that the router is listening on,
`ROUTER_SERVICE_SNI_PORT` and `ROUTER_SERVICE_NO_SNI_PORT`.  These ports can
be anything you want as long as they are unique on the machine.  These ports will
not be exposed externally.
====


