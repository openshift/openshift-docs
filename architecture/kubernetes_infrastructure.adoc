= Kubernetes Model
{product-author}
{product-version}
:data-uri:
:icons:
:experimental:
:toc:
:toc-placement!:
:toc-title:

toc::[]

Kubernetes is a system for managing containerized applications across a set of containers or hosts, providing deployment, maintenence, and application-scaling mechanisms. Docker is used to package, instantiate, and run containerized applications. 

A Kubernetes cluster involves a master component and a set of nodes, all on top of a distributed storage system. 

== Master

The Kubernetes master is the host or hosts that contain the master components (API Server, Controller Manger Server, etcd, etc)

=== API Server

The Kubernetes API server serves the main API, and validates and configures the data for pods, services, and replication controllers. The Kuberbetes API server also assigns pods to nodes and synchronizes pod information with service configuration. 

=== etcd

All persistent master state is stored in etcd. Other components watch etcd for changes and eventually bring themselves into the desired state described in etcd.

=== Controller Manager Server

The controller manager server watches etcd for changes to replication controller objects and then uses the API to enforce the desired state.

== Node

A Kubernetes node is managed from the master systems, and has the services necessary in order to run Docker containers. Each node runs Docker, which takes care of downloading and running containers.

A node is not created by Kubernetes, it is instead created by your cloud providers, or from your physical or virtual machines. Once Kubernetes is involved, it will validate the node with health checks. A node will be ignored until these health checks are passed. Note that Kubernetes will keep checking nodes until they are valid. 

=== Kubelet

Each node has a kubelet that works as directed by a container manifest; a YAML file that describes a pod. The kubelet uses a set of manifests and ensures that the containers described start and continue to run. A sample manifest can be found https://cloud.google.com/compute/docs/containers/container_vms#container_manifest[here].

There are a number of ways that a container manifest can be provided to a kubelet:

* A file path on the command line. The file is checked every twenty seconds.
* A HTTP endpoint passed on the command line. The endpoint is checked every twenty seconds.
* The kubelet will watch an etcd server, such as `[filename]#/registry/hosts/$(hostname -f)#`. Any changes are noticed and acted upon.
* The kublet will listen for HTTP and respond to a simple API tp submit a new manifest.

=== Service Proxy

Each node also runs a simple network proxy. This reflects the services defined in the API on each node and can do simple TCP and UDP stream forwarding (round robin) across a set of backends.