= HTTP Remote Command Execution
{product-author}
{product-version}
:data-uri:
:icons:
:experimental:
:toc: macro
:toc-title:

toc::[]

== Overview

OpenShift takes advantage of a feature built into Kubernetes to support executing commands in containers. This is implemented using HTTP along with a multiplexed streaming protocol such as link:http://www.chromium.org/spdy[SPDY] or link:https://http2.github.io/[HTTP/2].

== Client Operation

=== CLI
Support for remote container command execution is built into the `kubectl` command:

----
kubectl exec -p <pod> [-c <container>] -- <command> [<arg 1> ... <arg n>]
----

=== Protocol
Clients initiate the execution of a remote command in a container by issuing a request to the Kubernetes API server:

----
/proxy/minions/node123.openshift.com/exec/myns/mypod/mycontainer?command=date
----

In the above URL:

* `node123.openshift.com` is the node name
* `myns` is the target pod's namespace
* `mypod` is the target pod's name
* `mycontainer` is the target container's name
* `command=date` is the desired command to be executed

Additionally, the client can add parameters to the request to indicate if:

* the client should send input to the remote container's command (stdin).
* the client's terminal is a TTY.
* the remote container's command should send output from stdout to the client.
* the remote container's command should send output from stderr to the client.

After sending an `exec` request to the API server, the client upgrades the connection to one that supports multiplexed streams; the current implementation uses SPDY.

The client creates one stream each for stdin, stdout, and stderr. To distinguish among the streams, the client sets the `streamType` header on the stream to one of `stdin`, `stdout`, or `stderr`.

The client should close all streams, the upgraded connection, and the underlying connection when it is finished with the remote command execution request.

== Server Operation
The Kubelet handles remote execution requests from clients. Upon receiving a request, it upgrades the response, evaluates the request headers to determine what streams (`stdin`, `stdout`, `stderr`) to expect to receive, and waits for the client to create the streams.

After the Kubelet has received all the streams, it executes the command in the container, copying between the streams and the command's stdin, stdout, and stderr, as appropriate. When the command terminates, the Kubelet closes the upgraded connection, as well as the underlying one.

=== Executing a Command in a Container
There are a few different options for running a command in a container. The current implementation invokes `nsenter` directly on the host (node) to enter the container's namespaces prior to executing the command. Other options include using `docker exec` and running a "helper" container that then runs `nsenter` (so `nsenter` isn't a required binary that must be installed on the host).
