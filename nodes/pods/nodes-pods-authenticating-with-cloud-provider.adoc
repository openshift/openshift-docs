[id="nodes-pods-authenticating-with-cloud-provider"]
= Allowing pods to authenticate with a cloud provider
include::modules/common-attributes.adoc[]
:context: nodes-pods-authenticating-with-cloud-provider

toc::[]

Pods that require authentication with a cloud provider before being integrated with {product-title} must be mutated using a pod webhook.

include::modules/creating-eks-pod-identity-webhook.adoc[leveloffset=+1]

[id="configuring-windows-container-workloads_{context}"]
== Configuring Windows container workloads

To ensure workloads that are scheduled on Windows nodes have the right environment variables, you must use a node selector to target Windows as the operating system.

include::modules/scheduling-windows-workloads-node-selector.adoc[leveloffset=+2]

////
. Injecting `AWS_DEFAULT_REGION`

When the `aws-default-region` argument is set, this webhook injects `AWS_DEFAULT_REGION` and `AWS_REGION` in mutated containers if `AWS_DEFAULT_REGION` and `AWS_REGION` are not already set.

.`amazon-eks-pod-identity-webhook` arguments
[cols="30,70"]
|===
|Option |Definition

|--alsologtostderr
|Sends logs to both the standard error and files.

|--annotation-prefix
|The service account annotation (string) to look for. Default: `eks.amazonaws.com`

|--aws-default-region
|If set, `AWS_DEFAULT_REGION` and `AWS_REGION` will be set to this string value in mutated containers.

|--in-cluster
|If set to `true`, uses the in-cluster authentication and certificate request API. Default: `true`

|--kube-api string
|(out-of-cluster) The URL to the API server.

|--kubeconfig
|(out-of-cluster) The absolute path (string) to the API server `kubeconfig` file.

|--log_backtrace_at traceLocation
|When logging reaches the line `file:N`, a stack trace is emitted. Default: `0`

|--log_dir
|Specifies the directory (string) to write log files.

|--log_file
|Specifies the log file (string) to use.

|--log_file_max_size
|Defines the maximum size (megabytes) a log file can grow to. If the value is `0`, the maximum file size is unlimited. Default: `1800`

|--logtostderr
|Logs to standard error instead of to files. Default: `true`

|--namespace
|(in-cluster)
|The namespace name (string) this webhook and the `tls secret` reside in. Default: `eks`

|--port
|The port to listen on. Default: `443`

|--service-name
|(in-cluster) The service name (string) fronting this webhook. Default: `pod-identity-webhook`

|--skip_headers
|If set to `true`, does not display header prefixes in the log messages.

|--skip_log_headers
|If set to `true`, does not display headers when opening log files.

|--stderrthreshold severity
|Logs at or above the specified threshold go to stderr. Default: `2`

|--tls-cert string
|(out-of-cluster) TLS certificate file path. Default: `/etc/webhook/certs/tls.cert`

|--tls-key string
|(out-of-cluster) TLS key file path. Default: `/etc/webhook/certs/tls.key`

|--tls-secret string
|(in-cluster) The secret name for storing the TLS serving certificate. Default: `pod-identity-webhook`

|--token-audience string
|The default audience for tokens. This can be overridden by annotation. Default: `sts.amazonaws.com`

|--token-expiration int
|The token expiration. Default: `86400`

|--token-mount-path string
|The path to mount tokens. Default: `/var/run/secrets/eks.amazonaws.com/serviceaccount`

|--v Level
|The number for the log level verbosity.

|--version
|Displays the version and exit.

|--vmodule moduleSpec
|A comma delimited list of `pattern=N` settings for file-filtered logging.
|===

[id="rosa-in-cluster-installation_{context}"]
= In-cluster installation

The in-cluster installation of the Amazon EKS webhook lets you use the provided configuration files in the `deploy` directory, along with the provided `Makefile`.

This command:
+
* Creates a service account, role, cluster-role, role-binding, and cluster-role-binding that the deployment requires
* Creates the deployment, service, and mutating webhook in the cluster
* Approves the CSR that the deployment creates for its TLS serving certificate

[source, terminal]
----
make cluster-up IMAGE=602401143452.dkr.ecr.us-west-2.amazonaws.com/eks/pod-identity-webhook:latest
----

[id="self-hosted-setup_{context}"]
= Self-hosted Kubernetes configuration

If a self-hosted Kubernetes cluster is being used, configure the API server.

.Prerequisites

This feature requires Kubernetes 1.12 or greater.

.Procedure

To configure a self-hosted cluster:

. Configure a new key pair for signing and verifying projected service account tokens using the following `ssh-keygen` commands:

[source.terminal]
----
# Generate the keypair
PRIV_KEY="sa-signer.key"
PUB_KEY="sa-signer.key.pub"
PKCS_KEY="sa-signer-pkcs8.pub"
# Generate a key pair
ssh-keygen -t rsa -b 2048 -f $PRIV_KEY -m pem
# convert the SSH pubkey to PKCS8
ssh-keygen -e -m PKCS8 -f $PUB_KEY > $PKCS_KEY
----

. As of 1.16, Kubernetes does not include an OIDC discovery endpoint itself (see link:https://github.com/kubernetes/enhancements/pull/1190[kubernetes/community#1190]), so you must put the public signing key somewhere that AWS STS can discover it. This example creates a signing key in a public S3 bucket, but you can host these documents in a different domain.

.. Create an S3 bucket:
+
[source.terminal]
----
# Create S3 bucket with a random name. Feel free to set your own name here
export S3_BUCKET=${S3_BUCKET:-oidc-test-$(cat /dev/random | LC_ALL=C tr -dc "[:alpha:]" | tr '[:upper:]' '[:lower:]' | head -c 32)}
# Create the bucket if it doesn't exist
_bucket_name=$(aws s3api list-buckets  --query "Buckets[?Name=='$S3_BUCKET'].Name | [0]" --out text)
if [ $_bucket_name == "None" ]; then
    if [ "$AWS_REGION" == "us-east-1" ]; then
        aws s3api create-bucket --bucket $S3_BUCKET
    else
        aws s3api create-bucket --bucket $S3_BUCKET --create-bucket-configuration LocationConstraint=$AWS_REGION
    fi
fi
echo "export S3_BUCKET=$S3_BUCKET"
export HOSTNAME=s3-$AWS_REGION.amazonaws.com
export ISSUER_HOSTPATH=$HOSTNAME/$S3_BUCKET
----

.. Create the OIDC discovery and keys documents. Part of the OIDC spec is to host an OIDC discovery and a `keys.json` document, for example:
+
[source.terminal]
----
cat <<EOF > discovery.json
{
    "issuer": "https://$ISSUER_HOSTPATH/",
    "jwks_uri": "https://$ISSUER_HOSTPATH/keys.json",
    "authorization_endpoint": "urn:kubernetes:programmatic_authorization",
    "response_types_supported": [
        "id_token"
    ],
    "subject_types_supported": [
        "public"
    ],
    "id_token_signing_alg_values_supported": [
        "RS256"
    ],
    "claims_supported": [
        "sub",
        "iss"
    ]
}
EOF
----
+
Included in this repository is a small `go` file to help create the `keys.json` document.

+
[source.terminal]
----
go run ./hack/self-hosted/main.go -key $PKCS_KEY  | jq '.keys += [.keys[0]] | .keys[1].kid = ""' > keys.json
----
+
[NOTE]
This command prints the same key twice, once with an empty `kid` and once with a populated `kid`. Prior to Kubernetes 1.16 (PR #78502), the API server did not add a `kid` value to projected tokens. In 1.16+, the `kid` is included. By printing the key twice, you can safely upgrade a cluster to 1.16. Graceful signing key rotation is not possible prior to 1.16 since tokens were always signed with the same empty `kid` value, even if they used different public keys.

.. After you have the `keys.json` and `discovery.json` files, place them in your bucket. These objects must be public so that STS can access them.
+
[source.terminal]
----
aws s3 cp --acl public-read ./discovery.json s3://$S3_BUCKET/.well-known/openid-configuration
aws s3 cp --acl public-read ./keys.json s3://$S3_BUCKET/keys.json
----

. Configure the Kubernetes API server. As of Kubernetes 1.12, Kubernetes can issue and mount projected service account tokens in pods.
+
In order to use this feature, set the following API server flags:
+
[source,terminal]
----
# Path to the $PUB_KEY file from the beginning.
#
# This flag can be specified for multiple times.
# There is likely already one specified for legacy service accounts, if not,
# it is using the default value. Find out your default value and pass it explicitly
# (along with this $PUB_KEY), otherwise your existing tokens will fail.
--service-account-key-file

# Path to the signing (private) key ($PRIV_KEY)
--service-account-signing-key-file

# Identifiers of the API. The service account token authenticator will validate
# that tokens used against the API are bound to at least one of these audiences.
# If the --service-account-issuer flag is configured and this flag is not, this
# field defaults to a single element list containing the issuer URL.
#
# `--api-audiences` is for v1.13+, `--service-account-api-audiences` in v1.12
--api-audiences

# The issuer URL, or "https://$ISSUER_HOSTPATH" from above.
--service-account-issuer
----

. Set the audience. In the previous step, ``--api-audiences` flag sets an `aud` value for tokens that do not request an audience, and the API server requires that any projected tokens used for pod to API server authentication must have this audience set. This can typically be set to `kubernetes.svc.default`, or optionally the DNS name of your API server.
+
When using a Kubernetes-issued token for an external system, use a different audience (in OAuth-2 this is the `client-id`). The external system (such as AWS IAM) usually requires an audience, or client-id, at setup. For AWS IAM, a token's `aud` value must match the OIDC Identity Provider's client ID. EKS uses the string `sts.amazonaws.com` as the default, but when using the webhook, you can use any audience because the webhook's `--token-audience` value is set to the same value as your IDP in IAM.

. Create the provider. Follow the process in the link:https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html[EKS documentation] and substitute the cluster issuer with `https://$ISSUER_HOSTPATH`.
////