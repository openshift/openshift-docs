[[using-images-s2i-images-python]]
= Python
{product-author}
{product-version}
:data-uri:
:icons:
:experimental:
:toc: macro
:toc-title:

toc::[]

== Overview
{product-title} provides
xref:../../architecture/core_concepts/builds_and_image_streams.adoc#source-build[S2I]
enabled Python images for building and running Python applications.
ifndef::openshift-enterprise[]
The https://github.com/openshift/sti-python[Python S2I builder image]
endif::openshift-enterprise[]
ifdef::openshift-enterprise[]
The Python S2I builder image
endif::openshift-enterprise[]
assembles your application source with any required dependencies to create a
new image containing your Python application. This resulting image can be run
either by {product-title} or by Docker.

[[s2i-images-python-versions]]
== Versions
Currently, {product-title} provides versions
link:https://github.com/openshift/sti-python/tree/master/2.7[2.7],
link:https://github.com/openshift/sti-python/tree/master/3.3[3.3],
link:https://github.com/openshift/sti-python/tree/master/3.4[3.4], and
https://github.com/openshift/sti-python/tree/master/3.5[3.5] of Python.

[[s2i-images-python-images]]
== Images

ifdef::openshift-online[]
RHEL 7 images are available through the Red Hat Registry:

----
$ docker pull registry.access.redhat.com/rhscl/python-27-rhel7
$ docker pull registry.access.redhat.com/openshift3/python-33-rhel7
$ docker pull registry.access.redhat.com/rhscl/python-34-rhel7
$ docker pull registry.access.redhat.com/rhscl/python-35-rhel7
----

You can use these images through the `python` image stream.
endif::openshift-online[]

ifndef::openshift-online[]
These images come in two flavors, depending on your needs:

* RHEL 7
* CentOS 7

*RHEL 7 Based Images*

The RHEL 7 images are available through the Red Hat Registry:

----
$ docker pull registry.access.redhat.com/rhscl/python-27-rhel7
$ docker pull registry.access.redhat.com/openshift3/python-33-rhel7
$ docker pull registry.access.redhat.com/rhscl/python-34-rhel7
$ docker pull registry.access.redhat.com/rhscl/python-35-rhel7
----

*CentOS 7 Based Images*

These images are available on Docker Hub:

----
$ docker pull centos/python-27-centos7
$ docker pull openshift/python-33-centos7
$ docker pull centos/python-34-centos7
$ docker pull centos/python-35-centos7
----

To use these images, you can either access them directly from these
xref:../../architecture/infrastructure_components/image_registry.adoc#architecture-infrastructure-components-image-registry[image
registries] or push them into your
xref:../../architecture/infrastructure_components/image_registry.adoc#integrated-openshift-registry[{product-title}
Docker registry]. Additionally, you can create an
xref:../../architecture/core_concepts/builds_and_image_streams.adoc#image-streams[image
stream] that points to the image, either in your Docker registry or at the
external location. Your {product-title} resources can then reference the
ImageStream. You can find
https://github.com/openshift/origin/tree/master/examples/image-streams[example
image stream definitions] for all the provided {product-title} images.
endif::openshift-online[]

[[s2i-images-python-build-process]]
== Build Process
The following files in your source repository affects the behavior of the build process:

* `requirements.txt` - List of dependencies to be installed with pip. The format is documented in  link:https://pip.pypa.io/en/latest/user_guide.html#requirements-files[pip documentation].
* `setup.py` - Configures various aspects of the project, including installation of dependencies and other similar tasks as documented in the link:https://packaging.python.org/tutorials/distributing-packages/#setup-py[Python Packaging and Distributing Projects] user guide.

For most projects, it is sufficient to use `requirements.txt`, if it is present `setup.py` is not processed by default, or you can use the `-e` flag to trigger its processing.

S2I produces ready-to-run images by injecting source code into a container and letting the container prepare that source code for execution. Source-to-image performs the following steps:

. Starts a container from the builder image with the application source injected into a known directory.
. The container process transforms that source code into the appropriate runnable setup - in this case, by installing dependencies with `requirements.txt`.
. Commit the new container and set the image entrypoint to be a script (provided by the builder image) that will start Apache to host the Ruby application.

[[s2i-images-python-run-strategies]]
== Run Strategies
The Docker image produced by s2i-python executes your project in one of the following ways, in precedence order:

. *Gunicorn*:
+
The Gunicorn WSGI HTTP server is used to serve your application in the case that it is installed. It can be installed by listing it either in the `requirements.txt` file or in the _install_requires_ section of the `setup.py` file.
+
If a file named `wsgi.py` is present in your repository, it will be used as the entry point to your application. This can be overridden with the environment variable *_APP_MODULE_*. This file is present in Django projects by default.
+
If you have both Django and Gunicorn in your requirements, your Django project will automatically be served using Gunicorn.

. *Django development server*:
+
If you have Django in your requirements but don't have Gunicorn, then your application will be served using Django's development web server. However, this is not recommended for production environments.

. *Python script*:
+
This would be used where you provide a Python code file for running you application. It will be used in the case where you specify a path to a Python script via the APP_FILE environment variable, defaulting to a file named app.py if it exists. The script is passed to a regular Python interpreter to launch your application.

. *Application script file*:
This is the most general way of executing your application. It will be used in the case where you specify a path to an executable script file via the APP_SCRIPT environment variable, defaulting to a file named app.sh if it exists. The script is executed directly to launch your application.

[[s2i-images-python-configuration]]
== Configuration
The Python image supports a number of environment variables which can be set to
control the configuration and behavior of the Python runtime.

To set these environment variables as part of your image, you can place them into
xref:../../dev_guide/builds/build_strategies.adoc#environment-files[a *_.s2i/environment_* file]
inside your source code repository, or define them in
xref:../../dev_guide/builds/build_strategies.adoc#buildconfig-environment[the environment
section] of the build configuration's `*sourceStrategy*` definition.

You can also set environment variables to be used with an existing image when
xref:../../dev_guide/application_lifecycle/new_app.adoc#specifying-environment-variables[creating new
applications], or by
xref:../../dev_guide/environment_variables.adoc#set-environment-variables[updating
environment variables for existing objects] such as deployment configurations.

[NOTE]
====
Environment variables that control build behavior must be set as part of the s2i build
configuration or in the *_.s2i/environment_* file to make them available to the build
steps.
====

.Python Environment Variables
[cols="4a,6a",options="header"]
|===

|Variable name |Description

|`*APP_FILE*`
|This variable specifies the file name passed to the
python interpreter which is responsible for launching the application. This variable is set to *_app.py_* by default.

|`*APP_MODULE*`
|This variable specifies the WSGI callable. It follows the pattern
`$(MODULE_NAME):$(VARIABLE_NAME)`, where the module name is a full dotted path and
the variable name refers to a function inside the specified module. If you use
`setup.py` for installing the application, then the module name can be read from
that file and the variable defaults to `application`. There is an example
https://github.com/openshift/sti-python/tree/master/3.3/test/setup-test-app[setup-test-app]
available.

|`*APP_CONFIG*`
|This variable indicates the path to a valid Python file with a
http://docs.gunicorn.org/en/latest/configure.html[gunicorn configuration].


|`*DISABLE_COLLECTSTATIC*`
| Set it to a nonempty value to inhibit the execution of `manage.py collectstatic`
during the build. Only affects Django projects.

|`*DISABLE_MIGRATE*`
| Set it to a nonempty value to inhibit the execution of `manage.py migrate`
when the produced image is run. Only affects Django projects.

|`*PIP_INDEX_URL*`
| Set this variable to use a custom index URL or mirror to download required
packages during build process. This only affects packages listed in the
*_requirements.txt_* file.

| `*WEB_CONCURRENCY*`
| Set this to change the default setting for the number of
http://docs.gunicorn.org/en/stable/settings.html#workers[workers]. By default,
this is set to the number of available cores times 4.
|===

[[python-hot-deploy]]

== Hot Deploying
Hot deployment allows you to quickly make and deploy changes to your application
without having to generate a new S2I build. If you are using Django, hot
deployment works out of the box.

To enable hot deployment while using Gunicorn, ensure you have a Gunicorn
configuration file inside your repository with
https://gunicorn-docs.readthedocs.org/en/latest/settings.html#reload[the
`*reload*` option] set to *true*. Specify your configuration file using the
`*APP_CONFIG*` environment variable. For example, see the
xref:../../dev_guide/application_lifecycle/new_app.adoc#specifying-environment-variables[`oc new-app`]
command. You can use the
xref:../../dev_guide/environment_variables.adoc#set-environment-variables[`oc set env`]
command to update environment variables of existing objects.

[WARNING]
====
You should only use this option while developing or debugging; it is not
recommended to turn this on in your production environment.
====

To change your source code in a running pod, use the
xref:../../cli_reference/basic_cli_operations.adoc#troubleshooting-and-debugging-cli-operations[`oc rsh`]
command to enter the container:

----
$ oc rsh <pod_id>
----

After you enter into the running container, your current directory is set to
*_/opt/app-root/src_*, where the source code is located.

ifdef::openshift-online[]
[[python-templates]]
== Python Templates

{product-title} includes an example template to deploy a
link:https://github.com/openshift/nodejs-ex[sample Django application].
This template builds and deploys the sample application on Python 3.5 with a
PostgreSQL database using a persistent volume for storage.

The sample application can be built and deployed using the
`rhscl/python-35-rhel7` image with the following command:

----
$ oc new-app --template=django-psql-persistent
----
endif::openshift-online[]
