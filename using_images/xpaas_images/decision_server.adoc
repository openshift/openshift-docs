= Decision Server xPaaS Image
{product-author}
{product-version}
:data-uri:
:icons:
:experimental:
:toc: macro
:toc-title:

toc::[]

== Overview

Decision Server is available as a containerized xPaaS image that is designed for use with OpenShift as an execution environment for business rules.  Developers can quickly build, scale, and test applications deployed across hybrid environments.

[IMPORTANT]
There are significant differences in supported configurations and functionality
in the Decision Server xPaaS image compared to the regular release of JBoss BRMS.

This topic details the differences between the Decision Server xPaaS image and the
regular release of JBoss BRMS, and provides instructions specific to running and
configuring the Decision Server xPaaS image. Documentation for other JBoss BRMS
functionality not specific to the Decision Server xPaaS image can be found in the
https://access.redhat.com/documentation/en/red-hat-jboss-brms/[JBoss
BRMS documentation on the Red Hat Customer Portal].

`_EAP_HOME_` in this documentation, as in the
https://access.redhat.com/documentation/en/red-hat-jboss-brms/[JBoss
BRMS documentation], is used to refer to the JBoss EAP installation directory 
where the decision server is deployed. The location of `_EAP_HOME_` inside a 
Decision Server xPaaS image is *_/opt/eap/_*, which the `*JBOSS_HOME*` 
environment variable is also set to by default.

== Comparing the Decision Server xPaaS Image to the Regular Release of JBoss BRMS

=== Functionality Differences for OpenShift Decision Server xPaaS Images

There are several major functionality differences in the OpenShift Decision Server xPaaS image:

* The Decision Server image extends the Openshift EAP image, and any capabilities or limitations it has are also found in the Decision Server image.
* Only stateless scenarios are supported.
* Execution of business processes are not supported.
* Authoring of business rules are not supported.

[[Managing-OpenShift-Decision-Server-xPaaS-Images]]
=== Managing OpenShift Decision Server xPaaS Images

As the Decision Server image is built off the OpenShift JBoss EAP xPaaS image, the JBoss EAP Management CLI
is accessible from within the container for troubleshooting purposes.  

. First open a remote shell session to the running pod:
+
----
$ oc rsh <pod_name>
----
+
. Then run the following from the remote shell session to launch the JBoss EAP
Management CLI:
+
----
$ /opt/eap/bin/jboss-cli.sh
----

[WARNING]
Any configuration changes made using the JBoss EAP Management CLI on a running container will be lost when the container restarts.

link:#Making-Configuration-Changes-Decision-Server[Making configuration changes to the
JBoss EAP instance inside the JBoss EAP xPaaS image] is different from the process you may be used to for a regular release of JBoss EAP.

[[Security-Openshift-Decision-Server-xPaaS-Image]]
=== Security in the OpenShift Decision Server xPaaS Image

Access is limited to users with the *_kie-server_* authorization role.  A user with this role
can be specified via the *_KIE_SERVER_USER_* and *_KIE_SERVER_PASSWORD_* environment variables.

== Installing the Decision Server xPaaS Image Streams and Application Templates

To use the Red Hat xPaaS middleware images in your OpenShift project, you must
first
link:../../install_config/install/first_steps.html#creating-image-streams-for-xpaas-middleware-images[install
the image streams] and
link:../../install_config/install/first_steps.html#creating-instantapp-templates[Source-to-Image
(S2I) application templates].


[[Making-Configuration-Changes-Decision-Server]]
== Running and Configuring the Decision Server xPaaS Image

You can make changes to the Decision Server configuration in the xPaaS image using either the S2I templates, or by using a modified Decision Server image.

=== Using the Decision Server xPaaS Image Source-to-Image (S2I) Process

The recommended method to run and configure the OpenShift Decision Server xPaaS image is to use the OpenShift S2I process together with the application template parameters and environment variables.

The S2I process for the Decision Server xPaaS image works as follows:

. If there is a *_pom.xml_* file in the source repository, a Maven build is triggered with the contents of `*$MAVEN_ARGS*` environment variable.
+
* By default, the `package` goal is used with the `openshift` profile, including the system properties for skipping tests (`*-DskipTests*`) and enabling the Red Hat GA repository (`*-Dcom.redhat.xpaas.repo.redhatga*`).
+
. The results of a successful Maven build are installed into the local Maven repository, *_/home/jboss/.m2/repository/_*, along with all dependencies for offline usage.  The Decision Server xPaaS Image will load the created kjars from this local repository.
+
* In addition to being placed in the local Maven repository the resulting kjars are placed into *_EAP_HOME/standalone/deployments_*. This includes all JAR, WAR, and EAR files from the directory within the source repository specified by `*$ARTIFACT_DIR*` environment variable. The default value of `*$ARTIFACT_DIR*` is the *_target_* directory.
+
. Any JAR, WAR, and EAR in the *_deployments_* source repository directory will be copied to the *_EAP_HOME/standalone/deployments_* directory and subsequently deployed using the JBoss EAP deployment scanner.
+
. All files in the *_configuration_* source repository directory are copied to *_EAP_HOME/standalone/configuration_*.
+
[NOTE]
If you want to use a custom JBoss EAP configuration file, it should be named *_standalone-openshift.xml_*.
. All files in the *_modules_* source repository directory are copied to *_EAP_HOME/modules_*.

=== Using a Modified Decision Server xPaaS Image

An alternative method is to make changes to the image, and then use that modified image in OpenShift.  The templates currently provided, along with the interfaces they support, are listed below:

.Provided Templates
[options="header"]
|=====================================
| Template Name | Supported Interfaces
| *_decisionserver62-basic-s2i.json_* | http-rest, jms-hornetq
| *_decisionserver62-https-s2i.json_* | http-rest, https-rest, jms-hornetq
| *_decisionserver62-amq-s2i.json_* | http-rest, https-rest, jms-activemq
|=====================================

You can run the Decision Server xPaaS image in Docker, make the required configuration changes using the JBoss EAP Management CLI (*_EAP_HOME/bin/jboss-cli.sh_*) included in the Decision Server xPaaS image, and then commit the changed container as a new image. You can then use that modified image in OpenShift.

[IMPORTANT]
It is recommended that you do not replace the OpenShift placeholders in the JBoss EAP xPaaS configuration file, as they are used to automatically configure services (such as messaging, datastores, HTTPS) during a container's deployment. These configuration values are intended to be set using environment variables.

[NOTE]
Ensure that you follow the   link:../../creating_images/guidelines.html[guidelines for creating images].

=== Updating Rules 

As each image is built from a snapshot of a specific Maven repository, whenever a new rule is added, or an existing rule modified, a new image must be created and deployed for the rule modifications to take effect.  

[[Endpoints]]
== Endpoints

Clients can access the Decision Server xPaaS Image via multiple endpoints; by default the provided templates include support for REST, HornetQ, and ActiveMQ.

=== REST

Clients can use the https://access.redhat.com/documentation/en-US/Red_Hat_JBoss_BRMS/6.2/html-single/User_Guide/index.html#The_REST_API_for_Managing_the_Realtime_Decision_Server[REST API] in various ways:

==== Browser

. Current server state: http://host/kie-server/services/rest/server
. List of containers: http://host/kie-server/services/rest/server/containers
. Specific container state: http://host/kie-server/services/rest/server/containers/HelloRulesContainer

==== Java

[source,java]
----
// HelloRulesClient.java
KieServicesConfiguration config = KieServicesFactory.newRestConfiguration(
  "http://host/kie-server/services/rest/server", "kieserverUser", "kieserverPassword");
config.setMarshallingFormat(MarshallingFormat.XSTREAM);
RuleServicesClient client =
  KieServicesFactory.newKieServicesClient(config).getServicesClient(RuleServicesClient.class);
ServiceResponse<String> response = client.executeCommands("HelloRulesContainer", myCommands);
----

==== Command Line

[source,bash]
----
# request.sh
#!/bin/sh
curl -X POST \
  -d @request.xml \
  -H "Accept:application/xml" \
  -H "X-KIE-ContentType:XSTREAM" \
  -H "Content-Type:application/xml" \
  -H "Authorization:Basic a2llc2VydmVyOmtpZXNlcnZlcjEh" \
  -H "X-KIE-ClassType:org.drools.core.command.runtime.BatchExecutionCommandImpl" \
http://host/kie-server/services/rest/server/containers/instances/HelloRulesContainer
----

[source,xml]
----
<!-- request.xml -->
<batch-execution lookup="HelloRulesSession">
  <insert>
    <org.openshift.quickstarts.decisionserver.hellorules.Person>
      <name>errantepiphany</name>
    </org.openshift.quickstarts.decisionserver.hellorules.Person>
  </insert>
  <fire-all-rules/>
  <query out-identifier="greetings" name="get greeting"/>
</batch-execution>
----

=== JMS

Client can also use the Java Messaging Service, as demonstrated below:

==== Java (HornetQ)

[source,java]
----
// HelloRulesClient.java
Properties props = new Properties();
props.setProperty(Context.INITIAL_CONTEXT_FACTORY,
  "org.jboss.naming.remote.client.InitialContextFactory");
props.setProperty(Context.PROVIDER_URL, "remote://host:4447");
props.setProperty(Context.SECURITY_PRINCIPAL, "kieserverUser");
props.setProperty(Context.SECURITY_CREDENTIALS, "kieserverPassword");
InitialContext context = new InitialContext(props);
KieServicesConfiguration config =
  KieServicesFactory.newJMSConfiguration(context, "hornetqUser", "hornetqPassword");
config.setMarshallingFormat(MarshallingFormat.XSTREAM);
RuleServicesClient client =
  KieServicesFactory.newKieServicesClient(config).getServicesClient(RuleServicesClient.class);
ServiceResponse<String> response = client.executeCommands("HelloRulesContainer", myCommands);
----

==== Java (ActiveMQ)

[source,java]
----
// HelloRulesClient.java
props.setProperty(Context.INITIAL_CONTEXT_FACTORY,
  "org.apache.activemq.jndi.ActiveMQInitialContextFactory");
props.setProperty(Context.PROVIDER_URL, "tcp://host:61616");
props.setProperty(Context.SECURITY_PRINCIPAL, "kieserverUser");
props.setProperty(Context.SECURITY_CREDENTIALS, "kieserverPassword");
InitialContext context = new InitialContext(props);
ConnectionFactory connectionFactory = (ConnectionFactory)context.lookup("ConnectionFactory");
Queue requestQueue = (Queue)context.lookup("dynamicQueues/queue/KIE.SERVER.REQUEST");
Queue responseQueue = (Queue)context.lookup("dynamicQueues/queue/KIE.SERVER.RESPONSE");
KieServicesConfiguration config = KieServicesFactory.newJMSConfiguration(
  connectionFactory, requestQueue, responseQueue, "activemqUser", "activemqPassword");
config.setMarshallingFormat(MarshallingFormat.XSTREAM);
RuleServicesClient client =
  KieServicesFactory.newKieServicesClient(config).getServicesClient(RuleServicesClient.class);
ServiceResponse<String> response = client.executeCommands("HelloRulesContainer", myCommands);
----

== Troubleshooting

In addition to viewing the OpenShift logs, you can troubleshoot a running Decision Server xPaaS Image container by viewing its logs.  These are outputted to the container's standard out, and are accessible with the following command:

----
$ oc logs -f <pod_name> <container_name>
----

[NOTE]
By default, the OpenShift Decision Server xPaaS image does not have a file log handler configured. Logs are only sent to the container's standard out.
