// Module included in the following assemblies:
//
// * storage/understanding-persistent-storage.adoc
//* microshift_storage/understanding-persistent-storage-microshift.adoc
// * nodes/pods/nodes-pods-reduce-timeouts.adoc

[id="using_fsGroup_{context}"]
= Using the spc_t to reduce pod timeouts

If you elevate pods and their associated containers to super privielged, those pods and containers not constrained by SELinux policies, such as relabeling. When this option is configured, CRI-O skips the relabeling, leaving the current label in place. This can prevent the delays due to SELinux relabeling that can occur in storage volumes that contains many files (~1,000,000 or greater) 

To elevate these pods and containers, you can use security context constraints (SCC) permission to setting the `spc_t` SELinux type. The following security context makes the associated pods and containers super privileged and only allows relabeling only if the permission and ownership of root directory does not match with expected permissions of the volume: 

.Example deployment spec
[source,terminal]
----
apiVersion: apps/v1
kind: Deployment
...
spec:
  template:
    spec:
      securityContext:
        seLinuxOptions:
          fsGroupChangePolicy: OnRootMismatch
          type: "spc_t"
...
----

[IMPORTANT]
====
Having super privileged pods and containers can introduce vulnerabilities. If the super privileged pods are not running with the `restricted` SCC, the container could possibly access any file on the host. To prevent this vulnerability, ensure the pods are using an SCC that has `runAsUser` set to `MustRunAsRange`. This setting completely constrains file access. A container process running as a random UID and has no rights to modify anything on the host, although it could read world-readable files. The default for {product-title} is to run containers with the restricted SCC.

If the pods are running with an SCC that has `runAsUser` set to `runAsAny`, file access is unconstrained, allowing a container process to be able to overwrite files on the host.
====


.Procedure

. Create a `SecurityContextConstraints` CR YAML file:
+
[source,yaml]
----
allowHostDirVolumePlugin: false
allowHostIPC: false
allowHostNetwork: false
allowHostPID: false
allowHostPorts: false
allowPrivilegeEscalation: true
allowPrivilegedContainer: false
allowedCapabilities: null
apiVersion: security.openshift.io/v1
defaultAddCapabilities: null
fsGroup:
  type: MustRunAs
groups:
- system:authenticated
kind: SecurityContextConstraints <1>
metadata:
  name: custom
priority: null
readOnlyRootFilesystem: false
requiredDropCapabilities:
- KILL
- MKNOD
- SETUID
- SETGID
runAsUser:
  type: MustRunAsRange <1>
seLinuxContext:
  type: RunAsAny
supplementalGroups:
  type: RunAsAny
users: []
volumes:
- configMap
- downwardAPI
- emptyDir
- persistentVolumeClaim
- projected
- secret
----
<1> Specifies an SCC object.
<2> It is recommended to use the `MustRunAsRange` value.

. Create the object:
+
[source,terminal]
----
$ oc create -f <file_name>.yaml
----

. View the SCC:
+
[source,terminal]
----
$ oc get scc
----
+
.Example output
source,terminal]
----
NAME               PRIV    CAPS                   SELINUX     RUNASUSER          FSGROUP     SUPGROUP    PRIORITY     READONLYROOTFS   VOLUMES
...
restricted         false   <no value>             MustRunAs   MustRunAsRange     MustRunAs   RunAsAny    <no value>   false            ["configMap","csi","downwardAPI","emptyDir","ephemeral","persistentVolumeClaim","projected","secret"]
scc-for-spc-t      false   <no value>             RunAsAny    MustRunAsRange     MustRunAs   RunAsAny    <no value>   false            ["configMap","downwardAPI","emptyDir","persistentVolumeClaim","projected","secret"]
...
----

. Assign the SCC to the default service account in the project where deployment that uses Persistent Volumes with high file counts is located:
+
[source,terminal]
----
$ oc adm policy add-scc-to-user custom -z default -n <namespace>
----

Note: If you are not using default service account then change `default` with the service account used by the pods.

. Configure the SCC in the the deployment that uses Persistent Volumes with high file counts is located:
+
[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
...
spec:
  template:
    spec:
      securityContext:
        seLinuxOptions:
          fsGroupChangePolicy: OnRootMismatch <1>
          type: "spc_t" <2>
----
<1> Specifies that relabeling can happen only if the permission and ownership of root directory does not match with expected permissions of the volume.
<2> Specifies that the associated pods and containers are super privileged.
