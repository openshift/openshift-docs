// Module included in the following assemblies:
//
// * storage/understanding-persistent-storage.adoc
//* microshift_storage/understanding-persistent-storage-microshift.adoc
// * nodes/pods/nodes-pods-reduce-timeouts.adoc

[id="using_nodes-pods-reduce-timeouts-spec-t_{context}"]
= Using security context constraints to reduce pod timeouts

// based on https://access.redhat.com/solutions/6221251

You can reduce the pod timeouts that might happen if your cluster storage volume contains many files (~1,000,000 or greater), by elevating the pods and their associated containers to super privielged. Super priveleged pods and containers are not constrained by SELinux policies, such as relabeling. When this option is configured, CRI-O skips the relabeling, leaving the current label in place. 

To elevate these pods and containers, you can use security context constraints (SCC) permission to setting the `spc_t` SELinux type. The following security context makes the associated pods and containers super privileged and only allows relabeling only if the permission and ownership of root directory does not match with expected permissions of the volume: 

.Example deployment spec
[source,terminal]
----
apiVersion: apps/v1
kind: Deployment
...
spec:
  template:
    spec:
      securityContext:
        seLinuxOptions:
          fsGroupChangePolicy: OnRootMismatch
          type: "spc_t"
...
----

[IMPORTANT]
====
Having super privileged pods and containers can introduce vulnerabilities. If the super privileged pods are not running with the `restricted` SCC, the container could possibly access any file on the host. To prevent this vulnerability, ensure the pods are using an SCC that has `runAsUser` set to `MustRunAsRange`. This setting completely constrains file access. A container process running as a random UID and has no rights to modify anything on the host, although it could read world-readable files. The default for {product-title} is to run containers with the restricted SCC.

If the pods are running with an SCC that has `runAsUser` set to `runAsAny`, file access is unconstrained, allowing a container process to be able to overwrite files on the host.
====


.Procedure

. Create a `SecurityContextConstraints` CR YAML file:
+
[source,yaml]
----
allowHostDirVolumePlugin: false
allowHostIPC: false
allowHostNetwork: false
allowHostPID: false
allowHostPorts: false
allowPrivilegeEscalation: true
allowPrivilegedContainer: false
allowedCapabilities: null
apiVersion: security.openshift.io/v1
defaultAddCapabilities: null
fsGroup:
  type: MustRunAs
groups:
- system:authenticated
kind: SecurityContextConstraints <1>
metadata:
  name: scc-for-spc-t
priority: null
readOnlyRootFilesystem: false
requiredDropCapabilities:
- KILL
- MKNOD
- SETUID
- SETGID
runAsUser:
  type: MustRunAsRange <1>
seLinuxContext:
  type: RunAsAny
supplementalGroups:
  type: RunAsAny
users: []
volumes:
- configMap
- downwardAPI
- emptyDir
- persistentVolumeClaim
- projected
- secret
----
<1> Specifies an SCC object.
<2> It is recommended to use the `MustRunAsRange` value.

. Create the object:
+
[source,terminal]
----
$ oc create -f <file_name>.yaml
----

. View the SCC:
+
[source,terminal]
----
$ oc get scc
----
+
.Example output
source,terminal]
----
NAME               PRIV    CAPS                   SELINUX     RUNASUSER          FSGROUP     SUPGROUP    PRIORITY     READONLYROOTFS   VOLUMES
...
scc-for-spc-t      false   <no value>             RunAsAny    MustRunAsRange     MustRunAs   RunAsAny    <no value>   false            ["configMap","downwardAPI","emptyDir","persistentVolumeClaim","projected","secret"]
----

. Use the following command to assign the SCC to the default service account in the project where deployment that uses Persistent Volumes with high file counts is located:
+
[source,terminal]
----
$ oc adm policy add-scc-to-user custom -z default -n <namespace>
----
+
If you are not using default service account then change `default` with the service account used by the pods.

. Configure the SCC in the deployment that uses Persistent Volumes with high file counts is located:
+
[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
...
spec:
  template:
    spec:
      securityContext:
        seLinuxOptions:
          fsGroupChangePolicy: OnRootMismatch <1>
          type: "spc_t" <2>
----
<1> Specifies that relabeling can happen only if the permission and ownership of root directory does not match with expected permissions of the volume.
<2> Specifies that the associated pods and containers are super privileged.

.Verification
