// Module included in the following assemblies:
//
// * storage/understanding-persistent-storage.adoc
//* microshift_storage/understanding-persistent-storage-microshift.adoc
// * nodes/pods/nodes-pods-reduce-timeouts.adoc

[id="using_fsGroup_{context}"]
= Using the spc_t to reduce pod timeouts

If you elevate pods and their associated containers to super privielged, those pods and containers not constrained by SELinux policies, such as relabeling. When this option is configured, CRI-O skips the relabeling, leaving the current label in place. This can prevent the delays due to SELinux relabeling that can occur in storage volumes that contains many files (~1,000,000 or greater) 

To elevate these pods and containers, you can use security context constraints (SCC) permission to setting the `spc_t` SELinux type. The following security context makes the associated pods and containers super privileged and only allows relabeling only if the permission and ownership of root directory does not match with expected permissions of the volume: 

.Example deployment spec
[source,terminal]
----
apiVersion: apps/v1
kind: Deployment
...
spec:
  template:
    spec:
      securityContext:
        seLinuxOptions:
          fsGroupChangePolicy: OnRootMismatch
          type: "spc_t"
...
----

[IMPORTANT]
====
Having super privileged pods and containers can introduce vulnerabilities. If the super privileged pods are not running with the `restricted` SCC, the container could possibly access any file on the host. To prevent this vulnerability, ensure the pods are using an SCC that has `runAsUser` set to `MustRunAsRange`. This setting completely constrains file access. A container process running as a random UID and has no rights to modify anything on the host, although it could read world-readable files. The default for {product-title} is to run containers with the restricted SCC.

If the pods are running with an SCC that has `runAsUser` set to `runAsAny`, file access is unconstrained, allowing a container process to be able to overwrite files on the host.
====


.Procedure

. Create a custom SCC :

# cat custom_scc.yaml

allowHostDirVolumePlugin: false
allowHostIPC: false
allowHostNetwork: false
allowHostPID: false
allowHostPorts: false
allowPrivilegeEscalation: true
allowPrivilegedContainer: false
allowedCapabilities: null
apiVersion: security.openshift.io/v1
defaultAddCapabilities: null
fsGroup:
  type: MustRunAs
groups:
- system:authenticated
kind: SecurityContextConstraints
metadata:
  name: custom
priority: null
readOnlyRootFilesystem: false
requiredDropCapabilities:
- KILL
- MKNOD
- SETUID
- SETGID
runAsUser:
  type: MustRunAsRange
seLinuxContext:
  type: RunAsAny
supplementalGroups:
  type: RunAsAny
users: []
volumes:
- configMap
- downwardAPI
- emptyDir
- persistentVolumeClaim
- projected
- secret

$ oc create -f custom_scc.yaml

$ oc get scc

custom   false   <no value>   RunAsAny    MustRunAsRange     MustRunAs   RunAsAny    <no value>   false 
           ["configMap","downwardAPI","emptyDir","persistentVolumeClaim","projected","secret"]

restricted false   <no value>   MustRunAs   MustRunAsRange     MustRunAs   RunAsAny    <no value>   false    ["configMap","downwardAPI","emptyDir","persistentVolumeClaim","projected","secret"]

2. Assign it to the default service account in a project where deployment is stuck:

$ oc adm policy add-scc-to-user custom -z default -n <namespace>

Note: If you are not using default service account then change `default` with the service account used by the pods.

3. Then added the following changes to the deployment in securityContext :

      securityContext:
        fsGroupChangePolicy: OnRootMismatch
        seLinuxOptions:
          type: spc_t
