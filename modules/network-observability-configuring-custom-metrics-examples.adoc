// Module included in the following assemblies:
//
// network_observability/metrics-alerts-dashboards.adoc

:_mod-docs-content-type: REFERENCE
[id="network-observability-configuring-custom-metrics-examples_{context}"]
= Configuring custom metrics by using FlowMetric API examples

[role="_abstract"]
Examples of custom metrics using the `FlowMetric` API. You can add multiple `FlowMetric` resources to a project to see multiple dashboard views.

[id="example-ingress-bytes-received-from-cluster-external-resources_{context}"]
== Example to generate a metric that tracks ingress bytes received from cluster external sources

You can configure the `FlowMetric` resource to generate a metric that tracks ingress bytes received from cluster external sources, similar to the following sample configuration:

[source,yaml]
----
apiVersion: flows.netobserv.io/v1alpha1
kind: FlowMetric
metadata:
  name: flowmetric-cluster-external-ingress-traffic
  namespace: netobserv
spec:
  metricName: cluster_external_ingress_bytes_total
  type: Counter
  valueField: Bytes
  direction: Ingress
  labels: [DstK8S_HostName,DstK8S_Namespace,DstK8S_OwnerName,DstK8S_OwnerType]
  filters:
  - field: SrcSubnetLabel
    matchType: Absence
----
* `metadata.namespace` must match the namespace defined in the `FlowCollector` `spec.namespace` object. This is `netobserv` by default.
* `spec.metricName` defines the name of the Prometheus metric, which in the web console appears with the prefix `netobserv-<metricName>`.
* `spec.type` field specifies the metric type. A `Counter` is useful for counting bytes or packets.
* `spec.direction` defines the direction of traffic to capture. If not specified, both ingress and egress are captured, which can lead to duplicated counts.
* `spec.labels` defines what the metrics look like and their relationship to different entities. They also define the metric's cardinality. For example, `SrcK8S_Name` is a high-cardinality metric.
* `spec.filters` refines results based on the listed criteria. In this example,  selecting only the cluster external traffic is done by matching only flows where `SrcSubnetLabel` is absent. This assumes the subnet labels feature is enabled (via `spec.processor.subnetLabels`), which is done by default.

[id="example-for-rounnd-trip-time_{context}"]
== Example for Round-trip time

You can configure the `FlowMetric` resource to show the Round-trip time (RTT) latency for cluster external ingress traffic, similar to the following sample configuration:

[source,yaml]
----
apiVersion: flows.netobserv.io/v1alpha1
kind: FlowMetric
metadata:
  name: flowmetric-cluster-external-ingress-rtt
  namespace: netobserv
spec:
  metricName: cluster_external_ingress_rtt_seconds
  type: Histogram
  valueField: TimeFlowRttNs
  direction: Ingress
  labels: [DstK8S_HostName,DstK8S_Namespace,DstK8S_OwnerName,DstK8S_OwnerType]
  filters:
  - field: SrcSubnetLabel
    matchType: Absence
  - field: TimeFlowRttNs
    matchType: Presence
  divider: "1000000000"
  buckets: [".001", ".005", ".01", ".02", ".03", ".04", ".05", ".075", ".1", ".25", "1"]
----
* `metadata.namespace` must match the namespace defined in the `FlowCollector` `spec.namespace` object. This is `netobserv` by default.
* `spec.type` specifies the type of metric. A `Histogram` is useful for a latency value (`TimeFlowRttNs`).
* `divider` converts nanoseconds into seconds. RTT is provided in nanoseconds (`TimeFlowRttNs`) in flow logs. Use a divider of `1000000000` to convert the value into seconds, which is the standard Prometheus guideline.
* The custom buckets specify precision on RTT, with optimal precision ranging between 5ms and 250ms.