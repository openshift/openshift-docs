// Module included in the following assemblies:
//
// * virt/virtual_machines/importing_vms/virt-importing-virtual-machine-images-datavolumes.adoc
// * virt/virtual_machines/importing_vms/virt-importing-container-disk-with-datavolumes.adoc

ifeval::["{context}" == "virt-importing-virtual-machine-images-datavolumes"]
:virt-vm-image:
:object: virtual machine image
endif::[]

ifeval::["{context}" == "virt-importing-container-disk-with-datavolumes"]
:virt-container-disk:
:object: container disk
endif::[]

[id="virt-importing-vm-datavolume_{context}"]
= Importing a {object} into an object with DataVolumes

To create a virtual machine from an imported {object}, specify the image location
in the `VirtualMachine` configuration file before you create the virtual machine.

.Prerequisites

* Install the OpenShift CLI (`oc`).
ifdef::virt-vm-image[]
* A virtual machine disk image, in RAW, ISO, or QCOW2 format, optionally
compressed by using `xz` or `gz`.
* An `HTTP` endpoint where the image is hosted, along with any authentication
credentials needed to access the data source.
endif::virt-vm-image[]
ifdef::virt-container-disk[]
* An `HTTP` endpoint for the container image registry, along with any authentication
credentials needed to access the data source.
endif::virt-container-disk[]
* At least one available PersistentVolume.

.Procedure

. Identify an `HTTP` file server that hosts the {object} that you want
to import. You need the complete URL in the correct format:
+
ifdef::virt-vm-image[]
* `http://www.example.com/path/to/data`
endif::virt-vm-image[]
ifdef::virt-container-disk[]
* `docker://registry.example.com/container-image`
endif::virt-container-disk[]

. If your data source requires authentication credentials, edit the
`endpoint-secret.yaml` file, and apply the updated configuration to the cluster:
+
[source,yaml]
----
apiVersion: v1
kind: Secret
metadata:
  name: <endpoint-secret>
  labels:
    app: containerized-data-importer
type: Opaque
data:
  accessKeyId: "" <1>
  secretKey:   "" <2>
----
<1> Optional: your key or user name, base64 encoded
<2> Optional: your secret or password, base64 encoded
+
[source,terminal]
----
$ oc apply -f endpoint-secret.yaml
----

. Edit the virtual machine configuration file, specifying the data source for
the {object} you want to import. In this example, a Fedora {object} is imported:
+
[source,yaml]
----
apiVersion: kubevirt.io/v1alpha3
kind: VirtualMachine
metadata:
  creationTimestamp: null
  labels:
    kubevirt.io/vm: vm-fedora-datavolume
  name: vm-fedora-datavolume
spec:
  dataVolumeTemplates:
  - metadata:
      creationTimestamp: null
      name: fedora-dv
    spec:
      pvc:
        accessModes:
        - ReadWriteOnce
        resources:
          requests:
            storage: 2Gi
        storageClassName: local
      source:
        http:
ifdef::virt-vm-image[]
          url: https://download.fedoraproject.org/pub/fedora/linux/releases/28/Cloud/x86_64/images/Fedora-Cloud-Base-28-1.1.x86_64.qcow2 <1>
endif::virt-vm-image[]
ifdef::virt-container-disk[]
          registry: docker://registry.fedoraproject.org/fedora <1>
endif::virt-container-disk[]
          secretRef: "" <2>
          certConfigMap: "" <3>
    status: {}
  running: false
  template:
    metadata:
      creationTimestamp: null
      labels:
        kubevirt.io/vm: vm-fedora-datavolume
    spec:
      domain:
        devices:
          disks:
          - disk:
              bus: virtio
            name: datavolumedisk1
        machine:
          type: "" <4>
        resources:
          requests:
            memory: 64M
      terminationGracePeriodSeconds: 0
      volumes:
      - dataVolume:
          name: fedora-dv
        name: datavolumedisk1
status: {}
----
<1> The `HTTP` source of the {object} you want to import.
<2> The `secretRef` parameter is optional.
<3> The `certConfigMap` is required for communicating with servers that use self-signed certificates or certificates not signed by the system CA bundle. The referenced ConfigMap must be in the same namespace as the DataVolume.
<4> Specify `type: dataVolume` or `type: ""`. If you specify any other value for `type`, such as `persistentVolumeClaim`, a warning is displayed, and the virtual machine does not start.

. Create the virtual machine:
+
[source,terminal]
----
$ oc create -f vm-<name>-datavolume.yaml
----
+
[NOTE]
====
The `oc create` command creates the DataVolume and the virtual machine.
The CDI controller creates an underlying PVC with the correct annotation, and
the import process begins. When the import completes, the DataVolume status
changes to `Succeeded`, and the virtual machine is allowed to start.

DataVolume provisioning happens in the background, so there is no need to
monitor it. You can start the virtual machine, and it will not run until the
import is complete.
====

.Verification steps
. The importer Pod downloads the {object} from the specified URL and stores it on the provisioned PV. View the status of the importer Pod by running the following command:
+
[source,terminal]
----
$ oc get pods
----

. Monitor the DataVolume status until it shows `Succeeded` by running the following command:
+
[source,terminal]
----
$ oc describe dv <data-label> <1>
----
<1> The data label for the DataVolume specified in the virtual machine
configuration file.

. To verify that provisioning is complete and that the VMI has started, try
accessing its serial console by running the following command:
+
[source,terminal]
----
$ virtctl console <vm-fedora-datavolume>
----

ifeval::["{context}" == "virt-importing-virtual-machine-images-datavolumes"]
:virt-vm-image!:
:object!:
endif::[]

ifeval::["{context}" == "virt-importing-container-disk-with-datavolumes"]
:virt-container-disk!:
:object!:
endif::[]

