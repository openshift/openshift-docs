// Module included in the following assemblies:
//
// * security/zero_trust_workload_identity_manageer/zero-trust-manager-oidc-federation.adoc

:_mod-docs-content-type: PROCEDURE
[id="zero-trust-manager-initialize-vault-oidc_{context}"]

= Initializing Vault

A newly installed Vault is sealed. This means that the primary encryption key, which protects all other encryption keys, is not loaded into the server memory upon startup. You need to initialize Vault to unseal it.

The steps to initialize a Vault server are:

. Initialize and unseal Vault

. Enable the key-value (KV) secrets engine and store a test secret

. Configure JSON Web Token (JWT) authentication with SPIRE

. Deploy a demonstration application

. Authenticate and retrieve the secret

.Prerequisites

* Ensure that Vault is running.

* Ensure that Vault is not initialized. You can only initialize a Vault server once.

== Initializing and unsealing Vault

.Procedure

. Open a remote shell into the `vault` pod:
+
[source,terminal]
----
$ oc rsh -n vault statefulset/vault
----

. Initialize Vault to get your unseal key and root token:
+
[source,terminal]
----
$ vault operator init -key-shares=1 -key-threshold=1 -format=json
----

. Export the unseal key and root token you received from the earlier command:
+
[source,terminal]
----
$ export UNSEAL_KEY=<Your-Unseal-Key>
$ export ROOT_TOKEN=<Your-Root-Token>
----

. Unseal Vault using your unseal key:
+
[source,terminal]
----
$ vault operator unseal -format=json $UNSEAL_KEY
----

. Exit the pod by entering `Exit`.

.Verification

* To verify that the Vault pod is ready, run the following command:
+
[source,terminal]
----
$ oc get pod -n vault
----
+
.Example output
[source, terminal]
----
NAME        READY        STATUS      RESTARTS     AGE
vault-0     1/1          Running     0            65d
----

== Enabling the key-value secrets engine and store a test secret

.Procedure

. Open another shell session in the `Vault` pod.
+
[source,terminal]
----
$ oc rsh -n vault statefulset/vault
----

. Export your root token again within this new session and log in:
+
[source,terminal]
----
$ export ROOT_TOKEN=<Your-Root-Token>
$ vault login "${ROOT_TOKEN}"
----

. Enable the KV secrets engine at the `secret/` path and create a test secret:
+
[source,terminal]
----
$ export NAME=ztwim
$ vault secrets enable -path=secret kv
$ vault kv put secret/$NAME version=v0.1.0
----

.Verification

* To verify that the secret is stored correctly, run the following command:
+
[source,terminal]
----
$ vault kv get secret/$NAME
----

== Configuring JSON Web Token authentication with SPIRE

You need to set up JSON Web Token (JWT) authentication so your applications can securely log in to Vault by using SPIFFE identities.

.Procedure

. On your local machine, retrieve the SPIRE Certificate Authority (CA) bundle and save it to a file:
+
[source,terminal]
----
$ oc get cm -n zero-trust-workload-identity-manager spire-bundle -o jsonpath='{ .data.bundle\.crt }' > oidc_provider_ca.pem
----

. Back in the Vault pod shell, create a temporary file and paste the contents of `oidc_provider_ca.pem` into it:
+
[source,terminal]
----
$ cat << EOF > /tmp/oidc_provider_ca.pem
-----BEGIN CERTIFICATE-----
<Paste-Your-Certificate-Content-Here>
-----END CERTIFICATE-----
EOF
----

. Set up the necessary environment variables for the JWT configuration:
+
[source,terminal]
----
$ export APP_DOMAIN=<Your-App-Domain>
$ export JWT_ISSUER_ENDPOINT="oidc-discovery.$APP_DOMAIN"
$ export OIDC_URL="https://$JWT_ISSUER_ENDPOINT"
$ export OIDC_CA_PEM="$(cat /tmp/oidc_provider_ca.pem)"
----

. Enable the JWT authentication method and configure it with your OIDC provider details:
+
[source,terminal]
----
$ export ROLE="${NAME}-role"
$ vault auth enable jwt
$ vault write auth/jwt/config \
  oidc_discovery_url=$OIDC_URL \
  oidc_discovery_ca_pem="$OIDC_CA_PEM" \
  default_role=$ROLE
----

. Create a policy named `ztwim-policy` that grants read access to the secret you created earlier:
+
[source,terminal]
----
$ export POLICY="${NAME}-policy"
$ vault policy write $POLICY -<<EOF
path "secret/$NAME" {
    capabilities = ["read"]
}
EOF
----

. Create a JWT role that binds the policy to workload with a specific SPIFFE ID:
+
[source,terminal]
----
$ export APP_NAME=client
$ export APP_NAMESPACE=demo
$ export AUDIENCE=$APP_NAME
$ vault write auth/jwt/role/$ROLE -<<EOF
{
  "role_type": "jwt",
  "user_claim": "sub",
  "bound_audiences": "$AUDIENCE",
  "bound_claims_type": "glob",
  "bound_claims": {
    "sub": "spiffe://$APP_DOMAIN/ns/$APP_NAMESPACE/sa/$APP_NAME"
  },
  "token_ttl": "24h",
  "token_policies": "$POLICY"
}
EOF
----

== Deploying a demo application

This creates a simple client application that uses its SPIFFE identity to authenticate with Vault.

.Procedure

. On your local machine, set the environment variables for your application:
+
[source,terminal]
----
$ export APP_NAME=client
$ export APP_NAMESPACE=demo
$ export AUDIENCE=$APP_NAME
----

. Apply the Kubernetes manifest to create the namespace, service account, and deployment for the demo app. This deployment mounts the SPIFFE CSI driver socket.
+
[source,terminal]
----
$ oc apply -f - <<EOF
# ... (paste the full YAML from your provided code here) ...
EOF
----

.Verification

* Verify that the client deployment is ready by running the following command:
+
[source,terminal]
----
$ oc get deploy -n $APP_NAMESPACE
----
+
.Example output
[source, terminal]
----
NAME             READY        UP-TO-DATE      AVAILABLE     AGE
frontend-app     2/2          2               2             120d
backend-api      3/3          3               3             120d
----

== Authenticating and retrieving the secret

You use the demo app to fetch a JWT token from the SPIFFE Workload API and use it to log in to Vault and retrieve the secret.

.Procedure

. Run a command inside the running client pod to fetch a JWT-SVID:
+
[source,terminal]
----
$ oc -n $APP_NAMESPACE exec -it $(oc get pod -o=jsonpath='{.items[*].metadata.name}' -l app=$APP_NAME -n $APP_NAMESPACE) \
  -- /opt/spire/bin/spire-agent api fetch jwt \
  -socketPath /run/spire/sockets/spire-agent.sock \
  -audience $AUDIENCE
----

. Copy the token from the output and export it as an environment variable on your local machine:
+
[source,terminal]
----
$ export IDENTITY_TOKEN=<Your-JWT-Token>
----

. Use `curl` to send the JWT token to the Vault login endpoint to get a Vault client token:
+
[source,terminal]
----
$ export ROLE="${NAME}-role"
$ VAULT_TOKEN=$(curl -s --request POST --data '{ "jwt": "'"${IDENTITY_TOKEN}"'", "role": "'"${ROLE}"'"}' "${VAULT_ADDR}"/v1/auth/jwt/login | jq -r '.auth.client_token')
----

.Verification

* Use the newly acquired Vault token to read the secret from the KV store:
+
[source,terminal]
----
$ curl -s -H "X-Vault-Token: $VAULT_TOKEN" $VAULT_ADDR/v1/secret/$NAME | jq
----
+
You should see the contents of the secret (`"version": "v0.1.0"`) in the output, confirming the entire workflow is successful

