// Module included in the following assemblies:
//
// * storage/understanding-persistent-storage.adoc
//* microshift_storage/understanding-persistent-storage-microshift.adoc
// * nodes/pods/nodes-pods-reduce-timeouts.adoc

[id="using_nodes-pods-reduce-timeouts-auto_{context}"]
= Relabeling SELinux File Content Automatically

// Based on https://docs.google.com/document/d/1u96QZUdAZmurhPBjMue_ieyURsrM57p8gS8KqvJSvrE/edit#


You can reduce the pod timeouts that might happen if your cluster storage volume contains many files (~1,000,000 or greater), by using the Cluster Resource Override Operator (CRO) to elevate the pods and their associated containers to super privielged. Super priveleged pods and containers are not constrained by SELinux policies, such as relabeling. When this option is configured, CRI-O skips the relabeling, leaving the current label in place. 

The Cluster Resource Override Operator (CRO) has been extended to allow for you to automatically apply the `spc_t` SELinux type to pods by using a security context constraints (SCC), which elevates these pods and containers. The CRO applies the workaround by namespace and when the CRO is configured with the forceSelinuxRelabel attribute set to true.

The following security context makes the associated pods and containers super privileged and only allows relabeling only if the permission and ownership of root directory does not match with expected permissions of the volume: 

.Example deployment spec
[source,terminal]
----
apiVersion: apps/v1
kind: Deployment
...
spec:
  template:
    spec:
      securityContext:
        seLinuxOptions:
          fsGroupChangePolicy: OnRootMismatch
          type: "spc_t"
...
----




[IMPORTANT]
====
Having super privileged pods and containers can introduce vulnerabilities. If the super privileged pods are not running with the `restricted` SCC, the container could possibly access any file on the host. To prevent this vulnerability, ensure the pods are using an SCC that has `runAsUser` set to `MustRunAsRange`. This setting completely constrains file access. A container process running as a random UID and has no rights to modify anything on the host, although it could read world-readable files. The default for {product-title} is to run containers with the restricted SCC.

If the pods are running with an SCC that has `runAsUser` set to `runAsAny`, file access is unconstrained, allowing a container process to be able to overwrite files on the host.
====

.Procedure 

. Create a new namespace:

.. Create a YAML files that contains the following code:
+
[source,terminal]
----
apiVersion: v1
kind: Namespace
metadata:
 name: selinux-relabel
 labels:
   clusterresourceoverrides.admission.autoscaling.openshift.io/enabled: "true"
   forceselinuxrelabel.admission.node.openshift.io/enabled: "true"
----

.. Create the namespace:
+
[source,terminal]
----
$ oc create -f <file-name>.yaml
----
+
For example:
+
[source,terminal]
----
$ oc create -f cro-workaround-ns.yaml
----

. Install the Cluster Resource Override Operator by using the following YAML:
+
[source,yaml]
----
apiVersion: operator.autoscaling.openshift.io/v1
kind: ClusterResourceOverride
metadata:
 name: cluster
spec:
 podResourceOverride:
   spec:
     memoryRequestToLimitPercent: 100
     cpuRequestToLimitPercent: 100
     limitCPUToMemoryPercent: 100
     forceSelinuxRelabel: true
----

. Create a `SecurityContextConstraints` object:

.. Create a YAML files that contains the following code:
+
[source,yaml]
----
allowHostDirVolumePlugin: false
allowHostIPC: false
allowHostNetwork: false
allowHostPID: false
allowHostPorts: false
allowPrivilegeEscalation: true
allowPrivilegedContainer: false
allowedCapabilities: null
apiVersion: security.openshift.io/v1
defaultAddCapabilities: null
fsGroup:
  type: MustRunAs
groups:
- system:authenticated
kind: SecurityContextConstraints <1>
metadata:
  name: custom
priority: null
readOnlyRootFilesystem: false
requiredDropCapabilities:
- KILL
- MKNOD
- SETUID
- SETGID
runAsUser:
  type: MustRunAsRange <2>
seLinuxContext:
  type: RunAsAny
supplementalGroups:
  type: RunAsAny
users: []
volumes:
- configMap
- downwardAPI
- emptyDir
- persistentVolumeClaim
- projected
- secret
----
<1> Specifies an SCC object.
<2> It is recommended to use the `MustRunAsRange` value.

.. Create the object:
+
[source,terminal]
----
$ oc create -f <file_name>.yaml
----

.. View the SCC:
+
[source,terminal]
----
$ oc get scc
----
+
.Example output
[source,terminal]
----
NAME               PRIV    CAPS                   SELINUX     RUNASUSER          FSGROUP     SUPGROUP    PRIORITY     READONLYROOTFS   VOLUMES
...
scc-for-spc-t      false   <no value>             RunAsAny    MustRunAsRange     MustRunAs   RunAsAny    <no value>   false            ["configMap","downwardAPI","emptyDir","persistentVolumeClaim","projected","secret"]
----

. Use the following command to assign the SCC to the default service account in the project where deployment that uses Persistent Volumes with high file counts is located:
+
[source,terminal]
----
$ oc adm policy add-scc-to-user custom -z default -n <namespace>
----
+
where:
+
--
<namespace>:: Specifies the namespace you created. 
--
+
If you are not using default service account then change `default` with the service account used by the pods.


