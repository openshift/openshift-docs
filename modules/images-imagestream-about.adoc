// Module included in the following assemblies:
//
// * n/a

[id='architecture-component-imagestreams']
= Image streams

An image stream and its associated tags provide an abstraction for referencing
xref:../../architecture/core_concepts/containers_and_images.adoc#docker-images[container images] from within {product-title}.
The image stream and its tags allow you to see what images are available
and ensure that you are using the specific image you need even if the image in the repository changes.

Image streams do not contain actual image data, but present a single virtual view of related images, similar to an image repository.

You can  configure xref:../../dev_guide/builds/triggering_builds.adoc#image-change-triggers[Builds] and
xref:../../dev_guide/deployments/basic_deployment_operations.adoc#image-change-trigger[Deployments] to watch an image stream
for notifications when new images are added and react by performing a Build or Deployment, respectively.

For example, if a Deployment is using a certain image and a new version of that image is created,
a Deployment could be automatically performed to pick up the new version of the image.

However, if the image stream tag used by the Deployment or Build is not updated,
then even if the container image in the container image registry is updated, the Build or Deployment will continue using the previous (presumably known good) image.

The source images can be stored in any of the following:

* {product-title}'s xref:../../architecture/infrastructure_components/image_registry.adoc#integrated-openshift-registry[integrated
registry]
* An external registry, for example `registry.redhat.io` or `hub.docker.com`
* Other image streams in the {product-title} cluster

When you define an object that references an image stream tag (such as a Build or Deployment configuration), you point to an image stream tag, not the Docker repository. When you Build or Deploy your application, {product-title} queries the Docker repository using the image stream tag to locate the associated ID of the image and uses that
exact image.

The image stream metadata is stored in the etcd instance along with other cluster information.

Using image streams has several significant benefits:

* You can tag, rollback a tag, and quickly deal with images, without having to re-push using the command line.

* You can trigger Builds and Deployments when a new image is pushed to the registry. Also,
{product-title} has generic triggers for other resources (such as Kubernetes objects).

* You can xref:../../dev_guide/managing_images.adoc#importing-tag-and-image-metadata[mark a tag for periodic re-import].
If the source image has changed, that change is picked up and reflected in the image stream, which triggers the Build and/or Deployment flow, depending upon the Build or Deployment configuration.

* You can share images using fine-grained access control and quickly distribute images across your teams.

* If the source image changes, the image stream tag will still point to a known-good version of the image, ensuring that your application will not break unexpectedly.

* You can xref:../../admin_guide/manage_rbac.adoc#admin-guide-manage-rbac[configure security] around who can view and use the images through permissions on the image stream objects.

* Users that lack permission to read or list images on the cluster level can still retrieve the images tagged in a project using image streams.
