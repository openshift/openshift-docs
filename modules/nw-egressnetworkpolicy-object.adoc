// Module included in the following assemblies:
//
// * networking/network_security/configuring-egress-firewall-ovn.adoc

ifeval::["{context}" == "configuring-egress-firewall-ovn"]
:kind: EgressFirewall
:api: k8s.ovn.org/v1
:ovn:
endif::[]

[id="nw-egressnetworkpolicy-object_{context}"]
= {kind} custom resource (CR) object

:ovn:

You can define one or more rules for an egress firewall. A rule is either an `Allow` rule or a `Deny` rule, with a specification for the traffic that the rule applies to.

The following YAML describes an {kind} CR object:

.{kind} object
[source,yaml,subs="attributes+"]
----
apiVersion: {api}
kind: {kind}
metadata:
ifdef::ovn[]
  name: <name>
endif::ovn[]
spec:
  egress:
    ...
----
where:

ifdef::ovn[]
`name`:: Specifies the name for the object. This must be set to `default`.
endif::ovn[]

`egress`:: A collection of one or more egress network policy rules as described in the following section.

[id="egressnetworkpolicy-rules_{context}"]
== {kind} rules

The following YAML describes an egress firewall rule object. The user can select either an IP address range in CIDR format, a domain name, or use the `nodeSelector` to allow or deny egress traffic. The `egress` stanza expects an array of one or more objects.

// - OVN-Kubernetes does not support DNS
// - OpenShift SDN does not support port and protocol specification

.Egress policy rule stanza
ifdef::ovn[]
[source,yaml]
----
egress:
- type: <type>
  to:
    cidrSelector: <cidr>
    dnsName: <dns_name>
    nodeSelector: <label_name>: <label_value>
  ports:
      ...
----
where:

`egress.type`:: Specifies the type of rule. The value must be either `Allow` or `Deny`.
`egress.to`:: Specifies an egress traffic match rule that specifies the `cidrSelector` field or the `dnsName` field. You cannot use both fields in the same rule.
`egress.to.cidrSelector`:: Specifies an IP address range in CIDR format.
`egress.to.dnsName`:: Specifies a DNS domain name.
`egress.to.nodeSelector`:: Specifies labels, which are key/value pairs that the user defines. Labels are attached to objects, such as pods. The `nodeSelector` allows for one or more node labels to be selected and attached to pods.
`egress.ports`:: Optional: Specifies a collection of network ports and protocols for the rule.
// TODO: Do we want "Optional:" before the "Specifies"?

.Ports stanza
[source,yaml]
----
ports:
- port: <port>
  protocol: <protocol>
----
where:

`port`:: Specifies a network port, such as `80` or `443`. If you specify a value for this field, you must also specify a value for `protocol`.
`protocol`:: Specifies a network protocol. The value must be either `TCP`, `UDP`, or `SCTP`.
endif::ovn[]

[id="egressnetworkpolicy-example_{context}"]
== Example {kind} CR objects

The following example defines several egress firewall policy rules:

[source,yaml,subs="attributes+"]
----
apiVersion: {api}
kind: {kind}
metadata:
  name: default
spec:
  egress:
  - type: Allow
    to:
      cidrSelector: 1.2.3.0/24
  - type: Deny
    to:
      cidrSelector: 0.0.0.0/0
----
where:

`egress`:: Specifies a collection of egress firewall policy rule objects.
// TODO: Even though this was just one item, I kept the DL method, for consistency with the above examples

ifdef::ovn[]
The following example defines a policy rule that denies traffic to the host at the `172.16.1.1/32` IP address, if the traffic is using either the TCP protocol and destination port `80` or any protocol and destination port `443`.

[source,yaml,subs="attributes+"]
----
apiVersion: {api}
kind: {kind}
metadata:
  name: default
spec:
  egress:
  - type: Deny
    to:
      cidrSelector: 172.16.1.1/32
    ports:
    - port: 80
      protocol: TCP
    - port: 443
----

[id="configuringNodeSelector-example_{context}"]
== Example nodeSelector for {kind}

As a cluster administrator, you can allow or deny egress traffic to nodes in your cluster by specifying a label using `nodeSelector`. Labels can be applied to one or more nodes. The following is an example with the `region=east` label:

[source,yaml,subs="attributes+"]
----
apiVersion: {api}
kind: EgressFirewall
metadata:
  name: default
spec:
    egress:
    - to:
        nodeSelector:
          matchLabels:
            region: east
      type: Allow
----

[TIP]
====
Instead of adding manual rules per node IP address, use node selectors to create a label that allows pods behind an egress firewall to access host network pods.
====
endif::ovn[]

ifdef::kind[]
:!kind:
endif::[]
ifdef::api[]
:!api:
endif::[]
ifdef::ovn[]
:!ovn:
endif::[]
