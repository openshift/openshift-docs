:_mod-docs-content-type: PROCEDURE

[id="ephemeral-storage-using-a-sharedconfigmap-object-in-a-pod_{context}"]
= Using a SharedConfigMap instance in a pod

[role="_abstract"]
To access a `SharedConfigMap` custom resource (CR) instance from a pod, you grant a given service account RBAC permissions to use that `SharedConfigMap` CR instance.

.Prerequisites

* You have created a `SharedConfigMap` CR instance for the config map that you want to share across namespaces in the cluster.
* You must have permission to perform the following actions:
** Discover which `SharedConfigMap` CR instances are available by entering the `oc get sharedconfigmaps` command and getting a non-empty list back.
** Determine if the service account your pod specifies is allowed to use the given `SharedSecret` CR instance. That is, you can run `oc adm policy who-can use <identifier of specific SharedSecret>` to see if the service account in your namespace is listed.
** Determine if the service account your pod specifies is allowed to use `csi` volumes, or if you, as the requesting user who created the pod directly, are allowed to use `csi` volumes.  See "Understanding and managing pod security admission" for details.

[NOTE]
====
If neither of the last two prerequisites in this list are met, create, or ask someone to create, the necessary role-based access control (RBAC) so that you can discover `SharedConfigMap` CR instances and enable service accounts to use `SharedConfigMap` CR instances.
====

.Procedure

. Grant a given service account RBAC permissions to use the `SharedConfigMap` CR instance in its pod.
+
[NOTE]
====
Currently, `kubectl` and `oc` have hard-coded special case logic restricting the `use` verb to roles centered around pod security. Therefore, you cannot use `oc create role ...` to create the role needed for consuming a `SharedConfigMap` CR instance.
====
+
[source,terminal]
----
$ oc new-project buildah-entitlement
$ oc apply -f -<<EOF
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: use-shared-secret
rules:
  - apiGroups:
      - sharedresource.openshift.io
    resources:
      - sharedsecrets
    resourceNames:
      - share-entitlement-secret
    verbs:
      - use
---

. Create the `RoleBinding` associated with the role:
+
[source,terminal]
----
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: use-shared-secret
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: use-shared-secret
subjects:
  - kind: ServiceAccount
    name: pipeline
    namespace: buildah-entitlement
EOF
----

. Create a build with relevant mount details using `buildah` buildStrategy:
+
[source,terminal]
----
$ oc apply -f -<<EOF
apiVersion: shipwright.io/v1beta1
kind: Build
metadata:
  name: buildah-rhel-entitlement-build
spec:
  source:
    type: Git
    git:
      url: 
      revision: quick-tests
    contextDir: rh-builds
  strategy:
    name: buildah-csi
    kind: ClusterBuildStrategy
  paramValues:
  - name: dockerfile
    value: Dockerfile
  volumes:
  - csi:
      driver: csi.sharedresource.openshift.io
      readOnly: true
      volumeAttributes:
        sharedSecret: share-entitlement-secret
    name: rhel-entitlement
  - name: buildah-auth
    secret:
      secretName: buildah-auth
  output:
    image: image-registry.openshift-image-registry.svc:5000/buildah-entitlement/sample-go-app
EOF
----

. Create the buildRun referencing the rhel-entitlement-build:
+
[source,terminal]
----
$ oc apply -f -<<EOF
apiVersion: shipwright.io/v1beta1
kind: BuildRun
metadata:
  name: buildah-rhel-entitlement-buildrun
spec:
  build:
    name: buildah-rhel-entitlement-build
EOF
----