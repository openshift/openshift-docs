// Module included in the following assemblies:
//
// *deployment/deployment.adoc

:_mod-docs-content-type: PROCEDURE
[id="platform-engineer-workflow_{context}"]
= Configure your Gateway policies and HTTP route

[role="_abstract"]
While your Gateway is now deployed, it has no exposed endpoints and your HTTPS listener is not programmed. Next, you can do take the following steps:

* Define a `TLSPolicy` that leverages your `CertificateIssuer` to set up your HTTPS listener certificates.
* Define an `HTTPRoute` for your Gateway to communicate with your backend application API.
* Define an `AuthPolicy` to set up a default HTTP `403` response for any unprotected endpoints
* Define and a `RateLimitPolicy` to set up a default artificially low global limit to further protect any endpoints exposed by the Gateway.
* Define a `DNSPolicy` with a load balancing strategy for your Gateway.

[IMPORTANT]
====
In multicluster environments, you must perform the following steps in each cluster individually, unless specifically excluded.
====

.Prerequisites

* Your Gateway is deployed as described in xref:create-gateway_{context}[].
//TODO

.Procedure

. Set the `TLSPolicy` for your Gateway as follows:
+
[source,bash]
----
$ kubectl apply -f - <<EOF
apiVersion: kuadrant.io/v1
kind: TLSPolicy
metadata:
  name: ${KUADRANT_GATEWAY_NAME}-tls
  namespace: ${KUADRANT_GATEWAY_NS}
spec:
  targetRef:
    name: ${KUADRANT_GATEWAY_NAME}
    group: gateway.networking.k8s.io
    kind: Gateway
  issuerRef:
    group: cert-manager.io
    kind: ClusterIssuer
    name: ${KUADRANT_CLUSTER_ISSUER_NAME}
EOF
----

. Check that your TLS policy has an `Accepted` and `Enforced` status as follows:
+
[source,bash]
----
$ kubectl get tlspolicy ${KUADRANT_GATEWAY_NAME}-tls -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type=="Accepted")].message}{"\n"}{.status.conditions[?(@.type=="Enforced")].message}'
----
+
This may take a few minutes depending on the TLS provider, for example, Let's Encrypt.

//TODO new module
== Create an HTTP route for your application

.Procedure

. Create an `HTTPRoute` for the example Toystore application as follows:
+
[source,bash]
----
$ kubectl apply -f - <<EOF
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
  name: toystore
  namespace: ${KUADRANT_DEVELOPER_NS}
  labels:
    deployment: toystore
    service: toystore
spec:
  parentRefs:
  - name: ${KUADRANT_GATEWAY_NAME}
    namespace: ${KUADRANT_GATEWAY_NS}
  hostnames:
  - "api.${KUADRANT_ZONE_ROOT_DOMAIN}"
  rules:
  - matches:
    - method: GET
      path:
        type: PathPrefix
        value: "/cars"
    - method: GET
      path:
        type: PathPrefix
        value: "/health"
    backendRefs:
    - name: toystore
      port: 80
EOF
----

//TODO new module
== Set the default AuthPolicy

.Procedure

. Set a default `AuthPolicy` with a `deny-all` setting for your Gateway as follows:
+
[source,bash]
----
kubectl apply -f - <<EOF
apiVersion: kuadrant.io/v1
kind: AuthPolicy
metadata:
  name: ${KUADRANT_GATEWAY_NAME}-auth
  namespace: ${KUADRANT_GATEWAY_NS}
spec:
  targetRef:
    group: gateway.networking.k8s.io
    kind: Gateway
    name: ${KUADRANT_GATEWAY_NAME}
  defaults:
   when:
     - predicate: "request.path != '/health'"
   rules:
    authorization:
      deny-all:
        opa:
          rego: "allow = false"
    response:
      unauthorized:
        headers:
          "content-type":
            value: application/json
        body:
          value: |
            {
              "error": "Forbidden",
              "message": "Access denied by default by the gateway operator. If you are the administrator of the service, create a specific auth policy for the route."
            }
EOF
----

. Check that your `AuthPolicy` has `Accepted` and `Enforced` status as follows:
+
[source,bash]
----
$ kubectl get authpolicy ${KUADRANT_GATEWAY_NAME}-auth -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type=="Accepted")].message}{"\n"}{.status.conditions[?(@.type=="Enforced")].message}'
----

//TODO new module
== Set the default `RateLimitPolicy`

.Procedure

. Set the default `RateLimitPolicy` with a `low-limit` setting for your Gateway as follows:
+
[source,bash]
----
kubectl apply -f  - <<EOF
apiVersion: kuadrant.io/v1
kind: RateLimitPolicy
metadata:
  name: ${KUADRANT_GATEWAY_NAME}-rlp
  namespace: ${KUADRANT_GATEWAY_NS}
spec:
  targetRef:
    group: gateway.networking.k8s.io
    kind: Gateway
    name: ${KUADRANT_GATEWAY_NAME}
  defaults:
    limits:
      "low-limit":
        rates:
        - limit: 1
          window: 10s
EOF
----
+
It might take a few minutes for the `RateLimitPolicy` to be applied depending on your cluster. The limit in this example is artificially low to show it working easily.

. Check that your `RateLimitPolicy` has `Accepted` and `Enforced` status as follows:
+
[source,bash]
----
$ kubectl get ratelimitpolicy ${KUADRANT_GATEWAY_NAME}-rlp -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type=="Accepted")].message}{"\n"}{.status.conditions[?(@.type=="Enforced")].message}'
----

//TODO new module
== Set the DNS policy

.Procedure

. Set the `DNSPolicy` for your Gateway as follows:
+
[source,bash]
----
$ kubectl apply -f - <<EOF
apiVersion: kuadrant.io/v1
kind: DNSPolicy
metadata:
  name: ${KUADRANT_GATEWAY_NAME}-dnspolicy
  namespace: ${KUADRANT_GATEWAY_NS}
spec:
  healthCheck:
    failureThreshold: 3
    interval: 1m
    path: /health
  loadBalancing:
    defaultGeo: true
    geo: GEO-NA
    weight: 120
  targetRef:
    name: ${KUADRANT_GATEWAY_NAME}
    group: gateway.networking.k8s.io
    kind: Gateway
  providerRefs:
  - name: aws-credentials # Secret created earlier
EOF
----
+
The `DNSPolicy` uses the DNS Provider `Secret` that you defined earlier. The `geo` in this example is `GEO-NA`, but you can change this to suit your requirements.

. Check that your `DNSPolicy` has status of `Accepted` and `Enforced` as follows:
+
[source,bash]
----
$ kubectl get dnspolicy ${KUADRANT_GATEWAY_NAME}-dnspolicy -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type=="Accepted")].message}{"\n"}{.status.conditions[?(@.type=="Enforced")].message}'
----
+
This might take a few minutes.

. Check the status of the DNS health checks that are enabled on your DNSPolicy as follows:
+
[source,bash]
----
$ kubectl get dnspolicy ${KUADRANT_GATEWAY_NAME}-dnspolicy -n ${KUADRANT_GATEWAY_NS} -
----
+
These health checks flag a published endpoint as healthy or unhealthy based on defined configuration. When unhealthy, an endpoint will not be published if it has not already been published to the DNS provider. An endpoint will only be unpublished if it is part of a multi-value A record, and in all cases can be observed in the DNSPolicy status.
//TODO need this?
[role="_additional-resources"]
.Additional resources

* For more information, see the community-based https://docs.kuadrant.io/1.1.x/kuadrant-operator/doc/user-guides/dns/dnshealthchecks/[Kuadrant DNS Health Checks documentation].

//TODO new Verification module or within last module
== Test your default rate limit and auth policies

You can use a `curl` command to test the default `low-limit` and `deny-all` policies for your Gateway.

.Procedure

* Enter the following `curl` command:
+
[source,bash]
----
$ while :; do curl -k --write-out '%{http_code}\n' --silent --output /dev/null  "https://api.$KUADRANT_ZONE_ROOT_DOMAIN/cars" | grep -E --color "\b(429)\b|$"; sleep 1; done
----
+
You should see a HTTP `403` responses.