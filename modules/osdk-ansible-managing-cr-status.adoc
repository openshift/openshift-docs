// Module included in the following assemblies:
//
// * operators/operator_sdk/osdk-ansible.adoc

[id="osdk-ansible-managing-cr-status_{context}"]
= Managing custom resource status using the `operator_sdk.util` Ansible collection

Ansible-based Operators automatically update custom resource (CR) link:https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#status-subresource[`status` subresources] with generic information about the previous Ansible run. This includes the number of successful and failed tasks and relevant error messages as shown:

[source,yaml]
----
status:
  conditions:
    - ansibleResult:
      changed: 3
      completion: 2018-12-03T13:45:57.13329
      failures: 1
      ok: 6
      skipped: 0
    lastTransitionTime: 2018-12-03T13:45:57Z
    message: 'Status code was -1 and not [200]: Request failed: <urlopen error [Errno
      113] No route to host>'
    reason: Failed
    status: "True"
    type: Failure
  - lastTransitionTime: 2018-12-03T13:46:13Z
    message: Running reconciliation
    reason: Running
    status: "True"
    type: Running
----

Ansible-based Operators also allow Operator authors to supply custom status values with the `k8s_status` Ansible module, which is included in the link:https://galaxy.ansible.com/operator_sdk/util[`operator_sdk.util` collection]. This allows the author to update the `status` from within Ansible with any key-value pair as desired.

By default, Ansible-based Operators always include the generic Ansible run output as shown above. If you would prefer your application did _not_ update the status with Ansible output, you can track the status manually from your application.

.Procedure

. To track CR status manually from your application, update the `watches.yaml` file with a `manageStatus` field set to `false`:
+
[source,yaml]
----
- version: v1
  group: api.example.com
  kind: Test1
  role: Test1
  manageStatus: false
----

. Use the `operator_sdk.util.k8s_status` Ansible module to update the subresource. For example, to update with key `test1` and value `test2`, `operator_sdk.util` can be used as shown:
+
[source,yaml]
----
- operator_sdk.util.k8s_status:
    api_version: app.example.com/v1
    kind: Test1
    name: "{{ meta.name }}"
    namespace: "{{ meta.namespace }}"
    status:
      test1: test2
----
+
Collections can also be declared in the `meta/main.yml` for the role, which is included for new scaffolded Ansible Operators:
+
[source,yaml]
----
collections:
  - operator_sdk.util
----
+
Declaring collections in the role meta allows you to invoke the `k8s_status` module directly:
+
[source,yaml]
----
k8s_status:
  <snip>
  status:
    test1: test2
----

.Additional resources

- For more details about user-driven status management from Ansible-based Operators, see the link:https://github.com/operator-framework/operator-sdk/blob/master/proposals/ansible-operator-status.md[Ansible-based Operator Status Proposal for Operator SDK].
