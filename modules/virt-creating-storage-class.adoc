// Module included in the following assemblies:
//
// * virt/virtual_machines/virtual_disks/virt-configuring-local-storage-for-vms.adoc

:_content-type: PROCEDURE
[id="virt-creating-storage-class_{context}"]
= Creating a storage class

When you create a storage class, you set parameters that affect the
dynamic provisioning of persistent volumes (PVs) that belong to that storage class. You cannot update a `StorageClass` object's parameters after you create it.

[IMPORTANT]
====
When using {VirtProductName} with {product-title} Container Storage, specify RBD block mode persistent volume claims (PVCs) when creating virtual machine disks. With virtual machine disks, RBD block mode volumes are more efficient and provide better performance than Ceph FS or RBD filesystem-mode PVCs.

To specify RBD block mode PVCs, use the 'ocs-storagecluster-ceph-rbd' storage class and `VolumeMode: Block`.
====

[id="virt-creating-storage-class-csi_{context}"]
== Creating a storage class for the CSI driver with the storagePools stanza

Use this procedure to create a storage class for use with the HPP CSI driver implementation. You must create this storage class to use HPP in {VirtProductName} 4.10 and later.

.Procedure

. Create a YAML file for defining the storage class. For example:
+
[source,terminal]
----
$ touch <storageclass_csi>.yaml
----

. Edit the file. For example:
+
[source,yaml]
----
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: hostpath-csi <1>
provisioner: kubevirt.io.hostpath-provisioner <2>
reclaimPolicy: Delete <3>
volumeBindingMode: WaitForFirstConsumer <4>
parameters:
  storagePool: <any_name> <5>
----
<1> Assign any meaningful name to the storage class. In this example, `csi` is used to specify that the class is using the CSI provisioner instead of the legacy provisioner. Choosing descriptive names for storage classes, based on legacy or CSI driver provisioning, eases implementation of your migration strategy.
<2> The legacy provisioner uses `kubevirt.io/hostpath-provisioner`. The CSI driver uses `kubevirt.io.hostpath-provisioner`.
<3> The two possible `reclaimPolicy` values are `Delete` and `Retain`. If you
do not specify a value, the storage class defaults to `Delete`.
<4> The `volumeBindingMode` parameter determines when dynamic provisioning and volume binding occur. Specify `WaitForFirstConsumer` to delay the binding and provisioning of a PV until after a pod that uses the persistent volume claim (PVC) is created. This ensures that the PV meets the pod's scheduling requirements.
<5> `<any_name>` must match the name of the storage pool, which you define in the HPP custom resource.

. Save the file and exit.

. Create the `StorageClass` object:
+
[source,terminal]
----
$ oc create -f <storageclass_csi>.yaml
----

[id="virt-creating-storage-class-legacy-hpp_{context}"]
== Creating a storage class for the legacy hostpath provisioner

Use this procedure to create a storage class for the legacy hostpath provisioner (HPP). You do not need to explicitly add a `storagePool` parameter.
>>>>>>> 9c785ea8db (BZ2092346 - rearranged info to avoid 2 admonitions close together)

.Procedure

. Create a YAML file for defining the storage class. For example:
+
[source,terminal]
----
$ touch storageclass.yaml
----

. Edit the file. For example:
+
[source,yaml]
----
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: hostpath-provisioner <1>
provisioner: kubevirt.io/hostpath-provisioner
reclaimPolicy: Delete <2>
volumeBindingMode: WaitForFirstConsumer <3>
----
<1> You can optionally rename the storage class by changing this value.
<2> The two possible `reclaimPolicy` values are `Delete` and `Retain`. If you
do not specify a value, the storage class defaults to `Delete`.
<3> The `volumeBindingMode` value determines when dynamic provisioning and volume
binding occur. Specify `WaitForFirstConsumer` to delay the binding and provisioning
of a PV until after a pod that uses the persistent volume claim (PVC)
is created. This ensures that the PV meets the pod's scheduling requirements.
+
[NOTE]
====
Virtual machines use data volumes that are based on local PVs. Local PVs are bound to specific nodes. While the disk image is prepared for consumption by the virtual machine, it is possible that the virtual machine cannot be scheduled to the node where the local storage PV was previously pinned.

To solve this problem, use the Kubernetes pod scheduler to bind the PVC to a PV on the correct node. By using `StorageClass` with `volumeBindingMode` set to `WaitForFirstConsumer`, the binding and provisioning of the PV is delayed until a `Pod` is created using the PVC.
====

. Create the `StorageClass` object:
+
[source,terminal]
----
$ oc create -f storageclass.yaml
----

[role="_additional-resources"]
.Additional resources

* link:https://kubernetes.io/docs/concepts/storage/storage-classes/[Storage classes]
