// Module included in the following assemblies:
//
// * security/cert_manager_operator/cert-manager-creating-certificate.adoc

:_mod-docs-content-type: PROCEDURE
[id="cert-manager-configuring-routes_{context}"]
= Configuring certificates to secure routes in your cluster

The following steps demonstrate the process of utilizing the {cert-manager-operator} with the `Let's Encrypt` ACME HTTP-01 challenge type to secure the route resources in your OpenShift Cluster.

.Prerequisites

* You have installed the {cert-manager-operator} 1.14.0 or later.
* You have enabled the `RouteExternalCertificate` feature gate.
* You have the `create` and `update` permissions on the `routes/custom-host` sub-resource.
* You have a `Service` that you want to expose.

.Procedure

. Create a `route` for your service using edge TLS termination and a custom `hostname`.
+
[source, terminal]
----
$ oc create route edge <route_name> \ # <1>
  --service=<service_name> \ # <2>
  --hostname=<host_name> \ # <3>
  --namespace=<namespace> # <4>
----
<1> Specify your route's name.
<2> Specify the service you want to expose.
<3> Specify the hostname of your route.
<4> Specify the namespace where your route is located.

. Create an `Issuer` to configure the http01 solver. For other ACME issuer types, see "Configuring ACME an issuer" in the "Additional Resources" section.
+
.Example `Issuer.yaml` file
+
[source, yaml]
----
$ oc create -f - << EOF
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: letsencrypt-acme
  namespace: <namespace> # <1>
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    privateKeySecretRef:
      name: letsencrypt-acme-account-key
    solvers:
      - http01:
          ingress:
            ingressClassName: openshift-default
EOF
----
<1> Specify the namespace where the Issuer is located. It should be the same as your route's namespace.

. Create a `Certificate` for the route.
+
[source, yaml]
----
$ oc create -f - << EOF
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: example-route-cert
  namespace: <namespace> # <1>
spec:
  commonName: <hostname> # <2>
  dnsNames:
    - <hostname> # <3>
  usages:
    - server auth
  issuerRef:
    kind: Issuer
    name: letsencrypt-acme
  secretName: <secret_name> # <4>
EOF
----
<1> Specify the `namespace` where the `Certificate` is located. It should be the same as your route's namespace.
<2> Specify the certificate's common name using the `hostname` of the route.
<3> Add the `hostname` of your route to the certificate's DNS names.
<4> Specify the name of the secret that contains the certificate.

. Create a `Role` to provide the router service account permissions to read the referenced secret using the following command:
+
[source, terminal]
----
$ oc create role secret-reader \
  --verb=get,list,watch \
  --resource=secrets \
  --resource-name=<secret_name> \ # <1>
  --namespace=<namespace> # <2>
----
<1> Specify the name of the secret that you want to grant access to. It should be consistent with your `secretName` specified in the Certificate.
<2> Specify the namespace where both your secret and route reside.

. Create a `RoleBinding` to bind the router service account with the newly created `Role` using the following command:
+
[source, terminal]
----
$ oc create rolebinding secret-reader-binding \
  --role=secret-reader \
  --serviceaccount=openshift-ingress:router \
  --namespace=<namespace> # <1>
----
<1> Specify the namespace where both your secret and route reside.

. Update your route's `.spec.tls.externalCertificate` field to reference the previously created secret and use the certificate issued by {cert-manager-operator} using the following command:
+
[source, terminal]
----
$ oc patch route <route_name> \
  -n <namespace> \
  --type=merge \
  -p '{"spec":{"tls":{"externalCertificate":{"name":"<secret_name>"}}}}'
----

.Verification

* Verify that the certificate is created and ready to use by running the following command:
+ 
[source, terminal]
----
$ oc get certificate -n <namespace>
$ oc get secret -n <namespace>
----

* Verify that the router is using the referenced external certificate by running the following command. The command should return with the status code `200 OK`.
+ 
[source, terminal]
----
$ curl -IsS https://<hostname>
----

* Verify the server certificate's `subject`, `subjectAltName` and `issuer` are all as expected from the curl verbose outputs by running the following command:
+ 
[source, terminal]
----
$ curl -v https://<hostname>
----
+
Now the route is successfully secured by the certificate from the referenced secret issued by {cert-manager-operator}. Cert-manager will automatically manage the certificate's lifecycle.