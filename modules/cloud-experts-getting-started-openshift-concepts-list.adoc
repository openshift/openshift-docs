// Module included in the following assemblies:
//
// * cloud_experts_tutorials/cloud-experts-getting-started/cloud-experts-getting-started-openshift-concepts.adoc

:_mod-docs-content-type: CONCEPT
[id="cloud-experts-getting-started-openshift-concepts-routes_{context}"]
== Routes

[role="_abstract"]
An OpenShift route exposes a service at a hostname so that external clients can reach it by name. When a `Route` object is created on OpenShift, it gets picked up by the built-in HAProxy load balancer to expose the requested service and make it externally available with the given configuration.

Similar to the Kubernetes `Ingress` object, Red Hat created the concept of route to fill a need and then contributed the design principles behind it to the community, which heavily influenced the `Ingress` design. A route does have some additional features as can be seen in the following chart:

[cols="1,1,1"]
|===
|Feature | Ingress on OpenShift | Route on OpenShift

|Standard Kubernetes object
| **X**
|

|External access to services
| **X**
| **X**

|Persistent (sticky) sessions
| **X**
| **X**

|Load-balancing strategies (e.g. round robin)
| **X**
| **X**

|Rate-limit and throttling
| **X**
| **X**

|IP whitelisting
| **X**
| **X**

|TLS edge termination for improved security
| **X**
| **X**

|TLS re-encryption for improved security
|
| **X**

|TLS passhtrough for improved security
|
| **X**

|Multiple weighted backends (split traffic)
|
| **X**

|Generated pattern-based hostnames
|
| **X**

|Wildcard domains
|
| **X**
|===

[NOTE]
====
DNS resolution for a hostname is handled separately from routing. Your administrator might have configured a cloud domain that will always correctly resolve to the router or modify your unrelated hostname DNS records independently to resolve to the router.
====

An individual route can override some defaults by providing specific configurations in its annotations.

[id="cloud-experts-getting-started-openshift-concepts-imagestreams"]
== Image streams
An image stream stores a mapping of tags to images, metadata overrides that are applied when images are tagged in a stream, and an optional reference to a Docker image repository on a registry.

[id="cloud-experts-getting-started-openshift-concepts-imagestreams-benefits"]
=== Image stream benefits
Using an image stream makes it easier to change a tag for a container image. Otherwise, to manually change a tag, you must download the image, change it locally, then push it all back. Promoting applications by manually changing a tag and then updating the deployment object entails many steps.

With image streams, you upload a container image once and then you manage its virtual tags internally in OpenShift. In one project you might use the developer tag and only change a reference to it internally, while in production you might use a production tag and also manage it internally. You do not have to deal with the registry.

You can also use image streams in conjunction with deployment configs to set a trigger that will start a deployment as soon as a new image appears or a tag changes its reference.

[id="cloud-experts-getting-started-openshift-concepts-builds"]
== Builds
A build is the process of transforming input parameters into a resulting object. Most often, the process is used to transform input parameters or source code into a runnable image. A `BuildConfig` object is the definition of the entire build process.

OpenShift Container Platform leverages Kubernetes by creating Docker-formatted containers from build images and pushing them to a container image registry.

Build objects share common characteristics:

* Inputs for a build
* Requirements to complete a build process
* Logging the build process
* Publishing resources from successful builds
* Publishing the final status of the build

Builds take advantage of resource restrictions, specifying limitations on resources such as CPU usage, memory usage, and build or pod execution time.