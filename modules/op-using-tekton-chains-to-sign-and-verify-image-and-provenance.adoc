// This module is included in the following assemblies:
// * secure/using-tekton-chains-for-openshift-pipelines-supply-chain-security.adoc

:_mod-docs-content-type: PROCEDURE
[id="using-tekton-chains-to-sign-and-verify-image-and-provenance_{context}"]
= Using {tekton-chains} to sign and verify image and provenance

[role="_abstract"]
Cluster administrators can use {tekton-chains} to sign and verify images and provenances, by performing the following tasks:

* Generate an encrypted `x509` or `cosign` key pair and store it as a Kubernetes secret.
* Set up authentication for the Open Container Initiative (OCI) registry to store images, image signatures, and signed image attestations.
* Configure {tekton-chains} to generate and sign provenance.
* Create an image with Kaniko in a task run.
* Verify the signed image and the signed provenance.

.Prerequisites
Ensure that you have installed the following tools on the cluster:

* {pipelines-title} Operator
* {tekton-chains}
* link:https://docs.sigstore.dev/cosign/system_config/installation/[Cosign]
* link:https://docs.sigstore.dev/logging/installation/[Rekor]
* link:https://stedolan.github.io/jq/[jq]

.Procedure

. Generate an encrypted `x509` or `cosign` key pair. For more information about creating a key pair and saving it as a secret, see "Secrets for signing data in {tekton-chains}".

. Configure authentication for the image registry.

.. To configure the {tekton-chains} controller for pushing signature to an OCI registry, use the credentials associated with the service account of the task run. For detailed information, see the "Authenticating to an OCI registry" section.

.. To configure authentication for a Kaniko task that builds and pushes image to the registry, create a Kubernetes secret of the docker `config.json` file containing the required credentials.
+
[source,terminal]
----
$ oc create secret generic <docker_config_secret_name> \
  --from-file <path_to_config.json>
----
+
`<docker_config_secret_name>`:: Substitute `<docker_config_secret_name>` with the name of the docker config secret.
`<path_to_config.json>`:: Substitute `<path_to_config.json>` with the path to docker `config.json` file.

. Configure {tekton-chains} by setting the `artifacts.taskrun.format`, `artifacts.taskrun.storage`, and `transparency.enabled` parameters in the `chains-config` object:
+
[source,terminal]
----
$ oc patch configmap chains-config -n openshift-pipelines -p='{"data":{"artifacts.taskrun.format": "in-toto"}}'
----
+
[source,terminal]
----
$ oc patch configmap chains-config -n openshift-pipelines -p='{"data":{"artifacts.taskrun.storage": "oci"}}'
----
+
[source,terminal]
----
$ oc patch configmap chains-config -n openshift-pipelines -p='{"data":{"transparency.enabled": "true"}}'
----

. Start the Kaniko task.

.. Apply the Kaniko task to the cluster.
+
[source,terminal]
----
$ oc apply -f examples/kaniko/kaniko.yaml
----
+
Substitute the example URI with the URI or file path to your Kaniko task.

.. Set the appropriate environment variables.
+
[source,terminal]
----
$ export REGISTRY=<url_of_registry>
$ export DOCKERCONFIG_SECRET_NAME=<name_of_the_secret_in_docker_config_json>
----
+
`<url_of_registry>`:: Replace `<url_of_registry>` with the URL of the registry where you want to push the image.
`<name_of_the_secret_in_docker_config_json>`:: Replace `<name_of_the_secret_in_docker_config_json>` with the name of the secret in the docker `config.json` file.

.. Start the Kaniko task.
+
[source,terminal]
----
$ tkn task start --param IMAGE=$REGISTRY/kaniko-chains --use-param-defaults --workspace name=source,emptyDir="" --workspace name=dockerconfig,secret=$DOCKERCONFIG_SECRET_NAME kaniko-chains
----
+
Observe the logs of this task until all steps are complete. On successful authentication, the task pushes the final image to `$REGISTRY/kaniko-chains`.

. Wait for a minute to allow {tekton-chains} to generate the provenance and sign it, and then check the availability of the `chains.tekton.dev/signed=true` annotation on the task run.
+
[source,terminal]
----
$ oc get tr <task_run_name> \
-o json | jq -r .metadata.annotations

{
  "chains.tekton.dev/signed": "true",
  ...
}
----
+
Replace `<task_run_name>` with the name of the task run.

. Verify the image and the attestation.
+
[source,terminal]
----
$ cosign verify --key cosign.pub $REGISTRY/kaniko-chains

$ cosign verify-attestation --key cosign.pub $REGISTRY/kaniko-chains
----

. Find the provenance for the image in Rekor.

.. Get the digest of the $REGISTRY/kaniko-chains image. You can search for it in the task run, or pull the image to extract the digest.

.. Search Rekor to find all entries that match the `sha256` digest of the image.
+
[source,terminal]
----
$ rekor-cli search --sha <image_digest>

<uuid_1>
<uuid_2>
...
----
+
`<image_diget>`:: Replace `<image_digest>` with the `sha256` digest of the image.
`<uuid_1>`:: The first matching universally unique identifier (UUID).
`<uuid_2>`:: The second matching UUID.
+
The search result displays UUIDs of the matching entries. One of those UUIDs holds the attestation.

.. Check the attestation.
+
[source,terminal]
----
$ rekor-cli get --uuid <uuid> --format json | jq -r .Attestation | base64 --decode | jq
----
