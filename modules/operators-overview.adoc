// Module included in the following assemblies:
//
// * architecture/architecture.adoc

[id="operators-overview_{context}"]
= Operators in {product-title}

{product-title} {product-version} uses different classes of Operators to perform cluster
operations and run services on the cluster for your applications to use.

ifdef::openshift-enterprise,openshift-origin[]
[id="platform-operators_{context}"]
== Platform Operators in {product-title}

In {product-title} {product-version}, all cluster functions are divided into a series
of platform Operators. Platform operators manage a particular area of
cluster functionality, such as cluster-wide application logging, management of
the Kubernetes control plane, or the machine provisioning system.

Each Operator provides you with a simple API for determining cluster
functionality. The Operator hides the details of managing the lifecycle of that
component. Operators can manage a single component or tens of components, but
the end goal is always to reduce operational burden by automating common actions.
Operators also offer a more granular configuration experience. You configure each
component by modifying the API that the Operator exposes instead of modifying a
global configuration file.

In {product-title} {product-version}, all control plane components are run and managed as
applications on the infrastructure to ensure a uniform and consistent management
experience. The control plane services run as static pods so they can
manage normal workloads or processes the same way that they manage disaster
recovery. Aside from the core control plane components, other services run as
normal pods on the cluster, managed by regular Kubernetes constructs. Unlike in the past
where the `kubelet` could be running as containerized or non-containerized, the `kubelet`
always runs as a `systemd` process.


[id="second-level-operators_{context}"]
== Second-level Operators in {product-title}

The Cluster Version Operator, when we talk about payload manifests, is a
second-level Operator, the Operators that actually manage {product-title} as if
it were a native Kubernetes application. Second-level Operators are not a
codified concept, but the namespace where your code exists, the service accounts
or roles the second-level Operator runs as, the
link:https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#customresourcedefinitions[Custom Resource Definition] (CRD)
and pull secret that drives the operation of the Operator, and the Operator deployment.

Second-level Operators write out to a CRD resource called the ClusterOperator
that allows the Cluster Version Operator to understand the progress of the
managed component's deployment.
endif::[]

[id="OLM-operators_{context}"]
== Operators managed by OLM

The Cluster Operator Lifecycle Management (OLM) component manages Operators
that are available for use in applications. It does not manage the Operators that
comprise {product-title}.
OLM is a framework that manages Kubernetes-native applications as Operators.
Instead of managing Kubernetes manifests, it manages Kubernetes Operators.
OLM manages two classes of Operators, Red Hat Operators and certified Operators.

Some Red Hat Operators drive the cluster functions, like the scheduler and
problem detectors. Others are provided for you to manage yourself and use in
your applications, like etcd. {product-title} also offers certified Operators,
which the community built and maintains. These certified Operators provide an
API layer to traditional applications so you can manage the application through
Kubernetes constructs.
