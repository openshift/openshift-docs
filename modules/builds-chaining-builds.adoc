// Module included in the following assemblies:
//
// * assembly/builds

[id="builds-chaining-builds_{context}"]
= Chained builds

For compiled languages (such as Go, C, C++, and Java), including the dependencies
necessary for compilation in the application image might increase the size of
the image or introduce vulnerabilities that can be exploited.

To avoid these problems, two builds can be chained together: one that produces
the compiled artifact, and a second build that places that artifact in a
separate image that runs the artifact.

ifdef::openshift-enterprise,openshift-webscale,openshift-origin,openshift-dedicated[]
In the following example, a Source-to-Image build is combined with a Docker
build to compile an artifact that is then placed in a separate runtime image.

[NOTE]
====
Although this example chains a Source-to-Image build and a Docker build, the
first build can use any strategy that will produce an image containing the
desired artifacts, and the second build can use any strategy that can consume
input content from an image.
====

//image::chained-build.png[Chained Build] *Needs update*

The first build takes the application source and produces an image containing a
WAR file. The image is pushed to the `artifact-image` imagestream. The path of
the output artifact will depend on the *_assemble_* script of the
Source-to-Image builder used. In this case, it will be output to
*_/wildfly/standalone/deployments/ROOT.war_*.

[source,yaml]
----
apiVersion: v1
kind: BuildConfig
metadata:
  name: artifact-build
spec:
  output:
    to:
      kind: ImageStreamTag
      name: artifact-image:latest
  source:
    git:
      uri: https://github.com/openshift/openshift-jee-sample.git
  strategy:
    sourceStrategy:
      from:
        kind: ImageStreamTag
        name: wildfly:10.1
        namespace: openshift
----

The second build uses Image Source with a path to the WAR file inside the output
image from the first build. An inline *_Dockerfile_* copies that WAR file into a
runtime image.

[source,yaml]
----
apiVersion: v1
kind: BuildConfig
metadata:
  name: image-build
spec:
  output:
    to:
      kind: ImageStreamTag
      name: image-build:latest
  source:
    dockerfile: |-
      FROM jee-runtime:latest
      COPY ROOT.war /deployments/ROOT.war
    images:
    - from: <1>
        kind: ImageStreamTag
        name: artifact-image:latest
      paths: <2>
      - sourcePath: /wildfly/standalone/deployments/ROOT.war
        destinationDir: "."
  strategy:
    dockerStrategy:
      from: <3>
        kind: ImageStreamTag
        name: jee-runtime:latest
  triggers:
  - imageChange: {}
    type: ImageChange
----
<1> `from` specifies that the Docker build should include the output of the image
from the `artifact-image` imagestream, which was the target of the previous
build.
<2> `paths` specifies which paths from the target image to include in the current
Docker build.
<3> The runtime image is used as the source image for the Docker build.

The result of this setup is that the output image of the second build does not
have to contain any of the build tools that are needed to create the WAR file.
Also, because the second build contains an image change trigger,
whenever the first build is run and produces a new image with the binary
artifact, the second build is automatically triggered to produce a runtime image
that contains that artifact. Therefore, both builds behave as a single build
with two stages.
endif::[]

//.Procedure
//
//This module should include a procedure for chaining builds. It is not at all
//clear as is.
