// Module included in the following assemblies:
//
// * operating/manage_security_policies/about-security-policies.adoc
:_mod-docs-content-type: CONCEPT
[id="understand-admission-controller-enforcement_{context}"]
= Understanding admission controller enforcement

[role="_abstract"]

{product-title-short} uses an admission controller to provide enforcement for security policies that you have configured. The admission controller works with validating webhooks to evaluate requests to create, update, and perform workload operations against security policies. It can also evaluate running workloads and detect user-initiated container commands such as `pod exec` and `port forward`. If enforcement is configured for a policy and results in a violation, the request fails, preventing the operation from persisting in the API server and being successfully completed. 

The workflow for evaluating requests and enforcing policies follows these steps:

. A user or system submits a request to create, update, or perform workload operations that is received by the Kubernetes or {ocp} API server. 
. The API server contacts the validating webhooks with an `AdmissionReview` request.
. The validating webhooks call the admission controller via the service endpoint to verify that the resource being provisioned or user-issued commands in the containers comply with the specified security policies.
. The review request is either passed or failed, or can time out in some cases:
* If the review request violates an enforced security policy, the API server rejects the request.
* If review request is not prevented by a security policy or times out, the API server accepts and persists the resource. In the case of a timeout, this behavior is known as "fail open", which is the default behavior. However, you can configure the default behavior in case of timeout to "fail closed" for stricter enforcement.

If you use admission controller enforcement, consider the following guidance:

* Using admission controller enforcement increases Kubernetes or {ocp} API latency because it involves additional validation like policy evaluation on Kubernetes operations.
Many standard Kubernetes libraries, such as fabric8, have short Kubernetes or {ocp} API timeouts by default.
+
Consider API timeouts in any custom automation you might be using. If a request does time out due to latency issues, you can configure if the admission controller will fail open, allowing the request to reach the API server, or fail closed, blocking the requested operation. This setting is configured during installation and you can verify the setting by selecting *Platform Configuration* -> *Clusters* and checking the *Admission controller failure policy*.
* If you are using {product-title-short} in a continuous development (CD) tool, set the admission controller failure policy to fail closed, so that your CD tool handles the enforcement.
* You can use admission controller enforcement for the following items:
** Options in the pod `securityContext`
** Deployment configurations
** Image components and vulnerabilities
** User-initiated container commands such as `pod exec` and `port forward`
* If you have deploy stage enforcement enabled for a policy and you enable the admission controller, {product-title-short} attempts to block deployments that violate the policy.
If a noncompliant deployment is not rejected by the admission controller, for example, in case of a timeout, {product-title-short} still applies other deploy stage enforcement mechanisms, such as scaling to zero replicas.
