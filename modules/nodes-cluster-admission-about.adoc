// Module included in the following assemblies:
//
// * nodes/nodes-cluster-admission.adoc

[id="nodes-containers-controllers-about_{context}"]
= Understanding custom admission controllers

Admission control plug-ins intercept requests to the master API prior to persistence of a resource, but after the request is authenticated and authorized.

Each admission control plug-in is run in sequence before a request is accepted into the cluster. If any plug-in in the sequence rejects the request, the entire request is rejected immediately, and an error is returned to the end-user.

Admission control plug-ins may modify the incoming object in some cases to apply system configured defaults. In addition, admission control plug-ins may modify related resources as part of request processing to do things such as incrementing quota usage.

The {product-title} master has a default list of plug-ins that are enabled by
default for each type of resource (Kubernetes and {product-title}): 

* DefaultStorageClass
* DefaultTolerationSeconds
* LimitRanger 
* MutatingAdmissionWebhook
* NamespaceLifecycle
* OwnerReferencesPermissionEnforcement
* PersistentVolumeClaimResize
* Priority
* ResourceQuota
* ServiceAccount
* ValidatingAdmissionWebhook

These are required for the proper functioning of the master. Modifying these lists is not
recommended. Future versions of the product may use a different set of plug-ins and may change their ordering. If
you do override the default list of plug-ins in the master configuration file,
you are responsible for updating it to reflect requirements of newer versions of
the {product-title} master.

For the full list of admission controllers, see the 
link:https://v1-13.docs.kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do[Kubernetes documentation].

AlwaysPullImages::
This admission controller modifies every new Pod to force the image pull policy to Always. Images are always pulled prior to starting containers, which means valid credentials are required.

ClusterResourceOverride::
This admission controller overrides user-provided resource requirements in order to drive scheduling density. Requires the `autoscaling.openshift.io` API.

DefaultStorageClass::
This admission controller observes creation of PersistentVolumeClaim objects that do not request any specific storage class and automatically adds a default storage class to them. 

DefaultTolerationSeconds::
This admission controller sets the default forgiveness toleration for pods to tolerate the `notready:NoExecute` and `unreachable:NoExecute` taints for 5 minutes, if the pods don’t already have toleration for taints. Requires the `operator.openshift.io/v1` API.

DenyEscalatingExec::
This admission controller will deny exec and attach commands to pods that run with escalated privileges that allow host access. 

ExtendedResourceToleration::
This admission controller facilitates the creation of dedicated nodes with extended resources, such as GPUs, FPGAs, and so forth. If operators want to create dedicated nodes with extended resources, they are expected to taint the node with the extended resource name as the key. This admission controller, if enabled, automatically adds tolerations for such taints to pods requesting extended resources, so users don’t have to manually add these tolerations.  Requires the `operator.openshift.io/v1` API.

LimitPodHardAntiAffinityTopology::
This admission controller denies any pod that defines the `AntiAffinity` topology key other than `kubernetes.io/hostname` in `requiredDuringSchedulingRequiredDuringExecution`. Requires the `operator.openshift.io/v1` API.

LimitRanger::
This admission controller will observe the incoming request and ensure that it does not violate any of the constraints enumerated in the LimitRange object in a Namespace. If you are using LimitRange objects in your Kubernetes deployment, you MUST use this admission controller to enforce those constraints.

MutatingAdmissionWebhook::
This *beta* admission controller calls any mutating webhooks which match the request. Matching webhooks are called in serial; each one may modify the object if it desires.

NamespaceLifecycle::
This admission controller enforces that a Namespace that is undergoing termination cannot have new objects created in it and ensures that requests in a non-existent Namespace are rejected.

OriginPodNodeEnvironment::
This admission controller 

OwnerReferencesPermissionEnforcement::
This admission controller protects the access to the metadata.ownerReferences of an object so that only users with “delete” permission to the object can change it. 

PersistentVolumeClaimResize::
This admission controller implements additional validations for checking incoming PersistentVolumeClaim resize requests.

PodNodeConstraints::
This admission controller restricts the set of node selectors that can appear on a pod unless they have pods/binding perm.  Requires the `autoscaling.openshift.io` API.

PodNodeSelector::
This admission controller defaults and limits which node selectors can be used within a namespace by reading a namespace annotation and a global configuration. Requires the `operator.openshift.io/v1` API.

PodNodeSelector uses a configuration file to set options for the behavior of the backend. Note that the configuration file format will move to a versioned file in a future release. This file may be json or yaml and has the following format:

----
podNodeSelectorPluginConfig:
 clusterDefaultNodeSelector: name-of-node-selector
 namespace1: name-of-node-selector
 namespace2: name-of-node-selector
----

PodTolerationRestriction::
This admission controller first verifies any conflict between a pod’s tolerations and its namespace’s tolerations, and rejects the pod request if there is a conflict. It then merges the namespace’s tolerations into the pod’s tolerations. The resulting tolerations are checked against the namespace’s whitelist of tolerations. If the check succeeds, the pod request is admitted otherwise rejected. Requires the `operator.openshift.io/v1` API.

If the pod’s namespace does not have any associated default or whitelist of tolerations, then the cluster-level default or whitelist of tolerations are used instead if specified.

Tolerations to a namespace are assigned with the `scheduler.alpha.kubernetes.io/defaultTolerations` and `scheduler.alpha.kubernetes.io/tolerationsWhitelist` annotation keys.

Priority::
The priority admission controller uses the `priorityClassName` field and populates the integer value of the priority. If the priority class is not found, the Pod is rejected. Requires the `operator.openshift.io/v1` API.

ResourceQuota::
This admission controller will observe the incoming request and ensure that it does not violate any of the constraints enumerated in the ResourceQuota object in a Namespace. If you are using ResourceQuota objects in your Kubernetes deployment, you MUST use this admission controller to enforce quota constraints.

RunOnceDuration::
This admission controller specifies a maximum duration a run-once pod can run to completion.  Requires the `autoscaling.openshift.io` API.

ServiceAccount::
This admission controller implements automation for ServiceAccount objects.

ValidatingAdmissionWebhook::
This *beta* admission controller calls any validating webhooks which match the request. Matching webhooks are called in parallel; if any of them rejects the request, the request fails. 
