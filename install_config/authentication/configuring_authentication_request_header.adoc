[[install-config-configuring-authentication-request]]
= Configuring the Request Header Identity Provider
{product-author}
{product-version}
:data-uri:
:icons:
:experimental:
:toc: macro
:toc-title:
:prewrap!:

toc::[]

== Overview


You can configure the {product-title} master configuration file to use the Request Header identity provider for authentication within your cluster.

== Configuring Request Header Authentication

Set `RequestHeaderIdentityProvider` in the `identityProviders` stanza to
identify users from request header values, such as `X-Remote-User`. It is
typically used in combination with an xref:RequestHeaderIdentityProviderProxy[authenticating proxy], which sets the
request header value.

Perform either of the following changes on the master node.

* xref:redirect-www-challenges[Redirect unauthenticated requests from clients expecting `WWW-Authenticate` challenges.]
* xref:redirect-browser-based-requests[Redirect unauthenticated requests from clients expecting browser-based login flows.]


[[redirect-www-challenges]]
=== Configuring for WWW-Authenticate Challenges

To redirect unauthenticated requests from clients expecting `WWW-Authenticate` challenges.

. Edit the master configuration file using the xref:reqhead-ww-auth-optional[example below]:
+
----
/etc/origin/master/master-config.yaml
----

. Set the `challenge` parameter to `true`.
+
----
oauthConfig:
  ...
  identityProviders:
  - challenge: true
----
+
When true, unauthenticated token requests from non-web clients (like the CLI) are sent a `WWW-Authenticate` challenge header. Not supported by all identity providers.
To prevent cross-site request forgery (CSRF) attacks against browser clients Basic authentication challenges are only sent if a X-CSRF-Token header is present on the request. Clients that expect to receive Basic `WWW-Authenticate` challenges should set this header to a non-empty value.

. Specify the `mappingMethod` parameter to determine how identities are mapped to users.
include::install_config/authentication/configuring_authentication_allow_all.adoc[tag=configuring_authentication_common_steps2]

. Set the `name` parameter to an appropriate string. This provider name is prefixed to provider user names to form an identity name.
+
----
name: my_ww_authenticate_provider
----

. Set the `provider.challengeURL` parameter to the authenticating proxy URL that
will authenticate clients expecting `WWW-Authenticate` challenges and then proxy
the request to `\https://<master>/oauth/authorize`.
+
[[requestheaderidp-urlquerytokens]]
The `provider.challengeURL` parameters can include
the following tokens in the query portion of the URL:
+
// tag::IDP-urlquerytokens[]
*** `${url}` is replaced with the current URL, escaped to be safe in a query parameter.
+
For example: `\https://www.example.com/sso-login?then=${url}`

*** `${query}` is replaced with the current query string, unescaped.
+
For example: `\https://www.example.com/auth-proxy/oauth/authorize?${query}`
+
[WARNING]
====
If you expect unauthenticated requests to reach the OAuth server, a `clientCA`
parameter MUST be set for this identity provider, so that incoming requests
are checked for a valid client certificate before the request's headers are
checked for a user name. Otherwise, any direct request to the OAuth server can
impersonate any identity from this provider, merely by setting a request header.
====
// end::IDP-urlquerytokens[]
+
.Master Configuration Using `WW-Authenticate`
====

----
oauthConfig:
  ...
  identityProviders:
  - challenge: true 
    login: true
    mappingMethod: claim
    name: my_ww_authenticate_provider 
    provider:
      apiVersion: v1
      kind: RequestHeaderIdentityProvider <1>
      challengeURL: "https://www.example.com/challenging-proxy/oauth/authorize?${query}" <2>
----
<1> Specify *_RequestHeaderIdentityProvider_* as the provider kind.
<2> URL to redirect unauthenticated `/oauth/authorize` requests to,
that will authenticate browser-based clients and then proxy their request to `\https://<master>/oauth/authorize`.
The URL that proxies to `\https://<master>/oauth/authorize` must end with `/authorize` (with no trailing slash),
and also proxy subpaths, in order for OAuth approval flows to work properly.
`${url}` is replaced with the current URL, escaped to be safe in a query parameter.
`${query}` is replaced with the current query string.

====

. In the *_provider_* stanza, specify the header names to check, in order, for the user identity. The first header containing
a value is used as the identity. This parameter is case-insensitive.
+
----
 provider:
      headers: 
      - X-Remote-User
      - SSO-User
----

. Set the optional parameters, as needed.
+
[[reqhead-ww-auth-optional]]
.Optional parameters
====
----
oauthConfig:
  ...
  identityProviders:
  - name: my_request_header_provider
    challenge: true
    login: true
    mappingMethod: claim
    provider:
      apiVersion: v1
      kind: RequestHeaderIdentityProvider
      challengeURL: "https://www.example.com/challenging-proxy/oauth/authorize?${query}"
      loginURL: "https://www.example.com/login-proxy/oauth/authorize?${query}"
      clientCA: /path/to/client-ca.file <1>
      clientCommonNames: <2>
      - my-auth-proxy
      headers: <3>
      - X-Remote-User
      - SSO-User
      emailHeaders: <4>
      - X-Remote-User-Email
      nameHeaders: <5>
      - X-Remote-User-Display-Name
      preferredUsernameHeaders: <6>
      - X-Remote-User-Login
----
<1> Optional: PEM-encoded certificate bundle. If set, a valid client certificate
must be presented and validated against the certificate authorities in the
specified file before the request headers are checked for user names.
<2> Optional: list of common names (`cn`). If set, a valid client certificate with
a Common Name (`cn`) in the specified list must be presented before the request headers
are checked for user names. If empty, any Common Name is allowed. Can only be used in combination
with `clientCA`.
<3> Optional: Header names to check, in order, for an email address. The first header containing
a value is used as the email address. This parameter is case-insensitive.
<4> Optional: Header names to check, in order, for a display name. The first header containing
a value is used as the display name. This parameter is case-insensitive.
<5> Optional: Header names to check, in order, for a preferred user name, if different than the immutable
identity determined from the headers specified in `headers`. The first header containing
a value is used as the preferred user name when provisioning. This parameter is case-insensitive.
====

include::install_config/authentication/configuring_authentication_allow_all.adoc[tag=restart-after-config-master]

. xref:RequestHeaderIdentityProviderProxy[Configure the Authentication Proxy].


[[redirect-browser-based-requests]]
=== Configuring for Browser-Based Requests

To redirect unauthenticated requests from clients expecting browser-based login flows:

. Edit the master configuration file using the xref:reqhead-ww-auth-optional[example below].
+
----
/etc/origin/master/master-config.yaml
----
+
. Set the `login` parameter to `true`.
+
----
oauthConfig:
  ...
  identityProviders:
  - challenge:
    login: true
----
+
`RequestHeaderIdentityProvider` can only respond to clients requesting a login flow by redirecting to a configured loginURL. The configured URL should respond with a login flow.

.  Specify the `mappingMethod` parameter to determine how identities are mapped to users. 
include::install_config/authentication/configuring_authentication_allow_all.adoc[tag=configuring_authentication_common_steps2]

. Set the `name` parameter to an appropriate string. This provider name is prefixed to provider user names to form an identity name.
+
----
name: my_request_header_provider
----

. Set the `provider.loginURL` parameter to the authenticating proxy URL that
will authenticate interactive clients and then proxy the request to `\https://<master>/oauth/authorize`.
+
The `provider.loginURL` parameter can include
the following tokens in the query portion of the URL:
+
include::install_config/authentication/configuring_authentication_request_header.adoc[tag=IDP-urlquerytokens]
+
[[reqhead-auth-example-config]]
.Master Configuration Using `RequestHeaderIdentityProvider`
====

----
oauthConfig:
  ...
  identityProviders:
  - challenge: true 
    login: true
    mappingMethod: claim
    name: my_request_header_provider
    provider:
      apiVersion: v1
      kind: RequestHeaderIdentityProvider
      challengeURL: "https://www.example.com/challenging-proxy/oauth/authorize?${query}"
      loginURL: "https://www.example.com/login-proxy/oauth/authorize?${query}" <3>
----
<1> Specify *_RequestHeaderIdentityProvider_* as the provider kind.
<2> URL to redirect unauthenticated `/oauth/authorize` requests to,
that will authenticate clients which expect `WWW-Authenticate` challenges, and then proxy them to `\https://<master>/oauth/authorize`.
`${url}` is replaced with the current URL, escaped to be safe in a query parameter.
`${query}` is replaced with the current query string.
====

. Set the optional parameters, as xref:reqhead-ww-auth-optional[described in the previous section].

include::install_config/authentication/configuring_authentication_allow_all.adoc[tag=restart-after-config-master]

. xref:RequestHeaderIdentityProviderProxy[Configure the Authentication Proxy].


[[RequestHeaderIdentityProviderProxy]]
== Configuring the Apache Authentication Proxy

////
This is similar to how
link:https://access.redhat.com/documentation/en-US/OpenShift_Enterprise/2/html/Deployment_Guide/Configuring_OpenShift_Enterprise_Authentication.html[the remote user plug-in in OpenShift Enterprise 2] allowed administrators to
provide Kerberos, LDAP, and many other forms of enterprise authentication.
////

When using `RequestHeaderIdentityProvider`, users must access
`\https://<master>/oauth/authorize` (and subpaths) through an authenticating proxy.
To accomplish this, configure the OAuth server to redirect unauthenticated
requests for OAuth tokens to the proxy endpoint that proxies to `\https://<master>/oauth/authorize`.

This example configures an authentication proxy on the same host as the master.
Having the proxy and master is one option and might not
be suitable for your environment. For example, if you were already
xref:../../install_config/router/index.adoc#install-config-router-overview[running a router] on the
master, port 443 would not be available.

It is also important to note that while this reference configuration uses
Apache's `mod_auth_form`, it is not required and other proxies can be used if the following requirements are met:

* Block the `X-Remote-User` header from client requests to prevent spoofing.
* Enforce client certificate authentication in the `RequestHeaderIdentityProvider` configuration.
* Require the `X-Csrf-Token` header be set for all authentication request using the challenge flow.
* Only the `/oauth/authorize` endpoint and its subpaths should be proxied,
and redirects should not be rewritten to allow the backend server to send the client to the correct
location.
* The URL that proxies to `\https://<master>/oauth/authorize` must end with `/authorize` (with no trailing slash). For example:
+
`\https://proxy.example.com/login-proxy/authorize?...` -> `\https://<master>/oauth/authorize?...`
* Subpaths of the URL that proxies to `\https://<master>/oauth/authorize` must proxy to subpaths of `\https://<master>/oauth/authorize`. For example:
+
`\https://proxy.example.com/login-proxy/authorize/approve?...` -> `\https://<master>/oauth/authorize/approve?...`


=== Installing the Prerequisites

Perform the following tasks:

. The `mod_auth_form` module is shipped as part of the `mod_session` package that
is found in the link:https://access.redhat.com/solutions/392003[Optional channel].
+
----
# yum install -y httpd mod_ssl mod_session apr-util-openssl
----

. Generate a CA for validating requests that submit the trusted header. This CA
should be used as the file name for `clientCA` in the
xref:requestheader-master-ca-config[master's identity provider configuration].
+
----
# oadm ca create-signer-cert \
  --cert='/etc/origin/master/proxyca.crt' \
  --key='/etc/origin/master/proxyca.key' \
  --name='openshift-proxy-signer@1432232228' \
  --serial='/etc/origin/master/proxyca.serial.txt'
----
+
[NOTE]
The `oadm ca create-signer-cert` command generates a certificate that is valid
for five years. This can be altered with the `--expire-days` option, but for
security reasons, it is recommended to not make it greater than this
value.

. Generate a client certificate for the proxy. This can be done using any x509
certificate tooling. For convenience, the `oadm` CLI can be used:
+
----
# oadm create-api-client-config \
  --certificate-authority='/etc/origin/master/proxyca.crt' \
  --client-dir='/etc/origin/master/proxy' \
  --signer-cert='/etc/origin/master/proxyca.crt' \
  --signer-key='/etc/origin/master/proxyca.key' \
  --signer-serial='/etc/origin/master/proxyca.serial.txt' \
  --user='system:proxy' <1>

# pushd /etc/origin/master
# cp master.server.crt /etc/pki/tls/certs/localhost.crt <2>
# cp master.server.key /etc/pki/tls/private/localhost.key
# cp ca.crt /etc/pki/CA/certs/ca.crt
# cat proxy/system\:proxy.crt \
  proxy/system\:proxy.key > \
  /etc/pki/tls/certs/authproxy.pem
# popd
----
<1> The user name can be anything, however it is useful to give it a descriptive
name as it will appear in logs.
<2> When running the authentication proxy on a different host name than the
master, it is important to generate a certificate that matches the host name
instead of using the default master certificate as shown above. The value for
`masterPublicURL` in the *_/etc/origin/master/master-config.yaml_* file
must be included in the `X509v3 Subject Alternative Name` in the certificate
that is specified for `SSLCertificateFile`. If a new certificate needs to be
created, the `oadm ca create-server-cert` command can be used.
+
[NOTE]
The `oadm create-api-client-config` command generates a certificate that is
valid for two years. This can be altered with the `--expire-days` option, but
for security reasons, it is recommended to not make it greater than
this value.


=== Configuring Apache

This proxy does not need to reside on the same
host as the master. It uses a client certificate to connect to the master, which
is configured to trust the `X-Remote-User` header.

Configure Apache using the following example:

----
LoadModule auth_form_module modules/mod_auth_form.so
LoadModule session_module modules/mod_session.so
LoadModule request_module modules/mod_request.so

# Nothing needs to be served over HTTP.  This virtual host simply redirects to
# HTTPS.
<VirtualHost *:80>
  DocumentRoot /var/www/html
  RewriteEngine              On
  RewriteRule     ^(.*)$     https://%{HTTP_HOST}$1 [R,L]
</VirtualHost>

<VirtualHost *:443>
  # This needs to match the certificates you generated.  See the CN and X509v3
  # Subject Alternative Name in the output of:
  # openssl x509 -text -in /etc/pki/tls/certs/localhost.crt
  ServerName www.example.com

  DocumentRoot /var/www/html
  SSLEngine on
  SSLCertificateFile /etc/pki/tls/certs/localhost.crt
  SSLCertificateKeyFile /etc/pki/tls/private/localhost.key
  SSLCACertificateFile /etc/pki/CA/certs/ca.crt

  SSLProxyEngine on
  SSLProxyCACertificateFile /etc/pki/CA/certs/ca.crt
  # It's critical to enforce client certificates on the Master.  Otherwise
  # requests could spoof the X-Remote-User header by accessing the Master's
  # /oauth/authorize endpoint directly.
  SSLProxyMachineCertificateFile /etc/pki/tls/certs/authproxy.pem

  # Send all requests to the console
  RewriteEngine              On
  RewriteRule     ^/console(.*)$     https://%{HTTP_HOST}:8443/console$1 [R,L]

  # In order to using the challenging-proxy an X-Csrf-Token must be present.
  RewriteCond %{REQUEST_URI} ^/challenging-proxy
  RewriteCond %{HTTP:X-Csrf-Token} ^$ [NC]
  RewriteRule ^.* - [F,L]

  <Location /challenging-proxy/oauth/authorize>
    # Insert your backend server name/ip here.
    ProxyPass https://[MASTER]:8443/oauth/authorize
    AuthType basic
  </Location>

  <Location /login-proxy/oauth/authorize>
    # Insert your backend server name/ip here.
    ProxyPass https://[MASTER]:8443/oauth/authorize

    # mod_auth_form providers are implemented by mod_authn_dbm, mod_authn_file,
    # mod_authn_dbd, mod_authnz_ldap and mod_authn_socache.
    AuthFormProvider file
    AuthType form
    AuthName openshift
    ErrorDocument 401 /login.html
  </Location>

  <ProxyMatch /oauth/authorize>
    AuthUserFile /etc/origin/master/htpasswd
    AuthName openshift
    Require valid-user
    RequestHeader set X-Remote-User %{REMOTE_USER}s env=REMOTE_USER

    # For ldap:
    # AuthBasicProvider ldap
    # AuthLDAPURL "ldap://ldap.example.com:389/ou=People,dc=my-domain,dc=com?uid?sub?(objectClass=*)"

    # It's possible to remove the mod_auth_form usage and replace it with
    # something like mod_auth_kerb, mod_auth_gsspai or even mod_auth_mellon.
    # The former would be able to support both the login and challenge flows
    # from the Master.  Mellon would likely only support the login flow.

    # For Kerberos
    # yum install mod_auth_gssapi
    # AuthType GSSAPI
    # GssapiCredStore keytab:/etc/httpd.keytab
  </ProxyMatch>

</VirtualHost>

RequestHeader unset X-Remote-User
----


=== Additional mod_auth_form Requirements

A sample login page is available from the
link:https://github.com/openshift/openshift-extras/tree/master/misc/form_auth[openshift_extras]
repository. This file should be placed in the `DocumentRoot` location
(*_/var/www/html_* by default).

. Create the users in the system Apache is using to store
accounts information. In this example, file-backed authentication is used:
+
----
# yum -y install httpd-tools
# touch /etc/origin/master/htpasswd
# htpasswd /etc/origin/master/htpasswd <username>
----

. Update the `identityProviders` stanza in the
*_/etc/origin/master/master-config.yaml_* file:
+
[[requestheader-master-ca-config]]
----
  identityProviders:
  - name: requestheader
    challenge: true
    login: true
    provider:
      apiVersion: v1
      kind: RequestHeaderIdentityProvider
      challengeURL: "https://[MASTER]/challenging-proxy/oauth/authorize?${query}"
      loginURL: "https://[MASTER]/login-proxy/oauth/authorize?${query}"
      clientCA: /etc/origin/master/proxyca.crt
      headers:
      - X-Remote-User
----

. Restart the following services:
+
----
# systemctl restart httpd
ifdef::openshift-origin[]
# systemctl restart origin-master
endif::[]
ifdef::openshift-enterprise[]
# systemctl restart atomic-openshift-master
endif::[]
----


== Verifying the Configuration

To verify the Apache configuration:

. Test by bypassing the proxy. You should be able to request a token if you
supply the correct client certificate and header:
+
----
# curl -L -k -H "X-Remote-User: joe" \
   --cert /etc/pki/tls/certs/authproxy.pem \
   https://[MASTER]:8443/oauth/token/request
----

. If you do not supply the client certificate, the request should be denied:
+
----
# curl -L -k -H "X-Remote-User: joe" \
   https://[MASTER]:8443/oauth/token/request
----

. This should show a redirect to the configured `challengeURL` (with
additional query parameters):
+
----
# curl -k -v -H 'X-Csrf-Token: 1' \
   '<masterPublicURL>/oauth/authorize?client_id=openshift-challenging-client&response_type=token'
----

. This should show a 401 response with a `WWW-Authenticate` basic challenge:
+
----
#  curl -k -v -H 'X-Csrf-Token: 1' \
    '<redirected challengeURL from step 3 +query>'
----

. This should show a redirect with an access token:
+
----
#  curl -k -v -u <your_user>:<your_password> \
    -H 'X-Csrf-Token: 1' '<redirected_challengeURL_from_step_3 +query>'
----
