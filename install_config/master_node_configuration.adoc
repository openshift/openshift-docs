[[install-config-master-node-configuration]]
= Master and Node Configuration
{product-author}
{product-version}
:data-uri:
:icons:
:experimental:
:toc: macro
:toc-title:

toc::[]

The `openshift start` command and its subcommands (`master` to launch a
xref:../architecture/infrastructure_components/kubernetes_infrastructure.adoc#master[master
server] and `node` to launch a
xref:../architecture/infrastructure_components/kubernetes_infrastructure.adoc#node[node
server]) take a limited set of arguments that are sufficient for launching
servers in a development or experimental environment.

However, these arguments are insufficient to describe and control the full set
of configuration and security options that are necessary in a production
environment. To provide those options, it is necessary to use the master and
node configuration files:

* xref:../architecture/infrastructure_components/kubernetes_infrastructure.adoc#master[Master] host files at xref:../install_config/master_node_configuration.adoc#master-configuration-files[*_/etc/origin/master/master-config.yaml_*]

* xref:../architecture/infrastructure_components/kubernetes_infrastructure.adoc#node[Node] host files at xref:../install_config/master_node_configuration.adoc#node-configuration-files[*_/etc/origin/node/node-config.yaml_*]

These files define options including overriding the default plug-ins, connecting
to etcd, automatically creating service accounts, building image names,
customizing project requests, configuring volume plug-ins, and much more.

This topic covers the available options for customizing your {product-title}
master and node hosts, and shows you how to make changes to the configuration
after installation.

These files are fully specified with no default values. Therefore, an empty
value indicates that you want to start up with an empty value for that
parameter. This makes it easy to reason about exactly what your configuration
is, but it also makes it difficult to remember all of the options to specify. To
make this easier, the configuration files can be created with the
`--write-config` option and then used with the `--config` option.

[[master-node-config-prereq]]
== Installation dependencies

Production environments should be installed using the standard xref:../install/index.adoc#install-planning[cluster installation]
process. In production environments, it is a good idea to use
xref:../install/example_inventories.adoc#multiple-masters[multiple masters] for the purposes of
xref:../admin_guide/high_availability.adoc#admin-guide-high-availability[high availability] (HA).
A cluster architecture of three masters is recommended, and
xref:../architecture/infrastructure_components/kubernetes_infrastructure.adoc#master[HAproxy] is the recommended solution for this.

[CAUTION]
====
If etcd is installed on the _master hosts_, you must configure your cluster to
use at least three masters, because etcd would not be able to decide which one
is authoritative. The only way to successfully run only two masters is if you
install etcd on hosts other than the masters.
====

[[master-node-config-masters-nodes]]
== Configuring masters and nodes

The method you use to configure your master and node configuration files must
match the method that was used to install your {product-title} cluster. If you
followed the standard xref:../install/index.adoc#install-planning[cluster
installation] processe, then make your configuration changes in the Ansible
inventory file.

ifdef::openshift-origin[]
If you followed the
link:https://docs.openshift.org/latest/getting_started/administrators.html[Manual installation] method, then make your changes
xref:../install_config/master_node_configuration.adoc#master-node-config-manual[manually
in the configuration files] themselves.
endif::openshift-origin[]


[[master-node-config-ansible]]
== Making configuration changes using Ansible

For this section, familiarity with Ansible is assumed.

Only a portion of the available host configuration options are
https://github.com/openshift/openshift-ansible/blob/master/inventory/hosts.example[exposed to Ansible].
After an {product-title} install, Ansible creates an
inventory file with some substituted values. Modifying this inventory file and re-running the Ansible installer playbook is how you customize your {product-title} cluster.

While {product-title} supports using Ansible for cluster installation, using an Ansible playbook and inventory file, you can also use other management tools, such as
https://puppet.com/[Puppet], https://www.chef.io/[Chef],
http://saltstack.com/[Salt]).

[[config-htpasswd]]
*Use Case: Configuring the cluster to use HTPasswd authentication*

[NOTE]
====
* This use case assumes you have already set up
xref:../install/host_preparation.adoc#ensuring-host-access[SSH keys] to all the nodes referenced in the playbook.

* The `htpasswd` utility is in the `httpd-tools` package:
+
----
# yum install httpd-tools
----
====

To modify the Ansible inventory and make configuration changes:

. Open the *_./hosts_* inventory file:
+
.Sample inventory file:
====
----
[OSEv3:children]
masters
nodes

[OSEv3:vars]
ansible_ssh_user=cloud-user
ansible_become=true
openshift_deployment_type=openshift-enterprise

[masters]
ec2-52-6-179-239.compute-1.amazonaws.com  openshift_ip=172.17.3.88 openshift_public_ip=52-6-179-239 openshift_hostname=master.example.com  openshift_public_hostname=ose3-master.public.example.com containerized=True
[nodes]
ec2-52-6-179-239.compute-1.amazonaws.com  openshift_ip=172.17.3.88 openshift_public_ip=52-6-179-239 openshift_hostname=master.example.com  openshift_public_hostname=ose3-master.public.example.com containerized=True openshift_schedulable=False
ec2-52-95-5-36.compute-1.amazonaws.com  openshift_ip=172.17.3.89 openshift_public_ip=52.3.5.36 openshift_hostname=node.example.com openshift_public_hostname=ose3-node.public.example.com containerized=True
----
====
+
. Add the following new variables to the `[OSEv3:vars]` section of the file:
+
----
# htpasswd auth
openshift_master_identity_providers=[{'name': 'htpasswd_auth', 'login': 'true', 'challenge': 'true', 'kind': 'HTPasswdPasswordIdentityProvider'}]
# Defining htpasswd users
openshift_master_htpasswd_users={'<name>': '<hashed-password>', '<name>': '<hashed-password>'}
# or
#openshift_master_htpasswd_file=<path/to/local/pre-generated/htpasswdfile>
----
+
For HTPasswd authentication, you can use either the `openshift_master_htpasswd_users` variable to create the specified user(s) and password(s) or the `openshift_master_htpasswd_file` variable to specify a pre-generated flat file (the _htpasswd_ file) with the users and passwords already created.
+
Because {product-title} requires a hashed password to configure HTPasswd authentication, you can use the `htpasswd` command, xref:htpasswd[as shown in the following section], to generate the hashed password(s) for your user(s) or to create the flat file with the users and associated hashed passwords.
+
The following example changes the authentication method from the default `deny all` setting to `htpasswd` and use the specified file to generate user IDs and passwords for the `jsmith` and `bloblaw` users.
+
----
# htpasswd auth
openshift_master_identity_providers=[{'name': 'htpasswd_auth', 'login': 'true', 'challenge': 'true', 'kind': 'HTPasswdPasswordIdentityProvider'}]
# Defining htpasswd users
openshift_master_htpasswd_users={'jsmith': '$apr1$wIwXkFLI$bAygtKGmPOqaJftB', 'bloblaw': '7IRJ$2ODmeLoxf4I6sUEKfiA$2aDJqLJe'}
# or
#openshift_master_htpasswd_file=<path/to/local/pre-generated/htpasswdfile>
----

. Re-run the ansible playbook for these modifications to take effect:
+
----
$ ansible-playbook -b -i ./hosts ~/src/openshift-ansible/playbooks/deploy_cluster.yml
----
+
The playbook updates the configuration, and restarts the {product-title} master service to apply the changes.

You have now modified the master and node configuration files using Ansible, but this is just a simple use case. From here you can see which
xref:../install_config/master_node_configuration.adoc#master-configuration-files[master] and
xref:../install_config/master_node_configuration.adoc#node-configuration-files[node configuration] options are
https://github.com/openshift/openshift-ansible/blob/master/inventory/hosts.example[exposed to Ansible] and customize your own Ansible inventory.

[[htpasswd]]
=== Using the `htpasswd` commmand

To configure the {product-title} cluster to use HTPasswd authentication, you need at least one user with a hashed password to include in the xref:config-htpasswd[inventory file].

You can:

* xref:htpasswd-user[Generate the username and password] to add directly to the *_./hosts_* inventory file.
* xref:htpasswd-file[Create a flat file] to pass the credentials to the *_./hosts_* inventory file.


[[htpasswd-user]]
To create a user and hashed password:

. Run the following command to add the specified user:
+
----
$ htpasswd -n <user_name>
----
+
[NOTE]
====
You can include the `-b` option to supply the password on the command line:

----
$ htpasswd -nb <user_name> <password>
----
====

. Enter and confirm a clear-text password for the user.
+
For example:
+
----
$ htpasswd -n myuser
New password:
Re-type new password:
myuser:$apr1$vdW.cI3j$WSKIOzUPs6Q
----
+
The command generates a hashed version of the password.

You can then use the hashed password when configuring xref:config-htpasswd[HTPasswd authentication]. The hashed password is the string after the `:`. In the above example,you would enter:

----
openshift_master_htpasswd_users={'myuser': '$apr1$wIwXkFLI$bAygtISk2eKGmqaJftB'}
----

[[htpasswd-file]]
To create a flat file with a user name and hashed password:

. Execute the following command:
+
----
$ htpasswd -c </path/to/users.htpasswd> <user_name>
----
+
[NOTE]
====
You can include the `-b` option to supply the password on the command line:

----
$ htpasswd -c -b <user_name> <password>
----
====

. Enter and confirm a clear-text password for the user.
+
For example:
+
----
htpasswd -c users.htpasswd user1
New password:
Re-type new password:
Adding password for user user1
----
+
The command generates a file that includes the user name and a hashed version of the user's password.

You can then use the password file when configuring xref:config-htpasswd[HTPasswd authentication].

[NOTE]
====
For more information on the `htpasswd` command, see xref:../install_config/configuring_authentication.adoc#HTPasswdPasswordIdentityProvider[HTPasswd Identity Provider].
====

[[master-node-config-manual]]
== Making manual configuration changes

*Use Case: Configure the cluster to use HTPasswd authentication*

To manually modify a configuration file:

. Open the configuration file you want to modify, which in this case is the *_/etc/origin/master/master-config.yaml_* file:
+
. Add the following new variables to the `*identityProviders*` stanza of the file:
+
----
oauthConfig:
  ...
  identityProviders:
  - name: my_htpasswd_provider
    challenge: true
    login: true
    mappingMethod: claim
    provider:
      apiVersion: v1
      kind: HTPasswdPasswordIdentityProvider
      file: /path/to/users.htpasswd
----
. Save your changes and close the file.
. Restart the master for the changes to take effect:
+
----
$ master-restart api
$ master-restart controllers
----

You have now manually modified the master and node configuration files,
but this is just a simple use case.
From here you can see all the
xref:../install_config/master_node_configuration.adoc#master-configuration-files[master] and
xref:../install_config/master_node_configuration.adoc#node-configuration-files[node configuration] options, and further customize your own cluster by making further modifications.

[[master-configuration-files]]
== Master Configuration Files
This section reviews parameters mentioned in the *_master-config.yaml_* file.

You can xref:creating-new-configuration-files[create a new master configuration
file] to see the valid options for your installed version of {product-title}.

[IMPORTANT]
====
Whenever you modify the *_master-config.yaml_* file, you must restart the master
for the changes to take effect. See xref:master-node-config-restart-services[Restarting {product-title} services].
====

[[master-config-admission-control-config]]
=== Admission Control Configuration

.Admission Control Configuration Parameters
[cols="3a,6a",options="header"]
|===

| Parameter Name | Description

|`*AdmissionConfig*`
|Contains the xref:../architecture/additional_concepts/admission_controllers.adoc#architecture-additional-concepts-admission-controllers[admission control plug-in] configuration. {product-title} has a configurable list of admission controller plug-ins that are triggered whenever API objects are created or modified. This option allows you to override the default list of plug-ins; for example, disabling some plug-ins, adding others, changing the ordering, and specifying configuration. Both the list of plug-ins and their configuration can be controlled from Ansible.

|`*APIServerArguments*`
|Key-value pairs that will be passed directly to the Kube API server that match
the API servers' command line arguments. These are not migrated, but if you
reference a value that does not exist the server will not start. These values
may override other settings in `*KubernetesMasterConfig*`, which may cause
invalid configurations. Use `APIServerArguments` with the `event-ttl` value to store events in etcd. The default is `2h`, but it can be set to less to prevent memory growth:

----
apiServerArguments:
  event-ttl:
  - "15m"
----

|`*ControllerArguments*`
|Key-value pairs that will be passed directly to the Kube controller manager
that match the controller manager's command line arguments. These are not
migrated, but if you reference a value that does not exist the server will not
start. These values may override other settings in `*KubernetesMasterConfig*`,
which may cause invalid configurations.

|`*DefaultAdmissionConfig*`
|Used to enable or disable various admission plug-ins. When this type is present
as the *configuration* object under `*pluginConfig*` and if the admission
plug-in supports it, this will cause an *off by default* admission plug-in to be
enabled.

|`*PluginConfig*`
|Allows specifying a configuration file per admission control plug-in.

|`*PluginOrderOverride*`
|A list of admission control plug-in names that will be installed on the master.
Order is significant. If empty, a default list of plug-ins is used.

|`*SchedulerArguments*`
|Key-value pairs that will be passed directly to the Kube scheduler that match
the scheduler's command line arguments. These are not migrated, but if you
reference a value that does not exist the server will not start. These values
may override other settings in `*KubernetesMasterConfig*`, which may cause
invalid configurations.

|===


[[master-config-asset-config]]
=== Asset Configuration

.Asset Configuration Parameters
[cols="3a,6a",options="header"]
|===

| Parameter Name | Description

|`*AssetConfig*`
|If present, then the asset server starts based on the defined parameters. For example:
----
assetConfig:
  logoutURL: ""
  masterPublicURL: https://master.ose32.example.com:8443
  publicURL: https://master.ose32.example.com:8443/console/
  servingInfo:
    bindAddress: 0.0.0.0:8443
    bindNetwork: tcp4
    certFile: master.server.crt
    clientCA: ""
    keyFile: master.server.key
    maxRequestsInFlight: 0
    requestTimeoutSeconds: 0
----

|`*corsAllowedOrigins*`
|To access the API server from a web application using a different host name, you
must whitelist that host name by specifying `corsAllowedOrigins` in the
configuration field or by specifying the `--cors-allowed-origins` option on
`openshift start`. No pinning or escaping is done to the value. See
xref:../architecture/infrastructure_components/web_console.adoc#corsAllowedOrigins[Web
Console] for example usage.

|`*DisabledFeatures*`
|A list of features that should not be started. You will likely want to set this
as *null*. It is very unlikely that anyone will want to manually disable
features and that is not encouraged.

|`*Extensions*`
|Files to serve from the asset server file system under a subcontext.

|`*ExtensionDevelopment*`
|When  set to *true*, tells the asset server to reload extension scripts and
stylesheets for every request rather than only at startup. It lets you develop
extensions without having to restart the server for every change.

|`*ExtensionProperties*`
|Key- (string) and value- (string) pairs that will be injected into the console under
the global variable `*OPENSHIFT_EXTENSION_PROPERTIES*`.

|`*ExtensionScripts*`
|File paths on the asset server files to load as scripts when the web console loads.

|`*ExtensionStylesheets*`
|File paths on the asset server files to load as style sheets when the web console loads.

|`*LoggingPublicURL*`
|The public endpoint for logging (optional).

|`*LogoutURL*`
|An optional, absolute URL to redirect web browsers to after logging out of the
web console. If not specified, the built-in logout page is shown.

|`*MasterPublicURL*`
|How the web console can access the {product-title} server.

|`*MetricsPublicURL*`
|The public endpoint for metrics (optional).

|`*PublicURL*`
|URL of the asset server.

|===

[[master-config-authentication-authorization-config]]
=== Authentication and Authorization Configuration

.Authentication and Authorization Parameters
[cols="3a,6a",options="header"]
|===

| Parameter Name | Description

|`*authConfig*`
|Holds authentication and authorization configuration options.

|`*AuthenticationCacheSize*`
|Indicates how many authentication results should be cached. If 0, the default
cache size is used.

|`*AuthorizationCacheTTL*`
|Indicates how long an authorization result should be cached. It takes a valid
time duration string (e.g. "5m"). If empty, you get the default timeout. If zero
(e.g. "0m"), caching is disabled.

|===

[[master-config-controller-config]]
=== Controller Configuration

.Controller Configuration Parameters
[cols="3a,6a",options="header"]
|===

| Parameter Name | Description

|`*Controllers*`
|List of the controllers that should be started. If set to *none*, no
controllers will start automatically. The default value is * which will start
all controllers. When using *, you may exclude controllers by prepending a `-`
in front of their name. No other values are recognized at this time.

|`*ControllerLeaseTTL*`
|Enables controller election, instructing the master to attempt to acquire a
lease before controllers start and renewing it within a number of seconds
defined by this value. Setting this value non-negative forces
`*pauseControllers=true*`. This value defaults off (0, or omitted) and controller
election can be disabled with -1.

|`*PauseControllers*`
|Instructs the master to not automatically start controllers, but instead to
wait until a notification to the server is received before launching them.

|===


[[master-config-etcd]]
=== etcd Configuration

.etcd Configuration Parameters
[cols="3a,6a",options="header"]
|===

| Parameter Name | Description

|`*Address*`
|The advertised host:port for client connections to etcd.

|`*etcdClientInfo*`
|Contains information about how to connect to etcd. Specifies if etcd is run as embedded or non-embedded, and the hosts. The rest of the configuration is handled by the Ansible inventory. For example:
----
etcdClientInfo:
  ca: ca.crt
  certFile: master.etcd-client.crt
  keyFile: master.etcd-client.key
  urls:
  - https://m1.aos.example.com:4001
----

|`*etcdConfig*`
|If present, then etcd starts based on the defined parameters. For example:
----
etcdConfig:
  address: master.ose32.example.com:4001
  peerAddress: master.ose32.example.com:7001
  peerServingInfo:
    bindAddress: 0.0.0.0:7001
    certFile: etcd.server.crt
    clientCA: ca.crt
    keyFile: etcd.server.key
  servingInfo:
    bindAddress: 0.0.0.0:4001
    certFile: etcd.server.crt
    clientCA: ca.crt
    keyFile: etcd.server.key
  storageDirectory: /var/lib/origin/openshift.local.etcd
----

|`*etcdStorageConfig*`
|Contains information about how API resources are stored in etcd. These values
are only relevant when etcd is the backing store for the cluster.

|`*KubernetesStoragePrefix*`
|The path within etcd that the Kubernetes resources will be rooted under. This
value, if changed, will mean existing objects in *_etcd_* will no longer be
located. The default value is *kubernetes.io*.

|`*KubernetesStorageVersion*`
|The API version that Kubernetes resources in *_etcd_* should be serialized to.
This value should *not* be advanced until all clients in the cluster that read
from etcd have code that allows them to read the new version.

|`*OpenShiftStoragePrefix*`
|The path within etcd that the {product-title} resources will be rooted under.
This value, if changed, will mean existing objects in etcd will no longer be
located. The default value is *openshift.io*.

|`*OpenShiftStorageVersion*`
|API version that OS resources in *_etcd_* should be serialized to. This value
should *not* be advanced until all clients in the cluster that read from
*_etcd_* have code that allows them to read the new version.

|`*PeerAddress*`
|The advertised host:port for peer connections to *_etcd_*.

|`*PeerServingInfo*`
|Describes how to start serving the *_etcd_* peer.

|`*ServingInfo*`
|Describes how to start serving. For example:
----
servingInfo:
  bindAddress: 0.0.0.0:8443
  bindNetwork: tcp4
  certFile: master.server.crt
  clientCA: ca.crt
  keyFile: master.server.key
  maxRequestsInFlight: 500
  requestTimeoutSeconds: 3600
----

|`*StorageDir*`
|The path to the *_etcd_* storage directory.

|===


[[master-node-config-grant-config]]
=== Grant Configuration

.Grant Configuration Parameters
[cols="3a,6a",options="header"]
|===

| Parameter Name | Description

|`*GrantConfig*`
|Describes how to handle grants.

|`*GrantHandlerAuto*`
|Auto-approves client authorization grant requests.

|`*GrantHandlerDeny*`
|Auto-denies client authorization grant requests.

|`*GrantHandlerPrompt*`
|Prompts the user to approve new client authorization grant requests.

|`*Method*`
a|Determines the default strategy to use when an OAuth client requests a
grant.This method will be used only if the specific OAuth client does not
provide a strategy of their own. Valid grant handling methods are:

- auto: always approves grant requests, useful for trusted clients
- prompt: prompts the end user for approval of grant requests, useful for third-party clients
- deny: always denies grant requests, useful for black-listed clients

|===

[[master-config-image-config]]
=== Image Configuration

.Image Configuration Parameters
[cols="3a,6a",options="header"]
|===

| Parameter Name | Description

|`*Format*`
|The format of the name to be built for the system component.

|`*Latest*`
|Determines if the latest tag will be pulled from the registry.

|===

[[master-config-image-policy-config]]
=== Image Policy Configuration

.Image Policy Configuration Parameters
[cols="3a,6a",options="header"]
|===

| Parameter Name | Description

|`*DisableScheduledImport*`
|Allows scheduled background import of images to be disabled.

|`*MaxImagesBulkImportedPerRepository*`
|Controls the number of images that are imported when a user does a bulk import
of a Docker repository. This number defaults to 5 to prevent users from
importing large numbers of images accidentally. Set *-1* for no limit.

|`*MaxScheduledImageImportsPerMinute*`
|The maximum number of scheduled image streams that will be imported in the
background per minute. The default value is 60.

|`*ScheduledImageImportMinimumIntervalSeconds*`
|The minimum number of seconds that can elapse between when image streams
scheduled for background import are checked against the upstream repository. The
default value is 15 minutes.

|`*AllowedRegistriesForImport*`
|Limits the docker registries that normal users may import
images from. Set this list to the registries that you trust to contain valid Docker
images and that you want applications to be able to import from. Users with
permission to create Images or ImageStreamMappings via the API are not affected by
this policy - typically only administrators or system integrations will have those
permissions.

|`*InternalRegistryHostname*`
|Sets the hostname for the default internal image
registry. The value must be in `*hostname[:port]*` format.
For backward compatibility, users can still use `*OPENSHIFT_DEFAULT_REGISTRY*`
environment variable but this setting overrides the environment variable.  When
this is set, the internal registry must have its hostname set as well.
See xref:../install_config/registry/extended_registry_configuration.adoc#setting-the-registry-hostname[setting the registry hostname] for more details.

|`*ExternalRegistryHostname*`
|ExternalRegistryHostname sets the hostname for the default external image
registry. The external hostname should be set only when the image registry
is exposed externally. The value is used in `*publicDockerImageRepository*`
field in ImageStreams. The value must be in `*hostname[:port]*` format.

|===

[[master-node-config-kubernetes-master-config]]
=== Kubernetes Master Configuration

.Kubernetes Master Configuration Parameters
[cols="3a,6a",options="header"]
|===

| Parameter Name | Description

|`*APILevels*`
|A list of API levels that should be enabled on startup, v1 as examples.

|`*DisabledAPIGroupVersions*`
|A map of groups to the versions (or `*`) that should be disabled.

|`*KubeletClientInfo*`
|Contains information about how to connect to kubelets.

|`*KubernetesMasterConfig*`
|Contains information about how to connect to kubelet's KubernetesMasterConfig. If present, then start the kubernetes master with this process.

|`*MasterCount*`
|The number of expected masters that should be running. This value defaults to 1
and may be set to a positive integer, or if set to -1, indicates this is part of
a cluster.

|`*MasterIP*`
|The public IP address of Kubernetes resources. If empty, the first result from
`*net.InterfaceAddrs*` will be used.

|`*MasterKubeConfig*`
|File name for the *_.kubeconfig_* file that describes how to connect this node to the master.

|`*ServicesNodePortRange*`
|The range to use for assigning service public ports on a host. Default 30000-32767.

|`*ServicesSubnet*`
|The subnet to use for assigning service IPs.

|`*StaticNodeNames*`
|The list of nodes that are statically known.

|===

[[master-node-config-network-config]]
=== Network Configuration

Choose the CIDRs in the following parameters carefully, because the IPv4 address
space is shared by all users of the nodes. {product-title} reserves CIDRs from
the IPv4 address space for its own use, and reserves CIDRs from the IPv4
address space for addresses that are shared between the external user and the
cluster.

.Network Configuration Parameters
[cols="3a,6a",options="header"]
|===

| Parameter Name | Description

|`*ClusterNetworkCIDR*`
|The CIDR string to specify the global overlay network's L3 space. This is
reserved for the internal use of the cluster networking.

|`*ExternalIPNetworkCIDRs*`
|Controls what values are acceptable for the service external IP field. If
empty, no `*externalIP*` may be set. It may contain a list of CIDRs which are
checked for access. If a CIDR is prefixed with *!*, IPs in that CIDR will be
rejected. Rejections will be applied first, then the IP checked against one of
the allowed CIDRs. You must ensure this range does not overlap with your nodes,
pods, or service CIDRs for security reasons.

|`*HostSubnetLength*`
|The number of bits to allocate to each host's subnet. For example, 8 would mean a
/24 network on the host.

|`*IngressIPNetworkCIDR*`
|Controls the range to assign ingress IPs from for services of type
*LoadBalancer* on bare metal. It may contain a single CIDR that it will be
allocated from. By default `172.46.0.0/16` is configured. For security reasons,
you should ensure that this range does not overlap with the CIDRs reserved for
external IPs, nodes, pods, or services.

|`*HostSubnetLength*`
|The number of bits to allocate to each host's subnet. For example, 8 would mean a
/24 network on the host.

|`*NetworkConfig*`
|To be passed to the compiled-in-network plug-in. Many of the options here can be controlled in the Ansible inventory.

- `*NetworkPluginName*` (string)
- `*ClusterNetworkCIDR*` (string)
- `*HostSubnetLength*` (unsigned integer)
- `*ServiceNetworkCIDR*` (string)
- `*ExternalIPNetworkCIDRs*` (string array): Controls which values are acceptable for the service external IP field. If empty, no external IP may be set. It can contain a list of CIDRs which are checked for access. If a CIDR is prefixed with `!`, then IPs in that CIDR are rejected. Rejections are applied first, then the IP is checked against one of the allowed CIDRs. For security purposes, you should ensure this range does not overlap with your nodes, pods, or service CIDRs.

For Example:
----
networkConfig:
  clusterNetworks
  - cidr: 10.3.0.0/16
    hostSubnetLength: 8
  networkPluginName: example/openshift-ovs-subnet
# serviceNetworkCIDR must match kubernetesMasterConfig.servicesSubnet
  serviceNetworkCIDR: 179.29.0.0/16
----

|`*NetworkPluginName*`
|The name of the network plug-in to use.

|`*ServiceNetwork*`
|The CIDR string to specify the service networks.

|===

[[master-config-oath-authentication-config]]
=== OAuth Authentication Configuration

.OAuth Configuration Parameters
[cols="3a,6a",options="header"]
|===

| Parameter Name | Description

|`*AlwaysShowProviderSelection*`
|Forces the provider selection page to render even when there is only a single provider.

|`*AssetPublicURL*`
|Used for building valid client redirect URLs for external access.

|`*Error*`
|A path to a file containing a go template used to render error pages during the
authentication or grant flow If unspecified, the default error page is used.

|`*IdentityProviders*`
|Ordered list of ways for a user to identify themselves.

|`*Login*`
|A path to a file containing a go template used to render the login page. If
 unspecified, the default login page is used.

|`*MasterCA*`
|CA for verifying the TLS connection back to the `*MasterURL*`.

|`*MasterPublicURL*`
|Used for building valid client redirect URLs for external access.

|`*MasterURL*`
|Used for making server-to-server calls to exchange authorization codes for
access tokens.

|`*OAuthConfig*`
|If present, then the /oauth endpoint starts based on the defined parameters. For example:
----
oauthConfig:
  assetPublicURL: https://master.ose32.example.com:8443/console/
  grantConfig:
    method: auto
  identityProviders:
  - challenge: true
    login: true
    mappingMethod: claim
    name: htpasswd_all
    provider:
      apiVersion: v1
      kind: HTPasswdPasswordIdentityProvider
      file: /etc/origin/openshift-passwd
  masterCA: ca.crt
  masterPublicURL: https://master.ose32.example.com:8443
  masterURL: https://master.ose32.example.com:8443
  sessionConfig:
    sessionMaxAgeSeconds: 3600
    sessionName: ssn
    sessionSecretsFile: /etc/origin/master/session-secrets.yaml
  tokenConfig:
    accessTokenMaxAgeSeconds: 86400
    authorizeTokenMaxAgeSeconds: 500
----

|`*OAuthTemplates*`
|Allows for customization of pages like the login page.

|`*ProviderSelection*`
|A path to a file containing a go template used to render the provider selection
page. If unspecified, the default provider selection page is used.

|`*SessionConfig*`
|Holds information about configuring sessions.

|`*Templates*`
|Allows you to customize pages like the login page.

|`*TokenConfig*`
|Contains options for authorization and access tokens.

|===

[[master-node-config-project-config]]
=== Project Configuration

.Project Configuration Parameters
[cols="3a,6a",options="header"]
|===

| Parameter Name | Description

|`*DefaultNodeSelector*`
|Holds default project node label selector.

|`*ProjectConfig*`
|Holds information about project creation and defaults:

- `*DefaultNodeSelector*` (string): Holds the default project node label selector.
- `*ProjectRequestMessage*` (string): The string presented to a user if they are unable to request a project via the projectrequest API endpoint.
- `*ProjectRequestTemplate*` (string): The template to use for creating projects in response to projectrequest. It is in the format `<namespace>/<template>`. It is optional, and if it is not specified, a default template is used.
- `*SecurityAllocator*`: Controls the automatic allocation of UIDs and MCS labels to a project. If nil, allocation is disabled:
  * `*mcsAllocatorRange*` (string): Defines the range of MCS categories that will be assigned to namespaces. The format is `<prefix>/<numberOfLabels>[,<maxCategory>]`. The default is `s0/2` and will allocate from c0 -> c1023, which means a total of 535k labels are available. If this value is changed after startup, new projects may receive labels that are already allocated to other projects. The prefix may be any valid SELinux set of terms (including user, role, and type). However, leaving the prefix at its default allows the server to set them automatically. For example, `s0:/2` would allocate labels from s0:c0,c0 to s0:c511,c511 whereas `s0:/2,512` would allocate labels from s0:c0,c0,c0 to s0:c511,c511,511.
  * `*mcsLabelsPerProject*` (integer): Defines the number of labels to reserve per project. The default is `5` to match the default UID and MCS ranges.
  * `*uidAllocatorRange*` (string): Defines the total set of Unix user IDs (UIDs) automatically allocated to projects, and the size of the block each namespace gets. For example, `1000-1999/10` would allocate ten UIDs per namespace, and would be able to allocate up to 100 blocks before running out of space. The default is to allocate from 1 billion to 2 billion in 10k blocks, which is the expected size of ranges for container images when user namespaces are started.

|`*ProjectRequestMessage*`
|The string presented to a user if they are unable to request a project via the
project request API endpoint.

|`*ProjectRequestTemplate*`
|The template to use for creating projects in response to *projectrequest*. It
is in the format namespace/template and it is optional. If it is not specified,
a default template is used.

|===

[[master-node-config-scheduler-config]]
=== Scheduler Configuration

.Scheduler Configuration Parameters
[cols="3a,6a",options="header"]
|===

| Parameter Name | Description

|`*SchedulerConfigFile*`
|Points to a file that describes how to set up the scheduler. If empty, you get
the default scheduling rules

|===

=== Security Allocator Configuration

.Security Allocator Parameters
[cols="3a,6a",options="header"]
|===

| Parameter Name | Description

|`*MCSAllocatorRange*`
|Defines the range of MCS categories that will be assigned to namespaces. The
format is `<prefix>/<numberOfLabels>[,<maxCategory>]`. The default is *s0/2* and
will allocate from c0 to c1023, which means a total of 535k labels are available
(1024 choose 2 ~ 535k). If this value is changed after startup, new projects may
receive labels that are already allocated to other projects. Prefix may be any
valid SELinux set of terms (including user, role, and type), although leaving
them as the default will allow the server to set them automatically.

|`*SecurityAllocator*`
|Controls the automatic allocation of UIDs and MCS labels to a project. If nil,
allocation is disabled.

|`*UIDAllocatorRange*`
|Defines the total set of Unix user IDs (UIDs) that will be allocated to
projects automatically, and the size of the block each namespace gets. For
example, 1000-1999/10 will allocate ten UIDs per namespace, and will be able to
allocate up to 100 blocks before running out of space. The default is to
allocate from 1 billion to 2 billion in 10k blocks (which is the expected size
of the ranges container images will use once user namespaces are started).

|===


[[master-config-service-account-config]]
=== Service Account Configuration

.Service Account Configuration Parameters
[cols="3a,6a",options="header"]
|===

| Parameter Name | Description

|`*LimitSecretReferences*`
|Controls whether or not to allow a service account to reference any secret in a
namespace without explicitly referencing them.

|`*ManagedNames*`
|A list of service account names that will be auto-created in every namespace.
If no names are specified, the `*ServiceAccountsController*` will not be
started.

|`*MasterCA*`
|The CA for verifying the TLS connection back to the master. The service account
controller will automatically inject the contents of this file into pods so they
can verify connections to the master.

|`*PrivateKeyFile*`
|A file containing a PEM-encoded private RSA key, used to sign service account
tokens. If no private key is specified, the service account `*TokensController*`
will not be started.

|`*PublicKeyFiles*`
|A list of files, each containing a PEM-encoded public RSA key. If any file
contains a private key, the public portion of the key is used. The list of
public keys is used to verify presented service account tokens. Each key is
tried in order until the list is exhausted or verification succeeds. If no keys
are specified, no service account authentication will be available.

|`*ServiceAccountConfig*`
|Holds options related to service accounts:

- `*LimitSecretReferences*` (boolean): Controls whether or not to allow a service account to reference any secret in a namespace without explicitly referencing them.
- `*ManagedNames*` (string): A list of service account names that will be auto-created in every namespace. If no names are specified, then the `*ServiceAccountsController*` will not be started.
- `*MasterCA*` (string): The certificate authority for verifying the TLS connection back to the master. The service account controller will automatically inject the contents of this file into pods so that they can verify connections to the master.
- `*PrivateKeyFile*` (string): Contains a PEM-encoded private RSA key, used to sign service account tokens. If no private key is specified, then the service account `*TokensController*` will not be started.
- `*PublicKeyFiles*` (string): A list of files, each containing a PEM-encoded public RSA key. If any file contains a private key, then {product-title} uses the public portion of the key. The list of public keys is used to verify service account tokens; each key is tried in order until either the list is exhausted or verification succeeds. If no keys are specified, then service account authentication will not be available.

|===

[[master-config-serving-information-config]]
=== Serving Information Configuration

.Serving Information Configuration Parameters
[cols="3a,6a",options="header"]
|===

| Parameter Name | Description

|`*AllowRecursiveQueries*`
|Allows the DNS server on the master to answer queries recursively. Note that
open resolvers can be used for DNS amplification attacks and the master DNS
should not be made accessible to public networks.

|`*BindAddress*`
|The *ip:port* to serve on.

|`*BindNetwork*`
|Controls limits and behavior for importing images.

|`*CertFile*`
|A file containing a PEM-encoded certificate.

|`*CertInfo*`
|TLS cert information for serving secure traffic.

|`*ClientCA*`
|The certificate bundle for all the signers that you recognize for incoming
client certificates.

|`*dnsConfig*`
|If present, then start the DNS server based on the defined parameters. For example:
----
dnsConfig:
  bindAddress: 0.0.0.0:8053
  bindNetwork: tcp4
----

|`*DNSDomain*`
|Holds the domain suffix.

|`*DNSIP*`
|Holds the IP.

|`*KeyFile*`
|A file containing a PEM-encoded private key for the certificate specified by
`*CertFile*`.

|`*MasterClientConnectionOverrides*`
|Provides overrides to the client connection used to connect to the master.

|`*MaxRequestsInFlight*`
|The number of concurrent requests allowed to the server. If zero, no limit.

|`*NamedCertificates*`
|A list of certificates to use to secure requests to specific host names.

|`*RequestTimeoutSecond*`
|The number of seconds before requests are timed out. The default is 60 minutes.
If -1, there is no limit on requests.

|`*ServingInfo*`
|The HTTP serving information for the assets.

|===

[[master-node-config-volume-config]]
=== Volume Configuration

.Volume Configuration Parameters
[cols="3a,6a",options="header"]
|===

| Parameter Name | Description

|`*DynamicProvisioningEnabled*`
|A boolean to enable or disable dynamic provisioning. Default is *true*.

|*FSGroup*
|Enables xref:node-config-volume-config[local storage quotas] on each node for each FSGroup.
At present this is only implemented for emptyDir volumes, and if the underlying
`*volumeDirectory*` is on an XFS filesystem.

|`*MasterVolumeConfig*`
|Contains options for configuring volume plug-ins in the master node.

|`*NodeVolumeConfig*`
|Contains options for configuring volumes on the node.

|`*VolumeConfig*`
|Contains options for configuring volume plug-ins in the node:

- `*DynamicProvisioningEnabled*` (boolean): Default value is `true`, and toggles dynamic provisioning off when `false`.

|`*VolumeDirectory*`
|The directory that volumes are stored under.

|===

[[master-node-config-audit-config]]
=== Basic Audit

Audit provides a security-relevant chronological set of records documenting the
sequence of activities that have affected system by individual users,
administrators, or other components of the system.

Audit works at the API server level, logging all requests coming to the server.
Each audit log contains two entries:

. The request line containing:
.. A Unique ID allowing to match the response line (see #2)
.. The source IP of the request
.. The HTTP method being invoked
.. The original user invoking the operation
.. The impersonated user for the operation (`self` meaning himself)
.. The impersonated group for the operation (`lookup` meaning user's group)
.. The namespace of the request or <none>
.. The URI as requested

. The response line containing:
.. The unique ID from #1
.. The response code

Example output for user *admin* asking for a list of pods:

----
AUDIT: id="5c3b8227-4af9-4322-8a71-542231c3887b" ip="127.0.0.1" method="GET" user="admin" as="<self>" asgroups="<lookup>" namespace="default" uri="/api/v1/namespaces/default/pods"
AUDIT: id="5c3b8227-4af9-4322-8a71-542231c3887b" response="200"
----

The `openshift_master_audit_config` variable enables API service auditing. It
takes an array of the following options:

.Audit Configuration Parameters
[cols="3a,6a",options="header"]
|===

| Parameter Name | Description

|`enabled`
|A boolean to enable or disable audit logs. Default is `false`.

|`auditFilePath`
|File path where the requests should be logged to. If not set, logs are printed
to master logs.

|`maximumFileRetentionDays`
|Specifies maximum number of days to retain old audit log files based on the time
stamp encoded in their filename.

|`maximumRetainedFiles`
|Specifies the maximum number of old audit log files to retain.

|`maximumFileSizeMegabytes`
|Specifies maximum size in megabytes of the log file before it gets rotated.
Defaults to 100MB.
|===


.Example Audit Configuration
----
auditConfig:
  auditFilePath: "/var/log/audit-ocp.log"
  enabled: true
  maximumFileRetentionDays: 10
  maximumFileSizeMegabytes: 10
  maximumRetainedFiles: 10
----

.Advanced Setup for the Audit Log
If you want more advanced setup for the audit log, you can use:

----
openshift_master_audit_config={"enabled": true}
----

The directory in `auditFilePath` will be created if it does not exist.

----
openshift_master_audit_config={"enabled": true, "auditFilePath": "/var/log/openpaas-oscp-audit/openpaas-oscp-audit.log", "maximumFileRetentionDays": 14, "maximumFileSizeMegabytes": 500, "maximumRetainedFiles": 5}
----

[[master-node-config-advanced-audit]]
=== Advanced Audit

The advanced audit feature provides several improvements over the
xref:master-node-config-audit-config[basic audit functionality], including
fine-grained events filtering and multiple output back ends. The following table
contains additional options you can use.

.Advanced Audit Configuration Parameters

[cols="3a,6a",options="header"]
|===
| Parameter Name | Description

|`policyFile`
|Path to the file that defines the audit policy configuration.

|`policyConfiguration`
|An embedded audit policy configuration.

|`logFormat`
|Specifies the format of the saved audit logs. Allowed values are `legacy` (the
format used in basic audit), and `json`.

|`webHookKubeConfig`
|Path to a `.kubeconfig`-formatted file that defines the audit webhook
configuration, where the events are sent to.

|`webHookMode`
|Specifies the strategy for sending audit events. Allowed values are `block`
(blocks processing another event until the previous has fully processed) and
`batch` (buffers events and delivers in batches).
|===

To enable the advanced audit feature, you must provide either `policyFile` or
`policyConfiguration` describing the audit policy rules:

.Sample Audit Policy Configuration
[source,yaml]
----
apiVersion: audit.k8s.io/v1beta1
kind: Policy
rules:

  # Do not log watch requests by the "system:kube-proxy" on endpoints or services
  - level: None <1>
    users: ["system:kube-proxy"] <2>
    verbs: ["watch"] <3>
    resources: <4>
    - group: ""
      resources: ["endpoints", "services"]

  # Do not log authenticated requests to certain non-resource URL paths.
  - level: None
    userGroups: ["system:authenticated"] <5>
    nonResourceURLs: <6>
    - "/api*" # Wildcard matching.
    - "/version"

  # Log the request body of configmap changes in kube-system.
  - level: Request
    resources:
    - group: "" # core API group
      resources: ["configmaps"]
    # This rule only applies to resources in the "kube-system" namespace.
    # The empty string "" can be used to select non-namespaced resources.
    namespaces: ["kube-system"] <7>

  # Log configmap and secret changes in all other namespaces at the metadata level.
  - level: Metadata
    resources:
    - group: "" # core API group
      resources: ["secrets", "configmaps"]

  # Log all other resources in core and extensions at the request level.
  - level: Request
    resources:
    - group: "" # core API group
    - group: "extensions" # Version of group should NOT be included.

  # A catch-all rule to log all other requests at the Metadata level.
  - level: Metadata <1>

  # Log login failures from the web console or CLI. Review the logs and refine your policies.
  - level: Metadata
    nonResourceURLs:
    - /login* <8>
    - /oauth* <9>
----
<1> There are four possible levels every event can be logged at:
+
* `None` - Do not log events that match this rule.
+
* `Metadata` - Log request metadata (requesting user, time stamp, resource, verb,
etc.), but not request or response body. This is the same level as the one used
in basic audit.
+
* `Request` - Log event metadata and request body, but not response body.
+
* `RequestResponse` - Log event metadata, request, and response bodies.
<2> A list of users the rule applies to. An empty list implies every user.
<3> A list of verbs this rule applies to. An empty list implies every verb. This is
 Kubernetes verb associated with API requests (including `get`, `list`, `watch`,
 `create`, `update`, `patch`, `delete`, `deletecollection`, and `proxy`).
<4> A list of resources the rule applies to. An empty list implies every resource.
Each resource is specified as a group it is assigned to (for example, an empty for
Kubernetes core API, batch, build.openshift.io, etc.), and a resource list from
that group.
<5> A list of groups the rule applies to. An empty list implies every group.
<6> A list of non-resources URLs the rule applies to.
<7> A list of namespaces the rule applies to. An empty list implies every namespace.
<8> Endpoint used by the web console.
<9> Endpoint used by the CLI.

For more information on advanced audit, see the
link:https://kubernetes.io/docs/tasks/debug-application-cluster/audit[Kubernetes
documentation]

[[node-configuration-files]]
== Node Configuration Files

The following *_node-config.yaml_* file is a sample node configuration file that
was generated with the default values as of writing. You can
xref:creating-new-configuration-files[create a new node configuration file] to
see the valid options for your installed version of {product-title}.

.Sample Node Configuration File
====
[source,yaml]
----
allowDisabledDocker: false
apiVersion: v1
authConfig:
  authenticationCacheSize: 1000
  authenticationCacheTTL: 5m
  authorizationCacheSize: 1000
  authorizationCacheTTL: 5m
dnsDomain: cluster.local
dnsIP: 0.0.0.0 <1>
dockerConfig:
  execHandlerName: native
imageConfig:
  format: openshift/origin-${component}:${version}
  latest: false
iptablesSyncPeriod: 5s
kind: NodeConfig
masterKubeConfig: node.kubeconfig
networkConfig:
  mtu: 1450
  networkPluginName: ""
nodeIP: ""
nodeName: node1.example.com
podManifestConfig: <2>
  path: "/path/to/pod-manifest-file" <3>
  fileCheckIntervalSeconds: 30 <4>
proxyArguments:
  proxy-mode:
  - iptables <5>
servingInfo:
  bindAddress: 0.0.0.0:10250
  bindNetwork: tcp4
  certFile: server.crt
  clientCA: node-client-ca.crt
  keyFile: server.key
  namedCertificates: null
volumeDirectory: /root/openshift.local.volumes
----
<1> Configures an IP address to be prepended to a pod's *_/etc/resolv.conf_* by adding the address here.
<2> Allows pods to be placed directly on certain set of nodes, or on all nodes
without going through the scheduler. You can then use pods to perform the same
administrative tasks and support the same services on each node.
<3> Specifies the path for the
xref:../architecture/core_concepts/pods_and_services.adoc#pods[pod manifest file]
or directory. If it is a directory, then it is expected to contain one or more
manifest files. This is used by the Kubelet to create pods on the node.
<4> This is the interval (in seconds) for checking the manifest file for new
data. The interval must be a positive value.
<5> The xref:../architecture/core_concepts/pods_and_services.adoc#service-proxy-mode[service
proxy implementation] to use.
====

The node configuration file determines the resources of a node. See the
xref:../admin_guide/allocating_node_resources.adoc#admin-guide-allocating-node-resources[Allocating
node resources section in the Cluster Administrator guide] for more information.

[[node-config-pod-and-node-config]]
=== Pod and Node Configuration

.Pod and Node Configuration Parameters
[cols="3a,6a",options="header"]
|===

| Parameter Name | Description

|`*NodeConfig*`
|The fully specified configuration starting an {product-title} node.

|`*NodeIP*`
|Node may have multiple IPs, so this specifies the IP to use for pod traffic
routing. If not specified, network parse/lookup on the *nodeName* is performed
and the first non-loopback address is used.

|`*NodeName*`
|The value used to identify this particular node in the cluster. If possible,
this should be your fully qualified hostname. If you are describing a set of
static nodes to the master, this value must match one of the values in the list.

|`*PodEvictionTimeout*`
|Controls grace period for deleting pods on failed nodes. It takes valid time
duration string. If empty, you get the default pod eviction timeout.

|`*ProxyClientInfo*`
|Specifies the client cert/key to use when proxying to pods.

|===


[[node-config-docker-config]]
=== Docker Configuration

.Docker Configuration Parameters
[cols="3a,6a",options="header"]
|===

| Parameter Name | Description

|`*AllowDisabledDocker*`
|If true, the kubelet will ignore errors from Docker. This means that a node can
start on a machine that does not have docker started.

|`*DockerConfig*`
|Holds Docker related configuration options

|`*ExecHandlerName*`
|The handler to use for executing commands in Docker containers.

|===

[[node-config-volume-config]]
=== Local Storage Configuration

You can use the link:https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/storage_administration_guide/ch-xfs[XFS quota subsystem] 
to limit the size of `emptyDir` volumes and volumes based on an `emptyDir` volume, such as secrets and configuration maps, on each node.

To limit the size of `emptyDir` volumes in an XFS filesystem, configure local volume quota for each unique 
xref:../install_config/persistent_storage/pod_security_context.adoc#fsgroup[FSGroup] using the *_node-config-compute_* configuration map in the *openshift-node* project.

----
apiVersion: kubelet.config.openshift.io/v1
kind: VolumeConfig
  localQuota: <1>
    perFSGroup: 1Gi <2>
----

<1> Contains options for controlling local volume quota on the node.
<2> Set this value to a resource quantity representing the desired quota per 
[FSGroup], per node, such as `1Gi`, `512Mi`, and so forth. 
Requires the *volumeDirectory* to be on an XFS filesystem mounted with the `grpquota` option. The matching security context constraint *fsGroup* type must be 
xref:../architecture/additional_concepts/authorization.adoc#authorization-FSGroup[set to `MustRunAs`].

If no FSGroup is specified, indicating the request matched an SCC with `RunAsAny`, the quota
application is skipped.

[NOTE]
====
Do not edit the *_/etc/origin/node/volume-config.yaml_* file directly. The file is created from the *_node-config-compute_* configuration map. 
Use the *_node-config-compute_* configuration map to create or edit the paramaters in the *_volume-config.yaml_* file.
====

[[master-node-configuration-parallel-image-pulls-with-docker]]
=== Parallel Image Pulls with Docker 1.9+

If you are using Docker 1.9+, you may want to consider enabling parallel image
pulling, as the default is to pull images one at a time.

[NOTE]
====
There is a potential issue with data corruption prior to Docker 1.9. However,
starting with 1.9, the corruption issue is resolved and it is safe to switch to
parallel pulls.
====

====
[source,yaml]
----
kubeletArguments:
  serialize-image-pulls:
  - "false" <1>
----
<1> Change to true to disable parallel pulls. (This is the default config)
====

[[master-node-configuration-passwords-and-other-data]]
== Passwords and Other Sensitive Data

For some xref:../install_config/configuring_authentication.adoc#install-config-configuring-authentication[authentication configurations],
an LDAP `bindPassword` or OAuth `clientSecret` value is required.
Instead of specifying these values directly in the master configuration file,
these values may be provided as environment variables, external files,
or in encrypted files.

.Environment Variable Example
[source,yaml]
----
  ...
  bindPassword:
    env: BIND_PASSWORD_ENV_VAR_NAME
----

.External File Example
[source,yaml]
----
  ...
  bindPassword:
    file: bindPassword.txt
----

.Encrypted External File Example
[source,yaml]
----
  ...
  bindPassword:
    file: bindPassword.encrypted
    keyFile: bindPassword.key
----

To create the encrypted file and key file for the above example:

[options="nowrap"]
----
$ oc adm ca encrypt --genkey=bindPassword.key --out=bindPassword.encrypted
> Data to encrypt: B1ndPass0rd!
----

Run `oc adm` commands only from the first master listed in the Ansible host inventory file,
by default *_/etc/ansible/hosts_*.

[WARNING]
====
Encrypted data is only as secure as the decrypting key. Care should be taken
to limit filesystem permissions and access to the key file.
====

[[creating-new-configuration-files]]

== Creating New Configuration Files

When defining an {product-title} configuration from scratch, start by creating
new configuration files.

For master host configuration files, use the `openshift start` command with the
`--write-config` option to write the configuration files. For node hosts, use
the `oc adm create-node-config` command to write the configuration files.

The following commands write the relevant launch configuration file(s),
certificate files, and any other necessary files to the specified
`--write-config` or `--node-dir` directory.

Generated certificate files are valid for two years, while the certification
authority (CA) certificate is valid for five years. This can be altered with the
`--expire-days` and `--signer-expire-days` options, but for security reasons, it
is recommended to not make them greater than these values.

To create configuration files for an all-in-one server (a master and a node on
the same host) in the specified directory:

[options="nowrap"]
----
$ openshift start --write-config=/openshift.local.config
----

To create a xref:master-configuration-files[master configuration file] and
other required files in the specified directory:

[options="nowrap"]
----
$ openshift start master --write-config=/openshift.local.config/master
----

To create a xref:node-configuration-files[node configuration file] and other
related files in the specified directory:

[options="nowrap"]
----
$ oc adm create-node-config \
    --node-dir=/openshift.local.config/node-<node_hostname> \
    --node=<node_hostname> \
    --hostnames=<node_hostname>,<ip_address> \
    --certificate-authority="/path/to/ca.crt" \
    --signer-cert="/path/to/ca.crt" \
    --signer-key="/path/to/ca.key"
    --signer-serial="/path/to/ca.serial.txt"
    --node-client-certificate-authority="/path/to/ca.crt"
----

When creating node configuration files, the `--hostnames` option accepts a
comma-delimited list of every host name or IP address you want server
certificates to be valid for.

[[launching-servers-using-configuration-files]]

== Launching Servers Using Configuration Files
Once you have modified the master and/or node configuration files to your
specifications, you can use them when launching servers by specifying them as an
argument. Keep in mind that if you specify a configuration file, none of the
other command line options you pass are respected.

To launch an all-in-one server using a master configuration and a node
configuration file:

[options="nowrap"]
----
$ openshift start --master-config=/openshift.local.config/master/master-config.yaml --node-config=/openshift.local.config/node-<node_hostname>/node-config.yaml
----

To launch a master server using a master configuration file:

[options="nowrap"]
----
$ openshift start master --config=/openshift.local.config/master/master-config.yaml
----

To launch a node server using a node configuration file:

[options="nowrap"]
----
$ openshift start node --config=/openshift.local.config/node-<node_hostname>/node-config.yaml
----

[[master-node-config-logging-levels]]
== Configuring Logging Levels

{product-title} uses the `systemd-journald.service` to collect log messages for debugging, using five log message severities. The logging levels are based on Kubernetes logging conventions, as follows:

.Log Level Options
[cols="3a,6a",options="header"]
|===

|Option |Description

|0|Errors and warnings only
|2|Normal information
|4|Debugging-level information
|6|API-level debugging information (request / response)
|8|Body-level API debugging information
|===

You can control which INFO messages are logged by setting the loglevel option in the in *_/etc/sysconfig/atomic-openshift-node_*, the *_/etc/sysconfig/atomic-openshift-master-api_* file
and the *_/etc/sysconfig/atomic-openshift-master-controllers_* file. Configuring the logs to collect all messages can lead to large logs that are difficult to interpret and can take up excessive space. Collecting all messages should only be used in debug situations.

[NOTE]
====
Messages with FATAL, ERROR, WARNING and some INFO severities appear in the logs regardless of the log configuration.
====

You can view logs for the master or the node system using the following command:

----
# journalctl -r -u <journal_name>
----

Use the `-r` option to show the newest entries first.

For example:

----
# master-logs controllers controllers
# master-logs api api
# journalctl -r -u atomic-openshift-node.service
----

To change the logging level:

. Edit the *_/etc/sysconfig/atomic-openshift-master_* file for the master or *_/etc/sysconfig/atomic-openshift-node_* file for the nodes.
. Enter a value from the *Log Level Options* table above in the `OPTIONS=--loglevel=` field.
+
For example:
+
----
OPTIONS=--loglevel=4
----
. Restart the master or node host as appropriate.  See xref:master-node-config-restart-services[Restarting {product-title} services].

After the restart, all new log messages will conform to the new setting. Older messages do not change.

[NOTE]
====
The default log level can be set using the standard cluster installation
process. For more information, see
xref:../install/configuring_inventory_file.adoc#cluster-variables-table[Cluster Variables].
====

The following examples are excerpts from a master *journald* log at various log levels. Timestamps and system information have been removed from these examples.

.Excerpt of journalctl -u atomic-openshift-master-controllers.service output at loglevel=0

----
4897 plugins.go:77] Registered admission plugin "NamespaceLifecycle"
4897 start_master.go:290] Warning: assetConfig.loggingPublicURL: Invalid value: "": required to view aggregated container logs in the console, master start will continue.
4897 start_master.go:290] Warning: assetConfig.metricsPublicURL: Invalid value: "": required to view cluster metrics in the console, master start will continue.
4897 start_master.go:290] Warning: aggregatorConfig.proxyClientInfo: Invalid value: "": if no client certificate is specified, the aggregator will be unable to proxy to remote servers,
4897 start_master.go:412] Starting controllers on 0.0.0.0:8444 (v3.7.14)
4897 start_master.go:416] Using images from "openshift3/ose-<component>:v3.7.14"
4897 standalone_apiserver.go:106] Started health checks at 0.0.0.0:8444
4897 plugins.go:77] Registered admission plugin "NamespaceLifecycle"
4897 configgetter.go:53] Initializing cache sizes based on 0MB limit
4897 leaderelection.go:105] Attempting to acquire openshift-master-controllers lease as master-bkr-hv03-guest44.dsal.lab.eng.bos.redhat.com-10.19.41.74-xtz6lbqb, renewing every 3s, hold
4897 leaderelection.go:179] attempting to acquire leader lease...
systemd[1]: Started Atomic OpenShift Master Controllers.
4897 leaderelection.go:189] successfully acquired lease kube-system/openshift-master-controllers
4897 event.go:218] Event(v1.ObjectReference{Kind:"ConfigMap", Namespace:"kube-system", Name:"openshift-master-controllers", UID:"aca86731-ffbe-11e7-8d33-525400c845a8", APIVersion:"v1",
4897 start_master.go:627] Started serviceaccount-token controller
4897 factory.go:351] Creating scheduler from configuration: {{ } [{NoVolumeZoneConflict <nil>} {MaxEBSVolumeCount <nil>} {MaxGCEPDVolumeCount <nil>} {MaxAzureDiskVolumeCount <nil>} {Mat
4897 factory.go:360] Registering predicate: NoVolumeZoneConflict
4897 plugins.go:145] Predicate type NoVolumeZoneConflict already registered, reusing.
4897 factory.go:360] Registering predicate: MaxEBSVolumeCount
4897 plugins.go:145] Predicate type MaxEBSVolumeCount already registered, reusing.
4897 factory.go:360] Registering predicate: MaxGCEPDVolumeCount
----


.Excerpt of journalctl -u atomic-openshift-master-controllers.service output at loglevel=2

----
4897 master.go:47] Initializing SDN master of type "redhat/openshift-ovs-subnet"
4897 master.go:107] Created ClusterNetwork default (network: "10.128.0.0/14", hostSubnetBits: 9, serviceNetwork: "172.30.0.0/16", pluginName: "redhat/openshift-ovs-subnet")
4897 start_master.go:690] Started "openshift.io/sdn"
4897 start_master.go:680] Starting "openshift.io/service-serving-cert"
4897 controllermanager.go:466] Started "namespace"
4897 controllermanager.go:456] Starting "daemonset"
4897 controller_utils.go:1025] Waiting for caches to sync for namespace controller
4897 shared_informer.go:298] resyncPeriod 120000000000 is smaller than resyncCheckPeriod 600000000000 and the informer has already started. Changing it to 600000000000
4897 start_master.go:690] Started "openshift.io/service-serving-cert"
4897 start_master.go:680] Starting "openshift.io/image-signature-import"
4897 start_master.go:690] Started "openshift.io/image-signature-import"
4897 start_master.go:680] Starting "openshift.io/templateinstance"
4897 controllermanager.go:466] Started "daemonset"
4897 controllermanager.go:456] Starting "statefulset"
4897 daemoncontroller.go:222] Starting daemon sets controller
4897 controller_utils.go:1025] Waiting for caches to sync for daemon sets controller
4897 controllermanager.go:466] Started "statefulset"
4897 controllermanager.go:456] Starting "cronjob"
4897 stateful_set.go:147] Starting stateful set controller
4897 controller_utils.go:1025] Waiting for caches to sync for stateful set controller
4897 start_master.go:690] Started "openshift.io/templateinstance"
4897 start_master.go:680] Starting "openshift.io/horizontalpodautoscaling
----


.Excerpt of journalctl -u atomic-openshift-master-controllers.service output at loglevel=4

----
4897 factory.go:366] Registering priority: Zone
4897 factory.go:401] Creating scheduler with fit predicates 'map[GeneralPredicates:{} CheckNodeMemoryPressure:{} CheckNodeDiskPressure:{} Region:{} NoVolumeZoneC
4897 controller_utils.go:1025] Waiting for caches to sync for tokens controller
4897 controllermanager.go:108] Version: v1.7.6+a08f5eeb62
4897 leaderelection.go:179] attempting to acquire leader lease...
4897 leaderelection.go:189] successfully acquired lease kube-system/kube-controller-manager
4897 event.go:218] Event(v1.ObjectReference{Kind:"ConfigMap", Namespace:"kube-system", Name:"kube-controller-manager", UID:"acb3e9c6-ffbe-11e7-8d33-525400c845a8", APIVersion:"v1", Resou
4897 controller_utils.go:1032] Caches are synced for tokens controller
4897 plugins.go:101] No cloud provider specified.
4897 controllermanager.go:481] "serviceaccount-token" is disabled
4897 controllermanager.go:450] "bootstrapsigner" is disabled
4897 controllermanager.go:450] "tokencleaner" is disabled
4897 controllermanager.go:456] Starting "garbagecollector"
4897 start_master.go:680] Starting "openshift.io/build"
4897 controllermanager.go:466] Started "garbagecollector"
4897 controllermanager.go:456] Starting "deployment"
4897 garbagecollector.go:126] Starting garbage collector controller
4897 controller_utils.go:1025] Waiting for caches to sync for garbage collector controller
4897 controllermanager.go:466] Started "deployment"
4897 controllermanager.go:450] "horizontalpodautoscaling" is disabled
4897 controllermanager.go:456] Starting "disruption"
4897 deployment_controller.go:152] Starting deployment controller
----


.Excerpt of journalctl -u atomic-openshift-master-controllers.service output at loglevel=8

----
4897 plugins.go:77] Registered admission plugin "NamespaceLifecycle"
4897 start_master.go:290] Warning: assetConfig.loggingPublicURL: Invalid value: "": required to view aggregated container logs in the console, master start will continue.
4897 start_master.go:290] Warning: assetConfig.metricsPublicURL: Invalid value: "": required to view cluster metrics in the console, master start will continue.
4897 start_master.go:290] Warning: aggregatorConfig.proxyClientInfo: Invalid value: "": if no client certificate is specified, the aggregator will be unable to proxy to remote serv
4897 start_master.go:412] Starting controllers on 0.0.0.0:8444 (v3.7.14)
4897 start_master.go:416] Using images from "openshift3/ose-<component>:v3.7.14"
4897 standalone_apiserver.go:106] Started health checks at 0.0.0.0:8444
4897 plugins.go:77] Registered admission plugin "NamespaceLifecycle"
4897 configgetter.go:53] Initializing cache sizes based on 0MB limit
4897 leaderelection.go:105] Attempting to acquire openshift-master-controllers lease as master-bkr-hv03-guest44.dsal.lab.eng.bos.redhat.com-10.19.41.74-xtz6lbqb, renewing every 3s,
4897 leaderelection.go:179] attempting to acquire leader lease...
systemd[1]: Started Atomic OpenShift Master Controllers.
4897 leaderelection.go:189] successfully acquired lease kube-system/openshift-master-controllers
4897 event.go:218] Event(v1.ObjectReference{Kind:"ConfigMap", Namespace:"kube-system", Name:"openshift-master-controllers", UID:"aca86731-ffbe-11e7-8d33-525400c845a8", APIVersion:"
4897 start_master.go:627] Started serviceaccount-token controller
----


.Excerpt of journalctl -u atomic-openshift-master-api.service output at loglevel=2

----
4613 plugins.go:77] Registered admission plugin "NamespaceLifecycle"
4613 master.go:320] Starting Web Console https://bkr-hv03-guest44.dsal.lab.eng.bos.redhat.com:8443/console/
4613 master.go:329] Starting OAuth2 API at /oauth
4613 master.go:320] Starting Web Console https://bkr-hv03-guest44.dsal.lab.eng.bos.redhat.com:8443/console/
4613 master.go:329] Starting OAuth2 API at /oauth
4613 master.go:320] Starting Web Console https://bkr-hv03-guest44.dsal.lab.eng.bos.redhat.com:8443/console/
4613 master.go:329] Starting OAuth2 API at /oauth
4613 swagger.go:38] No API exists for predefined swagger description /oapi/v1
4613 swagger.go:38] No API exists for predefined swagger description /api/v1
[restful] 2018/01/22 16:53:14 log.go:33: [restful/swagger] listing is available at https://bkr-hv03-guest44.dsal.lab.eng.bos.redhat.com:8443/swaggerapi
[restful] 2018/01/22 16:53:14 log.go:33: [restful/swagger] https://bkr-hv03-guest44.dsal.lab.eng.bos.redhat.com:8443/swaggerui/ is mapped to folder /swagger-ui/
4613 master.go:320] Starting Web Console https://bkr-hv03-guest44.dsal.lab.eng.bos.redhat.com:8443/console/
4613 master.go:329] Starting OAuth2 API at /oauth
4613 swagger.go:38] No API exists for predefined swagger description /oapi/v1
4613 swagger.go:38] No API exists for predefined swagger description /api/v1
[restful] 2018/01/22 16:53:14 log.go:33: [restful/swagger] listing is available at https://bkr-hv03-guest44.dsal.lab.eng.bos.redhat.com:8443/swaggerapi
[restful] 2018/01/22 16:53:14 log.go:33: [restful/swagger] https://bkr-hv03-guest44.dsal.lab.eng.bos.redhat.com:8443/swaggerui/ is mapped to folder /swagger-ui/
Starting Web Console https://bkr-hv03-guest44.dsal.lab.eng.bos.redhat.com:8443/console/
Starting OAuth2 API at /oauth
No API exists for predefined swagger description /oapi/v1
No API exists for predefined swagger description /api/v1
----

[[master-node-config-restart-services]]
== Restarting master and node services

To apply master or node configuration changes, you must restart the respective
services.

To reload master configuration changes, restart master services running in control plane static pods using the `master-restart` command:

----
# master-restart api
----

To reload node configuration changes, restart the node service on the node host:

ifdef::openshift-enterprise[]
----
# systemctl restart atomic-openshift-node
----
endif::[]
ifdef::openshift-origin[]
----
# systemctl restart origin-node
----
endif::[]
