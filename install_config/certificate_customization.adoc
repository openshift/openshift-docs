[[install-config-certificate-customization]]
= Managing and Configuring Custom Certificates
{product-author}
{product-version}
:data-uri:
:icons:
:experimental:
:toc: macro
:toc-title:
:prewrap!:

toc::[]

[[pkis-to-manage-certificates]]
== Using PKIs to Manage Certificates
{product-name} includes several Public Key Infrastructures (PKIs) that
can authenticate systems, typically on the server side of the communication.
One way they perform system authentication is to manage certificates used
for specific purposes. The PKIs perform different functions and must be
configured in order to make informed security decisions.

Among other things, a PKI is a hierarchy of certificate authorities and certificates.

[NOTE]
====
PKIs include more components than certificates, but this discussion focuses on
certificate hierarchy.
====

[[pki-structure]]
=== PKI Structure
A PKI has a structure similar to a tree, with a root, branches, and leaves.

* The root is the Root CA, which is always a self-signed certificate.
* The branches are subsidiary (sometimes also called intermediary) certificate
authorities.
* The leaves are the certificates that systems, users, and services can directly
use to identify themselves.

Leaf certificates, also known as end-entity certificates, are signed by the
branches to which they are attached. Each branch is signed by a higher order
branch until the path reaches back to the Root CA, which is self-signed.

Processes and infrastructure of the complete PKI, together with this hierarchy,
operate the entire authentication system. In certain cases, the Root CAs
are stored in secure, disconnected locations, and a PKI only uses SubCAs to create
certificates.

A PKI also has processes to request and produce new certificates. At one time,
the processes were mostly manual, and they were managed by a dedicated team.
More recently, the PKI certificate process now also uses automation, such
Ansible.

If a system needed only an encrypted connection,  self-signed certificates 
could suffice. However, since encryption alone is not enough
to authenticate systems, CA-signed certificates are also necessary.

[[pki-types]]
=== Types of PKIs

{product-name} can use various PKIs, including:

* <<Platform PKIs>>
* <<Etcd PKIs>>
* <<Aggregator Proxy PKIs>>
* <<Application-level PKIs>>

[[pki-types-platform-pki]]
==== Platform PKIs

The platform PKI manages the platform components’ certificates,
which include the master API, controllers, and nodes. Also, by default, most of
the infrastructure components deployed at install time are signed by this CA,
including metrics, logging, and the default router wildcard certificate. However,
you can override these default certificates by using Ansible inventory parameters.

At install time, it is also possible for the installer to create a new PKI, or
to pass a SubCA and let {product-name} make use of it. In this case, {product-name}
has full control of that SubCA, including access to its private keys. Supplying
a SubCA at install time can be used, for example, when a company has
an existing PKI, and a new SubCA is generated for use with {product-name}.

By default, the PKI CA-related files are stored on all {product-name} masters in
the `/etc/origin/master` directory as shown below:

----
[root@master-0 ~]# ls -la /etc/origin/master/ca*
-rw-r--r--. 1 root root 1070 Nov 15 11:06 /etc/origin/master/ca-bundle.crt
-rw-r--r--. 1 root root 1070 Nov 15 11:05 /etc/origin/master/ca.crt
-rw-------. 1 root root 1679 Nov 15 11:05 /etc/origin/master/ca.key
-rw-r--r--. 1 root root    3 Nov 15 11:20 /etc/origin/master/ca.serial.txt
----

[[pki-types-etcd-pki]]
==== Etcd PKIs

An Etcd cluster has its own PKI. The PKI Root CA files can be found in the 
`/etc/etcd/ca` directory, as follows:

----
[root@master-0 ~]# ls -la /etc/etcd/ca
total 48
-rw-r--r--. 3 root root  1895 Nov 15 10:58 ca.crt
-rw-r--r--. 1 root root  3272 Nov 15 10:58 ca.key
----

You cannot customize the Ectd PKI at install time. It is also very
complicated to replace the Root CA and the associated certificates that have been
generated with it at a later time. Therefore, it is recommended to use the Root CA
for the Ectd PKI.

It is possible to use the `redeploy-ca.yml` playbook to re-deploy a new CA if,
for example, a system compromise is suspected.

[[pkis-types-aggregator-proxy]]
==== Aggregator Proxy PKIs

This PKI is dedicated to managing certificates for extension API servers. This
feature allows an extension of the control plane API by adding services dedicated
to handling specific APIs. It is an alternative way of extending the API to 
Custom Resource Definitions (CRDs) and controllers.

Customizing the Aggregator Proxy PKI is not supported.

The files of the Root CA are located in the {product-name} configuration directory,
as follows:

----
[root@master-0 ~]# ls -la /etc/origin/master/frontproxy*
-rw-r--r--. 1 root root 1078 Nov 15 11:06 /etc/origin/master/frontproxy-ca.crt
-rw-------. 1 root root 1675 Nov 15 11:06 /etc/origin/master/frontproxy-ca.key
-rw-r--r--. 1 root root    3 Nov 15 11:06 /etc/origin/master/frontproxy-ca.serial.txt
encrypted routes.
----

[[pkis-types-application-level]]
==== Application level PKIs
￼
{product-name} also includes an application level PKI. This PKI manages certificates
generated with the service serving certificate secret feature. You can locate the
Root CA files for this PKI as follows:

----
[root@master-0 ~]# ls -la /etc/origin/master/service-*
-rw-r--r--. 1 root root 1115 Nov 15 11:06 /etc/origin/master/service-signer.crt
-rw-------. 1 root root 1675 Nov 15 11:06 /etc/origin/master/service-signer.key
----

This feature enables {product-name} to generate certificates that can be used for
pod-to-pod communications because they present the service name in the Subject
Alternative Name field (SAN). You cannot initialize the application
level PKI at install time with a SubCA. However, you can replace the Root CA
with a SubCA after the installation completes.


[[pki-security]]
== Security Considerations of {product-name}-managed PKIs

As described previously, the {product-name}-managed PKI can be
installed with a RootCA or an externally supplied SubCA.

[NOTE]
====
Some PKIs are more difficult to configure this way than others. For this reason,
using the self-generated PKI for {product-name} instead of a SubCA PKI, is
recommended. Doing so diminishes the impact of the CA private key being compromised.
====


[[pki-security-certificate-validation]]
=== Certificate Validation

Although there are several steps in the certificate validation algorithm,
validation of the chain of trust is a significant part of PKI certificate validation.

To validate that a certificate has been issued by a trusted Certificate, the
validator must be able to retrace the steps up the chain from the presented
certificate through all the intermediary CAs up to the Root CA.

For validation to be successful, all of the CA's public keys, including the
intermediary and root keys, must be available to the client. Normally a client,
such as a browser, will only hold (and therefore trust) the Root CA of any trusted
PKIs. However, during the TLS handshake, the server is allowed to send the
entire CA certification path together with the certificate to be validated.
For this reason, for a client to trust a certificate, it only needs
to trust the Root CA, regardless of the depth of the chain of trust.

[[pki-security-compromised-pki]]
=== Consequences of a PKI being Compromised

When a PKI is compromised, a hacker could possibly forge new certificates
that pretend to be a legitimate server on any domain. If this were to occur, such
certificates would be trusted by the rest of the system.

If the self-generated PKI were used for {product-name}, the impact of it being
compromised is contained to the {product-name} cluster. To remediate this
situation, either run the `redeploy-openshift-ca` playbook to redeploy all
certificates, or simply destroy and recreate the cluster.

If you used a SubCA to install {product-name}, the impact extends
to any system that trusts the RootCA from which that SubCA was generated, either
directly or indirectly. In a company where the internal PKI was used to create
a SubCA for {product-name}, this can impact the entire internal network, including
both client and server machines. In fact, any client that trusts the company root
CA would also trust a certificate forged with the stolen SubCA.

[[pki-security-compromised-mitigation]]
=== Mitigating PKI Compromise

If a company’s SubCA was used to install {product-name}, you can use this
procedure to mitigate the impact of a stolen SubCa:


. Use the name constraint extension to scope down the domain of the certificates
that can be generated by the SubCA. Ideally, the OCP cluster in question would be
confined to its own domain, and everything else in the company would use different
domains.

. Use certificate transparency logging approaches to try to detect if rogue
certificates are circulating in the company environments.

. If you suspect that the OCP CA has been compromised, revoke it. This also
implies that all certificates issued by that CA are no longer valid.

. Use mechanisms such as certificate revocation list and OSCP stapling to ensure
that clients on the company network do not trust revoked certificates.

[NOTE]
====
Even when you use these mechanisms, the system may still trust revoked certificates.
====

Because the impact of a compromised SubCA propagates to the entire company’s
network, it is recommended to keep the {product-name} PKIs separate from the
company's main PKI. Using a Root CA for the {product-name} PKIs is a way to
accomplish this. This explains why even with the Root CA, self-signed by definition, 
there are no self-signed platform certificates in an {product-name} deployment.

Because the services using the certificates generated with the {product-name}-managed
PKIs form closed systems, there is no need to establish a level of trust with
the rest of the company’s network. Therefore, using a Root CA for these PKIs does
not introduce any limitations in the use of {product-name}. There is, however, a
limited set of endpoints that need to be accessible and trusted from outside of
{product-name}.

[[External-endpoints]]
== External Endpoints

Some platform components, such the master API external endpoint, metrics, logging,
and registry for instance, are exposed externally, and it is expected that users
in the company network will connect to them. For these components, you should
configure company-issued certificates so they can be trusted by external users.

You can customize those components that are not customizable at install time
after installation completes. Furthermore, those components that have
the certificates defined in the route, if not customized, will use the default
route certificate. Each of these components can be addressed by customizing this
certificate.

[[Wildcard-router-certificate]]
== Wildcard Certificate for the Router

By default, {product-name} uses a wildcard certificate in the router. When creating
an encrypted route, you can choose whether to use the default wildcard certificate
or use a router-specific certificate.

Because a router’s certificates are externally facing, they should be company-signed.
Also consider that wildcard certificates have been deprecated by the Internet
Engineering Task Force (IETF, the organization overseeing the PKI/TLS standards).
While it may be some time before wildcard certificates will stop functioning, it
will most likely occur if this deprecation stands. For this reason, you should use
a solution that does not rely on wildcard certificates.

Development teams should be able to use self-provisioned certificates for their
applications. This can be achieved by automating the certificate request process,
such as by using the Automated Certificate Management Environment (ACME) protocol.

If your organization does not allow that capability, it is recommended that you use
wildcard certificates for non-production environments in which you expect a high
number of new certificate requests.

However, in production environments, where fewer requests for certificates would
be expected to occur, it is recommended that you continue to use manually-provisioned
certificates, because the overhead associated with the manual requests should be
acceptable.

[[custom-certificate-configuration]]
== Configuring Custom Certificates

In many cases, default certificates already in place are the best certificates
to use; however, you can also configure custom certificates for specific purposes
for the public host names of the {product-title} API and
xref:../architecture/infrastructure_components/web_console.adoc#architecture-infrastructure-components-web-console[web console].
This can be done during a xref:../install/configuring_inventory_file.adoc#advanced-install-custom-certificates[cluster installation]
or configured after installation.

[[using-certificate-chains]]
== Configuring a Certificate Chain
If a certificate chain is used, then all certificates must be manually
concatenated into a single named certificate file. These certificates must
be placed in the following order:

* {product-title} master host certificate
* Intermediate CA certificate
* Root CA certificate
* Third party certificate

To create this certificate chain, concatenate the certificates into a
common file. You must run this command for each certificate and ensure
that they are in the previously defined order.

----
$ cat <certificate>.pem >> ca-chain.cert.pem
----

[[ansible-configuring-custom-certificates]]
== Configuring Custom Certificates During Installation

During cluster installations, custom certificates can be configured using the
`openshift_master_named_certificates` and
`openshift_master_overwrite_named_certificates` parameters, which are
configurable in the inventory file. More details are available about
xref:../install/configuring_inventory_file.adoc#advanced-install-custom-certificates[configuring custom certificates with Ansible].

.Custom Certificate Configuration Parameters
[source,yaml]
----
openshift_master_overwrite_named_certificates=true <1>
openshift_master_named_certificates=[{"certfile": "/path/on/host/to/crt-file", "keyfile": "/path/on/host/to/key-file", "names": ["public-master-host.com"], "cafile": "/path/on/host/to/ca-file"}] <2>
openshift_hosted_router_certificate={"certfile": "/path/on/host/to/app-crt-file", "keyfile": "/path/on/host/to/app-key-file", "cafile": "/path/on/host/to/app-ca-file"} <3>
----

<1> If you provide a value for the `openshift_master_named_certificates` parameter, set this parameter to `true`.
<2> Provisions a xref:configuring-custom-certificates-master[master API certificate].
<3> Provisions a xref:configuring-custom-certificates-wildcard[router wildcard certificate].

Example parameters for a master API certificate:
----
openshift_master_overwrite_named_certificates=true
openshift_master_named_certificates=[{"names": ["master.148.251.233.173.nip.io"], "certfile": "/home/cloud-user/master-bundle.cert.pem", "keyfile": "/home/cloud-user/master.148.251.233.173.nip.io.key.pem" ]
----

Example parameters for a router wildcard certificate:
----
openshift_hosted_router_certificate={"certfile": "/home/cloud-user/star-apps.148.251.233.173.nip.io.cert.pem", "keyfile": "/home/cloud-user/star-apps.148.251.233.173.nip.io.key.pem", "cafile": "/home/cloud-user/ca-chain.cert.pem"}
----

[[configuring-custom-certificates]]
== Configuring Custom Certificates for the Web Console or CLI

You can specify custom certificates for the web console and for the CLI through the
`servingInfo` section of the xref:../install_config/master_node_configuration.adoc#master-configuration-files[master
configuration file]:

* The `servingInfo.namedCertificates` section serves up custom certificates for the web console.
* The `servingInfo` section serves up custom certificates for the CLI and other API calls.

You can configure multiple certificates this way, and each certificate can be associated with
xref:configuring-custom-certificates-master[multiple host names], xref:configuring-custom-certificates-master[multiple routers], or the xref:configuring-custom-certificates-registry[{product-title} image registry].

A default certificate must be configured in the `servingInfo.certFile` and
`servingInfo.keyFile` configuration sections in addition to
`namedCertificates`.

[NOTE]
====
The `namedCertificates` section should be configured only for the host name
associated with the `masterPublicURL` and
`oauthConfig.assetPublicURL` settings in the *_/etc/origin/master/master-config.yaml_* file.
Using a custom serving certificate for
the host name associated with the `masterURL` will result in TLS errors as
infrastructure components will attempt to contact the master API using the
internal `masterURL` host.
====

.Custom Certificates Configuration

----
servingInfo:
  logoutURL: ""
  masterPublicURL: https://openshift.example.com:8443
  publicURL: https://openshift.example.com:8443/console/
  bindAddress: 0.0.0.0:8443
  bindNetwork: tcp4
  certFile: master.server.crt <1>
  clientCA: ""
  keyFile: master.server.key <1>
  maxRequestsInFlight: 0
  requestTimeoutSeconds: 0
  namedCertificates:
    - certFile: wildcard.example.com.crt <2>
      keyFile: wildcard.example.com.key <2>
      names:
        - "openshift.example.com"
  metricsPublicURL: "https://metrics.os.example.com/hawkular/metrics"

----

<1> Path to certificate and key files for the CLI and other API calls.
<2> Path to certificate and key files for the web console.

The `openshift_master_cluster_public_hostname` and `openshift_master_cluster_hostname` parameters in the xref:../install/configuring_inventory_file.adoc#configuring-ansible[Ansible inventory file], by default `/etc/ansible/hosts`, must be different. If they are the same, the named certificates will fail and you will need to re-install them.

----
# Native HA with External LB VIPs
openshift_master_cluster_hostname=internal.paas.example.com
openshift_master_cluster_public_hostname=external.paas.example.com
----

For more information on
using DNS with {product-title}, see the xref:../install/prerequisites.adoc#prereq-dns[DNS installation prerequisites].

This approach allows you to take advantage of the self-signed certificates generated by {product-title} and add custom trusted certificates to individual components as needed.

Note that the internal infrastructure certificates remain self-signed, which might be perceived as bad practice by some security or PKI teams. However, any risk here is minimal, as the only clients that trust these certificates are other components within the cluster. All external users and systems use custom trusted certificates.

Relative paths are resolved based on the location of the master configuration file. Restart
the server to pick up the configuration changes.

[[configuring-custom-certificates-master]]
== Configuring a Custom Master Host Certificate

In order to facilitate trusted connections with external users of {product-title}, you can provision a named certificate that matches the domain name provided in the `openshift_master_cluster_public_hostname` paramater in the xref:../install/configuring_inventory_file.adoc#configuring-ansible[Ansible inventory file],
by default `/etc/ansible/hosts`.

You must place this certificate in a directory accessible to Ansible and add the path in the
Ansible inventory file, as follows:

----
openshift_master_named_certificates=[{"certfile": "/path/to/console.ocp-c1.myorg.com.crt", "keyfile": "/path/to/console.ocp-c1.myorg.com.key", "names": ["console.ocp-c1.myorg.com"]}]
----

Where the parameter values are:

* *certfile* is the path to the file that contains the {product-title} custom master API certificate.

* *keyfile* is the path to the file that contains the {product-title} custom master API certificate key.

* *names* is the cluster public hostname.

// * *cafile* contains the root CA for this key and certificate. If an intermediate CA is in use, it must contain both the intermediate and root CA. "cafile": "/path/to/console.ocp-c1.myorg.com.ca.crt"


The file paths must be local to the system where Ansible runs. Certificates
are copied to master hosts and are deployed within the
*_/etc/origin/master_* directory.

When securing the registry, add the service hostnames and IP addresses to the server certificate for the registry.
The Subject Alternative Names (SAN) must contain the following.

* Two service hostnames:
+
----
docker-registry.default.svc.cluster.local
docker-registry.default.svc
----

* Service IP address.
+
For example:
+
----
172.30.252.46
----
+
Use the following command to get the container image registry service IP address:
+
----
oc get service docker-registry --template='{{.spec.clusterIP}}'
----

* Public hostname.
+
----
docker-registry-default.apps.example.com
----
+
Use the following command to get the container image registry public hostname:
+
----
oc get route docker-registry --template '{{.spec.host}}'
----

For example, the server certificate should contain SAN details similar to the following:

----
X509v3 Subject Alternative Name:
               DNS:docker-registry-public.openshift.com, DNS:docker-registry.default.svc, DNS:docker-registry.default.svc.cluster.local, DNS:172.30.2.98, IP Address:172.30.2.98
----

[[configuring-custom-certificates-wildcard]]
== Configuring a Custom Wildcard Certificate for the Default Router

You can configure the {product-title} default router with a default wildcard certificate. A default wildcard certificate provides a convenient way for
applications that are deployed in {product-title} to use default encryption without needing custom certificates.

[NOTE]
====
Default wildcard certificates are recommended for non-production environments only.
====

To configure a default wildcard certificate, provision a certificate that is
valid for `*.<app_domain>`, where `<app_domain>` is the value of
`openshift_master_default_subdomain` in the
xref:../install/configuring_inventory_file.adoc#configuring-ansible[Ansible
inventory file], by default `/etc/ansible/hosts`. Once provisioned, place the
certificate, key, and ca certificate files on your Ansible host, and add the
following line to your Ansible inventory file.

----
openshift_hosted_router_certificate={"certfile": "/path/to/apps.c1-ocp.myorg.com.crt", "keyfile": "/path/to/apps.c1-ocp.myorg.com.key", "cafile": "/path/to/apps.c1-ocp.myorg.com.ca.crt"}
----

For example:

----
openshift_hosted_router_certificate={"certfile": "/home/cloud-user/star-apps.148.251.233.173.nip.io.cert.pem", "keyfile": "/home/cloud-user/star-apps.148.251.233.173.nip.io.key.pem", "cafile": "/home/cloud-user/ca-chain.cert.pem"}
----

Where the parameter values are:

* *certfile* is the path to the file that contains the {product-title} router wildcard certificate.

* *keyfile* is the path to the file that contains the {product-title} router wildcard certificate key.

* *cafile* is the path to the file that contains the root CA for this key and certificate. If an intermediate CA is in use, the file should contain both the intermediate and root CA.

If these certificate files are new to your {product-title} cluster, change to the playbook directory and run the Ansible *_deploy_router.yml_* playbook to add these files to the {product-title} configuration files.
The playbook adds the certificate files to the *_/etc/origin/master/_* directory.

----
ifdef::openshift-enterprise[]
# ansible-playbook [-i /path/to/inventory] \
    /usr/share/ansible/openshift-ansible/playbooks/openshift-hosted/deploy_router.yml
endif::[]
ifdef::openshift-origin[]
# ansible-playbook [-i /path/to/inventory] \
    ~/openshift-ansible/playbooks/openshift-hosted/deploy_router.yml
endif::[]
----

If xref:../install_config/redeploying_certificates.adoc#redeploying-all-certificates-current-ca[the certificates are not new],
for example, you want to change existing certificates or replace expired certificates, change to the playbook directory and run the following playbook:

----
ansible-playbook /usr/share/ansible/openshift-ansible/playbooks/redeploy-certificates.yml
----

[NOTE]
For this playbook to run, the certificate names must not change. If the certificate names change, rerun the Ansible *_deploy_cluster.yml_* playbook
as if the certificates were new.

[[configuring-custom-certificates-registry]]
== Configuring a Custom Certificate for the Image Registry

The {product-title} image registry is an internal service that facilitates builds and deployments. Most of the communication with the registry is handled by internal components in {product-title}. As such, you should not need to replace the certificate used by the registry service itself.

However, by default, the registry uses routes to allow external systems and users to do pulls and pushes of images. You can use a _re-encrypt route_ with a custom certificate that is presented to external users instead of using the internal, self-signed certificate.

To configure this, add the
xref:../install/configuring_inventory_file.adoc#advanced-install-configuring-docker-route[following lines]
of code to the `[OSEv3:vars]` section of the Ansible inventory file, by default
*_/etc/ansible/hosts_* file. Specify the certificates to use with the registry
route.

----
openshift_hosted_registry_routehost=registry.apps.c1-ocp.myorg.com <1>
openshift_hosted_registry_routecertificates={"certfile": "/path/to/registry.apps.c1-ocp.myorg.com.crt", "keyfile": "/path/to/registry.apps.c1-ocp.myorg.com.key", "cafile": "/path/to/registry.apps.c1-ocp.myorg.com-ca.crt"} <2>
openshift_hosted_registry_routetermination=reencrypt <3>
----

//https://github.com/openshift/openshift-docs/issues/5765
<1> The host name of the registry.
<2> The locations of the *cacert*, *cert*, and *key* files.
+
* *certfile* is the path to the file that contains the {product-title} registry certificate.

* *keyfile* is the path to the file that contains the {product-title} registry certificate key.

* *cafile* is the path to the file that contains the root CA for this key and certificate. If an intermediate CA is in use, the file should contain both the intermediate and root CA.
<3> Specify where encryption is performed:
+
* Set to `reencrypt` with a _re-encrypt route_ to terminate encryption at the edge router and re-encrypt it with a new certificate supplied by the destination.
+
* Set to `passthrough` to terminate encryption at the destination. The destination is responsible for decrypting traffic.

[[configuring-custom-certificates-lb]]
== Configuring a Custom Certificate for a Load Balancer

If your {product-title} cluster uses the default load balancer or an enterprise-level load balancer,
you can use custom certificates to make the web console and API available externally using a publicly-signed custom certificate. leaving the existing internal certificates for
the internal endpoints.

To configure {product-title} to use custom certificates in this way:

. Edit the `servingInfo` section of the xref:../install_config/master_node_configuration.adoc#master-configuration-files[master configuration file]:
+
----
servingInfo:
  logoutURL: ""
  masterPublicURL: https://openshift.example.com:8443
  publicURL: https://openshift.example.com:8443/console/
  bindAddress: 0.0.0.0:8443
  bindNetwork: tcp4
  certFile: master.server.crt
  clientCA: ""
  keyFile: master.server.key
  maxRequestsInFlight: 0
  requestTimeoutSeconds: 0
  namedCertificates:
    - certFile: wildcard.example.com.crt <1>
      keyFile: wildcard.example.com.key <2>
      names:
        - "openshift.example.com"
  metricsPublicURL: "https://metrics.os.example.com/hawkular/metrics"
----
+
<1> Path to the certificate file for the web console.
+
<2> Path to the key file for the web console.
+
[NOTE]
====
Configure the  `namedCertificates` section for only the host name associated with the `masterPublicURL` and `oauthConfig.assetPublicURL` settings.
Using a custom serving certificate for the host name associated with the `masterURL` causes in TLS errors as infrastructure components
attempt to contact the master API using the internal masterURL host.
====

. Specify the `openshift_master_cluster_public_hostname` and `openshift_master_cluster_hostname` paramaters in the Ansible inventory file, by default *_/etc/ansible/hosts_*.
These values must be different. If they are the same, the named certificates will fail.
+
----
# Native HA with External LB VIPs
openshift_master_cluster_hostname=paas.example.com <1>
openshift_master_cluster_public_hostname=public.paas.example.com <2>
----
+
<1> The FQDN for internal load balancer configured for SSL passthrough.
+
<2> The FQDN for external the load balancer with custom (public) certificate.

For information specific to your load balancer environment, refer to link:https://access.redhat.com/documentation/en-us/reference_architectures/?category=openshift%2520container%2520platform&version=current%2520release[the {product-title} Reference Architecture for your provider] and link:http://v1.uncontained.io/playbooks/installation/load_balancing.html#custom-certificate-ssl-termination-production[Custom Certificate SSL Termination (Production)].

[[configuring-custom-certificates-retrofit]]
== Retrofit Custom Certificates into a Cluster

You can retrofit custom master and custom router certificates into an existing
{product-title} cluster.

[[configuring-custom-certificates-retrofit-master]]
=== Retrofit Custom Master Certificates into a Cluster

To retrofit custom certificates:

. Edit the Ansible inventory file to set the `openshift_master_overwrite_named_certificates=true`.

. Specify the path to the certificate using the `openshift_master_named_certificates` parameter.
+
[source,yaml]
----
openshift_master_overwrite_named_certificates=true
openshift_master_named_certificates=[{"certfile": "/path/on/host/to/crt-file", "keyfile": "/path/on/host/to/key-file", "names": ["public-master-host.com"], "cafile": "/path/on/host/to/ca-file"}] <1>
----
+
<1> Path to a xref:configuring-custom-certificates-master[master API certificate].

. Change to the playbook directory and run the following playbook:
+
----
ansible-playbook /usr/share/ansible/openshift-ansible/playbooks/redeploy-certificates.yml
----

. If you use xref:configuring-custom-certificates[named certificates]:
.. Update the certificate parameters in the  *_master-config.yaml_* file on each
master node.
.. Restart the {product-title} master service to apply the changes.
+
----
# master-restart api
# master-restart controllers
----

[[configuring-custom-certificates-retrofit-router]]
=== Retrofit Custom Router Certificates into a Cluster

To retrofit custom router certificates:

. Edit the Ansible inventory file to set the `openshift_master_overwrite_named_certificates=true`.

. Specify the path to the certificate using the `openshift_hosted_router_certificate` parameter.
+
[source,yaml]
----
openshift_master_overwrite_named_certificates=true
openshift_hosted_router_certificate={"certfile": "/path/on/host/to/app-crt-file", "keyfile": "/path/on/host/to/app-key-file", "cafile": "/path/on/host/to/app-ca-file"} <1>
----
+
<1> Path to a xref:configuring-custom-certificates-wildcard[router wildcard certificate].

. Change to the playbook directory and run the following playbook:
+
----
$ cd /usr/share/ansible/openshift-ansible
$ ansible-playbook playbooks/openshift-hosted/redeploy-router-certificates.yml
----

[[ansible-configuring-custom-certificates-other]]
== Using Custom Certificates with Other Components

For information on how other components, such as Logging & Metrics, use custom certificates, see
xref:../day_two_guide/certificate_management.adoc#admin-solutions-certificate-management[Certificate Management].
