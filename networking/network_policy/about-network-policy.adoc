[id="about-network-policy"]
= About network policy
include::modules/common-attributes.adoc[]
:context: about-network-policy

toc::[]

As a project administrator, you can define network policies that restrict traffic to or from selected pods.

[NOTE]
====
Network policies are namespace scoped and designed to allow project administrators to secure applications. A cluster administrator should therefore not attempt to use network policies to define cluster-wide network traffic policy, at the risk of those rules being overridden. 
====

What follows is a discussion of how network traffic isolation works with network policy in {product-title}.

[id="network-policy-concepts_{context}"]
== Network policy concepts

Network policy is deigned specifically to secure applications. You can use a network policy to control traffic flow at the IP address or port level for selected pods. The following concepts apply to network policy:

* Network policy applies to selected pods in the namespace in which the policy is defined.
* Network policy defines two types of rules:
** Ingress rules that allow traffic to other pods, namespaces, or IP address blocks.
** Egress rules that allow traffic from other pods, namespaces, or IP address blocks.
* Network policy supports the TCP, UDP, and SCTP protocols.
* Network policy supports specifying ports for supported protocols.

A network policy consists of three parts:

* Pod selector: Identifies which pods the network policy isolates. A pod selected by a pod selector is considered to be an _isolated pod_.
* Ingress and egress rules: Contains an additive list of  _network policy peers_ which define where traffic is allowed from or to.
* Policy types: Specifies whether the network policy includes ingress rules, egress rules, or both.

.Network policy object
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: policy-object-example
spec:
  podSelector: <.>
  ingress: [] <.>
  egress: [] <.>
  policyTypes: <.>
  - Ingress
  - Egress
----
<.> Pod selector.
<.> Optional: Ingress rules that define network policy peers in a particular namespace.
<.> Optional: Egress rules that define network policy peers in a particular namespace.
<.> Optional: Policy types defined by the network policy. If not specified, the default value is `Ingress`.

[id="policy-isolation-behavior_{context}"]
== Network policy pod isolation behavior

By default, all pods in a namespace are accessible from other pods and network endpoints. To isolate one or more pods in a namespace, you can create network policies in that namespace to indicate the allowed connections.

If a pod is matched by selectors in one or more network policies, then the pod will accept only connections that are allowed by at least one of those network policies.

If a pod is not selected by the pod selector of any network policy in the namespace that the pod exists, the pod is unaffected by network policy and all ingress and egress traffic is permitted.

If a namespace does have network policy rules defined then the following applies:

* If a pod is not selected by any ingress network policy rule selectors, then all ingress traffic is allowed to that pod
* If a pod is not selected by any egress network policy rule selectors, then all egress traffic is allowed from that pod

[IMPORTANT]
====
To ensure that pods in a particular namespace are isolated by default, it is recommended to always create a _deny ingress by default_ network policy that selects all pods in that namespace.
====

[id="requirements-for-network-policy_{context}"]
== Requirements for network policy

Your cluster must use a cluster network provider that supports the use of network policy, such as OVN-Kubernetes or OpenShift SDN with the network policy isolation mode configured.

ifeval::[{product-version} < 4.10]
[NOTE]
====
When using the OpenShift SDN cluster network provider, the following limitations apply regarding network policies:

* Egress network policy as specified by the `egress` field is not supported.
* IPBlock is supported by network policy, but without support for `except` clauses. If you create a policy with an IPBlock section that includes an `except` clause, the SDN pods log warnings and the entire IPBlock section of that policy is ignored.
====
endif::[]

By default, the following roles can create, edit, and delete a network policy:

* `cluster-admin`
* `admin`

// Duplicated here because this is really important for cluster admins to know.
[NOTE]
====
Any network policies defined by a cluster administrator can be overridden by a project administrator. Do not use network policies to define cluster-wide network traffic policy.
====

[id="limitations-of-network-policy_{context}"]
== Limitations of network policy

The following limitations apply to the use of network policy:

* You cannot use network policy with host network to host network traffic.

Additionally, network policy has the following limitations when a host network pod is involved:

* When a pod network pod tries to connect to a host network pod, the traffic is affected by egress network policies that match the pod network pod, but the traffic is unaffected by ingress policies that match the host network pod.
* When a host network pod tries to connect to a pod network pod, the following behaviors apply:
** If there is an `allow-from-host-network` policy defined that matches the pod network pod, then the traffic is allowed.
** If the aforementioned policy is not defined, then the behavior is undefined. Even if a network policy blocks all ingress traffic to the pod network pod, it is possible a host network pod can connect to it. The behavior is not consistent across Container Network Interface (CNI) plug-ins.

[id="types-of-network-traffic-supported_{context}"]
== Network traffic protocols supported

You can define a network policy for only the TCP, UDP, and SCTP network protocols.

[id="types-of-network-policy-rules_{context}"]
== Types of network policy rules

Network policy supports the following policy rules:

* Ingress
* Egress

A network policy can contain both ingress and egress network policy rules.

Network policy rules are additive and only apply to one end of the connection. If the source pod is selected via an allow policy but the destination pod is selected via a deny policy then the traffic will be dropped.

For example, if an ingress network policy rule allows a destination pod to receive traffic from a source pod, but the source pod is restricted from communicating with the destination pod with an egress network policy rule, the connection is blocked.

When using ingress and egress policy rules, the following guidelines apply:

* Use ingress policy to control which other pods can connect to your services.
* Use egress policy only if necessary to control outbound traffic to IP address blocks.
* Use the least number of network policies necessary; {product-title} does not prevent the creation of redundant network policies.

[NOTE]
====
If you are using the OpenShift SDN cluster network provider, only the ingress policy type is supported.
====

[id="policy-scope_{context}"]
== Network policy scope

A network policy is scoped to a specific namespace and can be further limited to a specific subset of pods in that namespace.

If multiple network policies are defined in a namespace they are applied additively, which means network policies can be created in any order.

[id="policy-isolation_{context}"]
== Network policy isolation of network traffic

A network policy can apply to the following network traffic flows:

* Traffic between pods in the same namespace
* Traffic between pods in different namespaces
* Traffic from an IP address block to a pod
* Traffic to an IP address block from a pod

[id="select-pods-that-a-policy-isolates_{context}"]
== Selection of pods that a policy isolates

A pod selector identifies the set of pods that a network policy isolates. You can isolate all pods in a namespace or selectively apply a network policy to a subset of pods.

If you specify an empty selector, the policy applies to all pods in the namespace where the network policy is defined. For example, the following network policy allows all ingress traffic from port `443` to all pods in the namespace:

[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: allow-all-https
spec:
  podSelector: {}
  ingress:
  - ports:
    - port: 443
----

If you specify a pod selector, the network policy isolation applies to only the pods that match that selector.

== Network policy peers

When you define a network policy, each policy rule describes the network policy peers that the network policy applies to. This peer group is the set of pods for which ingress or egress traffic is restricted. You can also specify network policy peers by IP address block if necessary.

[id="select-pods-that-a-policy-rule-applies-to_{context}"]
=== Selection of network policy peers

The specific behavior for network policy peer selectors is as follows:

* If only a namespace selector is used then a policy rule applies to all pods in that namespace.
* If only a pod selector is used then a policy rule applies to only the namespace in which the network policy is defined.
* If both a namespace selector and pod selector are used in a policy rule then only pods that satisfy both selectors are selected.

The following examples illustrate the rule selector behavior.

* In a namespace with the `namespace-name: web` label, match all pods as network policy peers:
+
.Example network policy with a `namespaceSelector` field
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: ingress-namespace-selector
spec:
  podSelector:
  ingress:
  - namespaceSelector:
      matchLabels:
ifeval::[{product-version} < 4.8]
        networking-namespace: web
endif::[]
ifeval::[{product-version} >= 4.8]
        kubernetes.io/metadata.name: web
endif::[]
  policyTypes:
  - Ingress
----

* In the local namespace, match all pods with `deployment: blue` as network policy peers:
+
.Example network policy with a `podSelector` field
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: ingress-pod-selector
spec:
  podSelector:
  ingress:
  - podSelector:
      matchLabels:
        deployment: blue
  policyTypes:
  - Ingress
----

* In a namespace with the `namespace-name: web` label, match pods with the `deployment: blue` label as network policy peers:
+
.Example network policy with `namespaceSelector` and `podSelector` fields
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: ingress-combined-selector
spec:
  podSelector:
  ingress:
  - podSelector:
      matchLabels:
        deployment: blue
    namespaceSelector:
      matchLabels:
ifeval::[{product-version} < 4.8]
        namespace-name: web
endif::[]
ifeval::[{product-version} >= 4.8]
        kubernetes.io/metadata.name: web
endif::[]
  policyTypes:
  - Ingress
----

ifeval::[{product-version} < 4.8]
[NOTE]
====
A namespace does not have a label by default. To add a label to a namespace as a target for a namespace selector, add a label such as with the `oc label namespace <name> namespace-name=<name>` command. Replace `<name>` with the name of the namespace the label is applied to.
====
endif::[]
// This might not actually be available in OCP at all; Confirm.
ifeval::[{product-version} >= 4.8]
[NOTE]
====
Beginning with {product-title} 4.8, which is based on Kubernetes 1.21, link:https://kubernetes.io/docs/reference/labels-annotations-taints/#kubernetes-io-metadata-name[the following label is added automatically to each namespace]:

[source,yaml]
----
metadata:
  name: <name>
  labels:
    kubernetes.io/metadata.name: <name>
----
====
endif::[]

// Labels that a selector can target, not a selector itself.
[id="available-selector-policy-groups_{context}"]
=== Available labels for existing policy groups

Several custom labels are available in {product-title} that you can use to select network policy peers in specific cases:

`policy-group.network.openshift.io/ingress: ""`::
+
--
Selects all Ingress Controller router pods.

While the deprecated label `network.openshift.io/policy-group: ingress` continues to work, its use is not recommended.

If you expose a service from a namespace where you have defined network policies, you can use this label to ensure that incoming traffic from the router pods is allowed. A service is typically exposed with the `oc expose service` command.

.Example network policy to allow ingress from router pods
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: web-allow-router
spec:
  podSelector:
    matchLabels:
      app: web
  ingress:
  - from:
    - namespaceSelector:
      policy-group.network.openshift.io/ingress: ""
    ports:
    - port: 4443
----

[NOTE]
====
If your `default` Ingress Controller runs on the host network, this namespace selector also allows all traffic for the host network. You can determine if your `default` Ingress Controller uses the `HostNetwork` endpoint publishing strategy with the following command:

[source,terminal]
----
$ oc get --namespace openshift-ingress-operator ingresscontrollers/default \
  --output jsonpath='{.status.endpointPublishingStrategy.type}'
----

If the previous command reports the endpoint publishing strategy as `HostNetwork`, then your `default` Ingress Controller is on the host network.
====
--

`policy-group.network.openshift.io/host-network`: ""::
Selects all host network traffic. You cannot combine this namespace selector with a pod selector.

[id="policy-rules_{context}"]
== Policy rules

A network policy must specify one or more policy rules that identifies what ingress or egress traffic is permitted for pods that the network policy isolates.

[id="policy-rule-precedence_{context}"]
=== Isolate by default

When defining network policies, it is recommended to always first define a deny by default policy for the namespace. Because network policies are additive, any subsequent network policy rules for an isolated pod allows network traffic from only the network policy peers selected by the policy.

For example, consider the following network policies:

[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: deny-all
spec:
  podSelector: {}
  ingress: []
---
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: web-allow-http
spec:
  podSelector:
    matchLabels:
      app: web
  ingress:
  - from:
    - podSelector: {}
    ports:
    - port: 8088
----

In the previous example, the `deny-all` network policy isolates all pods in the namespace and does not allow any ingress traffic. The `web-allow-http` network policy also isolates the `app: web` pods and allows traffic to the selected pods on port 8088 from all pods in the local namespace.

Because a default deny policy is defined in this namespace, all pods are isolated and therefore all ingress traffic is disallowed. This approach ensures that no pods in a namespace are unintentionally left open to ingress traffic.

[id="restrictions-by-ports-protocols_{context}"]
=== Restrictions by ports and protocols

You can restrict traffic by port and protocol. The following conditions apply:

- If you do not specify a port or a protocol, the policy rule applies to all traffic types on all ports
- If you specify a protocol but omit a port then the default is all ports
- If you specify a port but omit a protocol then the default protocol is TCP

[id="restrictions-by-ip_adress-blocks_{context}"]
=== Restrictions by IP address blocks

In addition to selectors for pods and namespaces, you can define a network policy rule that selects an IP address block specified in CIDR form. Optionally, you can exclude one or more subsets of the IP address block. Because pod IP addresses are ephemeral, IP blocks should be for networks external to the cluster.

[NOTE]
====
If IP addresses are rewritten during packet handling, whether this address manipulation happens before or after network policy processing, the behavior of network policy is undefined. For more information, see link:https://kubernetes.io/docs/concepts/services-networking/network-policies/#behavior-of-ipblock-selectors[ipBlock].
====

.Example ingress rule that matches an IP address block
[source,yaml]
----
kind: NetworkPolicy # Valid
apiVersion: networking.k8s.io/v1
metadata:
  name: <name>
spec:
  egress:
  - to:
    - ipBlock:
        cidr: 172.17.0.0/16
        except:
        - 172.17.1.0/24
        - 172.17.2.0/24
----

In the previous example, the network policy allows egress traffic to the `172.17.0.0/16` IP address block, except for traffic from the `172.17.1.0/24` and `172.17.2.0/24` IP address blocks.

////
Spec:
  PodSelector:     <none> (Allowing the specific traffic to all pods in this namespace)
  Allowing ingress traffic:
    To Port: <any> (traffic allowed to all ports)
    From:
      IPBlock:
        CIDR: 172.17.0.0/16
        Except: 172.17.1.0/24
  Not affecting egress traffic
  Policy Types: Ingress
////

[id="policy-rule-behavior-with-an-empty-selector_{context}"]
=== Behavior with an empty selector

When specifying a network policy rule selector for network policy peers, you can specify an empty pod or namespace selector. The following behavior applies when using an empty selector:

* If a network policy ingress or egress rule uses an empty namespace selector, the policy applies to all pods in all namespaces. For example:
+
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: allow-only-db-pods
spec:
  podSelector: {}
  ingress:
    from:
    - namespaceSelector: {}
      podSelector:
        matchLabels:
          app: db
      ports:
      - port: 5432
----

* If a network policy ingress or egress rule uses an empty pod selector, the policy applies to all pods in the selected namespaces. For example:
+
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: allow-only-db-https-ns
spec:
  podSelector: {}
  ingress:
    from:
    - namespaceSelector:
        matchLabels:
          app: web
      podSelector: {}
      ports:
      - port: 443
----

[id="policy-rule-behavior-with-an-empty-ingress-or-egress-rule-set_{context}"]
=== Behavior with an empty ingress or egress rule set

If you define a network policy rule with an empty list, the network policy does not allow any traffic.

For example, the following ingress rule allows no ingress traffic:

.Example ingress ruleset defined as an empty list
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: <name>
spec:
  ingress: []
----

////
Name:         name1
Namespace:    default
Created on:   2021-06-28 21:11:24 -0400 EDT
Labels:       <none>
Annotations:  <none>
Spec:
  PodSelector:     <none> (Allowing the specific traffic to all pods in this namespace)
  Allowing ingress traffic:
    <none> (Selected pods are isolated for ingress connectivity)
  Not affecting egress traffic
  Policy Types: Ingress
////

An empty rule set is the inverse of a rule set with a single empty selector, which selects and allows all traffic. For example, the following ingress rule set selects all ingress traffic:

.Example ingress ruleset with a single empty selector
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
spec:
  ingress:
  - {}
----

////
Spec:
  PodSelector:     <none> (Allowing the specific traffic to all pods in this namespace)
  Allowing ingress traffic:
    To Port: <any> (traffic allowed to all ports)
    From: <any> (traffic not restricted by source)
  Not affecting egress traffic
  Policy Types: Ingress
////

The previous example is identical in behavior to the following example:

.Example ingress ruleset that matches all ingress traffic
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
spec:
  ingress:
  - from:
    - podSelector: {}
      namespaceSelector: {}
----

////
Spec:
  PodSelector:     <none> (Allowing the specific traffic to all pods in this namespace)
  Allowing ingress traffic:
    To Port: <any> (traffic allowed to all ports)
    From:
      NamespaceSelector: <none>
      PodSelector: <none>
  Not affecting egress traffic
  Policy Types: Ingress
////

[id="network-policy-examples"]
== Network policy examples

The following example `NetworkPolicy` objects demonstrate supporting different scenarios:

* Deny all traffic:
+
To make a project deny by default, add a `NetworkPolicy` object that matches all pods but accepts no traffic:
+
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: deny-by-default
spec:
  podSelector: {}
  ingress: []
----

* Only allow connections from the {product-title} Ingress Controller:
+
To make a project allow only connections from the {product-title} Ingress Controller, add the following `NetworkPolicy` object.
+
[source,yaml]
----
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-from-openshift-ingress
spec:
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          network.openshift.io/policy-group: ingress
  podSelector: {}
  policyTypes:
  - Ingress
----

* Only accept connections from pods within a project:
+
To make pods accept connections from other pods in the same project, but reject all other connections from pods in other projects, add the following `NetworkPolicy` object:
+
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: allow-same-namespace
spec:
  podSelector: {}
  ingress:
  - from:
    - podSelector: {}
----

* Only allow HTTP and HTTPS traffic based on pod labels:
+
To enable only HTTP and HTTPS access to the pods with a specific label (`role=frontend` in following example), add a `NetworkPolicy` object similar to the following:
+
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: allow-http-and-https
spec:
  podSelector:
    matchLabels:
      role: frontend
  ingress:
  - ports:
    - protocol: TCP
      port: 80
    - protocol: TCP
      port: 443
----

* Accept connections by using both namespace and pod selectors:
+
To match network traffic by combining namespace and pod selectors, you can use a `NetworkPolicy` object similar to the following:
+
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: allow-pod-and-namespace-both
spec:
  podSelector:
    matchLabels:
      name: test-pods
  ingress:
    - from:
      - namespaceSelector:
          matchLabels:
            project: project_name
        podSelector:
          matchLabels:
            name: test-pods
----

`NetworkPolicy` objects are additive, which means you can combine multiple `NetworkPolicy` objects together to satisfy complex network requirements.

For example, for the `NetworkPolicy` objects defined in previous samples, you can define both `allow-same-namespace` and `allow-http-and-https` policies within the same project. Thus allowing the pods with the label `role=frontend`, to accept any connection allowed by each policy. That is, connections on any port from pods in the same namespace, and connections on ports `80` and `443` from pods in any namespace.

//include::modules/nw-networkpolicy-about.adoc[leveloffset=+1]
//include::modules/nw-networkpolicy-optimize.adoc[leveloffset=+1]

[id="about-network-policy-next-steps"]
== Next steps

* xref:../../networking/network_policy/creating-network-policy.adoc#creating-network-policy[Creating a network policy]
* Optional: xref:../../networking/network_policy/default-network-policy.adoc#default-network-policy[Defining a default network policy]

[id="about-network-policy-additional-resources"]
== Additional resources

* xref:../../networking/network_policy/multitenant-network-policy.adoc#multitenant-network-policy[Configuring multitenant network policy]
* xref:../../rest_api/network_apis/networkpolicy-networking-k8s-io-v1.adoc#networkpolicy-networking-k8s-io-v1[NetworkPolicy API]
