
[[openshift-tutorial-terms]]
= Some Terminology
{product-author}
{product-version}
:data-uri:
:icons:
:experimental:
:toc: macro
:toc-title:

toc::[]
{nbsp} +

Before we get to far in, we need to get some things straight. This topic describes the terminology that we use in this tutorial and that you will use everytime you work with {product-title}.

image::terms.png[terms, 594,254, align="center"]

Namespace::

_Namespaces_ are a Kubernetes concept and we really don't talk much about them in {product-title}.

Kubernetes defines namespaces as link:https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/[_multiple virtual clusters backed by the same physical cluster_]. They state that link:https://kubernetes.io/docs/tasks/administer-cluster/namespaces-walkthrough/[_namespace provides the scope for pods, services, and deployments in the cluster_]. 

[TIP]
====
Don't worry, we will define those terms later, too
====

image::project-namespace.png[projects, 409,400, float="right"]

Namespaces, essentially, provide a mechanism for different users, teams, customers, and so forth to share a cluster. Namespaces are identified by a user-specified name and an internally-provided UID (unique identifier). 

One thing that namespaces do not do well is preventing users from accessing other namespaces. That is where projects come in.

Projects:: 
A _project_ is an {product-title} implementation of a Kubernetes namespace. You can think of a project as a wrapper for a name space. 

xref:../../architecture/core_concepts/projects_and_users.html#projects[Projects] provide everything that namespaces provide, but with additional tools, including the security that namespaces lack. You can control which users can access which namespaces and communication between projects is not allowed. 

Most users interact with most objects and resources through projects. 

Nodes::
A _node_ is the physical system where pod and their containers reside. 

xref:../../architecture/infrastructure_components/kubernetes_infrastructure.html#node[Nodes] contain the services required to run pods and containers, including the container runtime service, the Kubernetes (Kubelet) service, and a simple network proxy. 

In short, {product-title} is comprised of the following nodes:

* *Master*. The master node is where the administrator manages other nodes in a cluster and schedules pods to run on nodes.
* *Infrastructure*. Infrastructure nodes are nodes that are labeled to run pieces of the OpenShift Container Platform environment.
* *Nodes*. The other nodes are where the pods and containers reside. 

OpenShift Container Platform creates nodes from a cloud provider, physical systems, or virtual systems. 

[[openshift-tutorial-terms-pod]]
Pod::
A _pod_ is simply a collection of one or more containers on the same host. Pods can be thought of as analagous to a physical system where containers are installed.

Because all of the containers in a pod are on the same phyical system, the containers can share resources such as storage. Each pod has a dedicated IP address that is load balanced through a service (which is defined next). 

//http://demandware.edgesuite.net/abaq_prd/on/demandware.static/-/Sites-siteCatalog_Burpee_US/default/dw8b3edca3/Category%20Content%20Images/CLP%20Vegetables/CATID-2470_Peas.jpg

image::pods.png[projects, 409,400, float="right"]
[[openshift-tutorial-terms-service]]
Service::
A _service_ is an abstraction that defines a set of pods. xref:../../architecture/core_concepts/pods_and_services.html#services[Services] identify a set of replicated pods in order to proxy the connections to the pods, acting as a front-end to the pods. Back-end pods can be added to or removed from a service while the service remains consistently available, enabling anything that depends on the service to refer to it at a consistent address.  

Services are associated with pods through label selectors in the pod that match to labels (key/value pairs) in the pod specification.

Users can access services using either the service IP address/port combination or the service name. 

[[openshift-tutorial-terms-container]]
Containers::
Containers are where the work happens. 

Docker tells you that containers link:https://www.docker.com/what-container[package code and dependencies together]. But, you can think of a container as a virtual machine -- a virtual machine that usually runs a single process (often called a "micro-service"), such as a web server or a database, though containers can be used for arbitrary workloads.

image::node.png[node, 562,347 align="center"]

Containers contain a complete filesystem containing everything it needs to run. The can communicate and can share volumes (persistent storage). 

*Remember!*

image::containertopods.png[container, align="left"]

Containers are created from image files, which are stanard *.tar* file that describe the entire contrainer file system with all libraries, working directories, and metadata.

[[openshift-tutorial-terms-route]]
Route::
A _route_ exposes a service at a host name. In other words, makes services accessible.

Each route consists of a name (limited to 63 characters), a service selector, and an optional security configuration.

Creating routes through the CLI or web console deploys a virtual router to allow external access to services and performs load balancing. 

[[openshift-tutorial-terms-images]]
Images::
_Images_ are essentially templates for creating containers.

An xref:../../architecture/core_concepts/containers_and_images.html#docker-images[image] is a binary that includes all of the requirements for running a single container, including the code, a run time, environment variables, and configuration files.

[[openshift-tutorial-terms-builds]]
Builds::
The {product-title} documentation says that a xref:../../architecture/core_concepts/builds_and_image_streams.html#builds[_build is the process of transforming input parameters into a resulting object_].

But, you can think of a build as how you turn your source code into a runnable image.

* A *Docker build* converts a Dockerfile into an image in a Docker registry. You can simply edit an existing Dockerfile (a text file) and add new commands. 
 
* A *Source-to-Image (S2I) build* transforms your application source into an executable Dockerimage that you can later use in {project-title}. This allows you to make changes to your application without needing to understand anything about the underlying Docker image.

* A *custom build* uses a plain Docker-formatted container image embedded with build process logic, for example for building RPMs or base images.

* A *pipeline build* allows developers to define a Jenkins pipeline for execution by the Jenkins pipeline plugin. 

Whatever method you choose, the _BuildConfig_ file contains the configuration data that determines how to manage your build.     


Replication Controllers::
A framework for defining pods that are meant to be horizontally scaled. A replication controller includes a pod definition that is to be replicated, and the pods created from it can be scheduled to different nodes.

Deployment Configurations (dc)::
Represent a set of pods created from the same container image, managing workflows such as rolling updates. A dc also provides a basic but extensible Continuous Delivery workflow.

Build Configurations (bc)::

Used by the OpenShift Source-to-Image (S2I) feature to build a container image from application source code stored in a Git server. A bc works together with a dc to provide a basic but extensible Continuous Integration/Continuous Delivery workflow.

Persistent Volumes (PV)::
Provision persistent networked storage to pods that can be mounted inside a container to store data.

Persistent Volume Claims (PVC)::
Represent a request for storage by a pod to Kubernetes. 

Routes::
Represent a DNS host name recognized by the OpenShift router as an ingress point for applications and microservices.



== Next Up

Now that you have some understanding of critical {product-title} terms, let's try a xref:../openshift-tutorial/tutorial-install.adoc#openshift-tutorial-install[installing {product-title}].  






